# 方块数据操作

NetherGate 提供了强大的方块数据读写功能，让你可以轻松读取和修改容器（箱子、漏斗等）的物品数据。

---

## 📋 **目录**

- [快速开始](#快速开始)
- [读取数据](#读取数据)
- [写入数据](#写入数据)
- [支持的容器](#支持的容器)
- [实战示例](#实战示例)
- [最佳实践](#最佳实践)

---

## 🚀 **快速开始**

### **获取服务实例**

```csharp
public class MyPlugin : IPlugin
{
    private IBlockDataReader _blockReader;
    private IBlockDataWriter _blockWriter;
    
    public void OnEnable(IPluginContext context)
    {
        _blockReader = context.BlockDataReader;
        _blockWriter = context.BlockDataWriter;
    }
}
```

### **简单示例**

```csharp
// 读取箱子内容
var position = new Position(100, 64, 200);
var items = await _blockReader.GetChestItemsAsync(position);

// 输出物品信息
foreach (var item in items)
{
    _logger.Info($"槽位 {item.Slot}: {item.Id} x{item.Count}");
}

// 修改箱子内容
var newItems = items.Where(i => i.Id.Contains("diamond")).ToList();
await _blockWriter.SetContainerItemsAsync(position, newItems);
```

---

## 📖 **读取数据**

### **IBlockDataReader 接口**

```csharp
public interface IBlockDataReader
{
    /// <summary>
    /// 读取箱子物品
    /// </summary>
    Task<List<ItemStack>> GetChestItemsAsync(Position position);
    
    /// <summary>
    /// 读取容器物品（通用方法）
    /// </summary>
    Task<List<ItemStack>> GetContainerItemsAsync(Position position);
    
    /// <summary>
    /// 读取方块 NBT 数据
    /// </summary>
    Task<NbtCompound> GetBlockDataAsync(Position position);
    
    /// <summary>
    /// 读取方块 ID
    /// </summary>
    Task<string> GetBlockIdAsync(Position position);
}
```

### **读取箱子**

```csharp
var chestPos = new Position(100, 64, 200);
var items = await _blockReader.GetChestItemsAsync(chestPos);

// 统计物品
var totalItems = items.Count;
var diamondCount = items
    .Where(i => i.Id == "minecraft:diamond")
    .Sum(i => i.Count);

_logger.Info($"箱子有 {totalItems} 个物品，其中 {diamondCount} 个钻石");
```

### **读取其他容器**

```csharp
// 读取漏斗
var hopperItems = await _blockReader.GetContainerItemsAsync(hopperPos);

// 读取潜影盒
var shulkerItems = await _blockReader.GetContainerItemsAsync(shulkerPos);

// 读取发射器
var dispenserItems = await _blockReader.GetContainerItemsAsync(dispenserPos);
```

### **读取方块数据**

```csharp
// 读取完整的 NBT 数据
var nbtData = await _blockReader.GetBlockDataAsync(position);

// 访问自定义数据
if (nbtData.TryGet("CustomName", out NbtString customName))
{
    _logger.Info($"自定义名称: {customName.Value}");
}

// 读取方块 ID
var blockId = await _blockReader.GetBlockIdAsync(position);
_logger.Info($"方块类型: {blockId}");
```

---

## ✍️ **写入数据**

### **IBlockDataWriter 接口**

```csharp
public interface IBlockDataWriter
{
    /// <summary>
    /// 设置容器物品
    /// </summary>
    Task SetContainerItemsAsync(Position position, List<ItemStack> items);
    
    /// <summary>
    /// 添加物品到容器
    /// </summary>
    Task AddItemsToContainerAsync(Position position, List<ItemStack> items);
    
    /// <summary>
    /// 清空容器
    /// </summary>
    Task ClearContainerAsync(Position position);
    
    /// <summary>
    /// 修改方块 NBT 数据
    /// </summary>
    Task SetBlockDataAsync(Position position, NbtCompound data);
}
```

### **设置容器内容**

```csharp
// 创建物品列表
var items = new List<ItemStack>
{
    new ItemStack
    {
        Slot = 0,
        Id = "minecraft:diamond",
        Count = 64
    },
    new ItemStack
    {
        Slot = 1,
        Id = "minecraft:gold_ingot",
        Count = 32
    }
};

// 写入到箱子
await _blockWriter.SetContainerItemsAsync(chestPos, items);
```

### **添加物品**

```csharp
// 添加物品（不会覆盖现有内容）
var newItems = new List<ItemStack>
{
    new ItemStack { Id = "minecraft:emerald", Count = 16 }
};

await _blockWriter.AddItemsToContainerAsync(chestPos, newItems);
```

### **清空容器**

```csharp
// 清空箱子
await _blockWriter.ClearContainerAsync(chestPos);
```

### **修改 NBT 数据**

```csharp
// 设置箱子的自定义名称
var nbtData = new NbtCompound("BlockData")
{
    new NbtString("CustomName", "{\"text\":\"我的箱子\"}")
};

await _blockWriter.SetBlockDataAsync(chestPos, nbtData);
```

---

## 📦 **支持的容器**

| 容器类型 | 方块 ID | 槽位数 | 说明 |
|---------|---------|--------|------|
| **箱子** | `minecraft:chest` | 27 | 普通箱子 |
| **大箱子** | `minecraft:chest` (双) | 54 | 两个箱子并排 |
| **潜影盒** | `minecraft:shulker_box` | 27 | 可携带的箱子 |
| **漏斗** | `minecraft:hopper` | 5 | 自动传输物品 |
| **发射器** | `minecraft:dispenser` | 9 | 发射物品 |
| **投掷器** | `minecraft:dropper` | 9 | 投掷物品 |
| **熔炉** | `minecraft:furnace` | 3 | 输入、燃料、输出 |
| **烟熏炉** | `minecraft:smoker` | 3 | 快速烹饪食物 |
| **高炉** | `minecraft:blast_furnace` | 3 | 快速冶炼矿物 |
| **酿造台** | `minecraft:brewing_stand` | 5 | 酿造药水 |
| **末影箱** | `minecraft:ender_chest` | 27 | 玩家专属存储 |

---

## 💼 **实战示例**

### **示例1：箱子整理命令**

```csharp
public class SortChestCommand : ICommand
{
    public async Task<CommandResult> ExecuteAsync(ICommandSender sender, string[] args)
    {
        var pos = ParsePosition(args);
        
        // 读取箱子内容
        var items = await _blockReader.GetChestItemsAsync(pos);
        
        if (items.Count == 0)
        {
            return CommandResult.Fail("箱子是空的");
        }
        
        // 排序：按物品ID排序
        var sorted = items
            .OrderBy(i => i.Id)
            .ThenByDescending(i => i.Count)
            .Select((item, index) => new ItemStack
            {
                Slot = (byte)index,
                Id = item.Id,
                Count = item.Count,
                Tag = item.Tag
            })
            .ToList();
        
        // 写回箱子
        await _blockWriter.SetContainerItemsAsync(pos, sorted);
        
        return CommandResult.Ok($"已整理 {items.Count} 个物品");
    }
}
```

### **示例2：批量填充箱子**

```csharp
public class FillChestCommand : ICommand
{
    public async Task<CommandResult> ExecuteAsync(ICommandSender sender, string[] args)
    {
        var pos = ParsePosition(args[0]);
        var itemId = args[1];
        var count = int.Parse(args[2]);
        
        // 创建物品列表
        var items = new List<ItemStack>();
        var maxStackSize = 64;
        var slot = 0;
        
        while (count > 0 && slot < 27)
        {
            var stackCount = Math.Min(count, maxStackSize);
            items.Add(new ItemStack
            {
                Slot = (byte)slot,
                Id = itemId,
                Count = (byte)stackCount
            });
            
            count -= stackCount;
            slot++;
        }
        
        // 写入箱子
        await _blockWriter.SetContainerItemsAsync(pos, items);
        
        return CommandResult.Ok($"已填充 {items.Count} 组物品");
    }
}
```

### **示例3：箱子复制**

```csharp
public class CopyChestCommand : ICommand
{
    public async Task<CommandResult> ExecuteAsync(ICommandSender sender, string[] args)
    {
        var sourcePos = ParsePosition(args[0]);
        var targetPos = ParsePosition(args[1]);
        
        // 读取源箱子
        var items = await _blockReader.GetChestItemsAsync(sourcePos);
        
        // 复制到目标箱子
        await _blockWriter.SetContainerItemsAsync(targetPos, items);
        
        return CommandResult.Ok($"已复制 {items.Count} 个物品");
    }
}
```

### **示例4：物品搜索系统**

```csharp
public class FindItemCommand : ICommand
{
    public async Task<CommandResult> ExecuteAsync(ICommandSender sender, string[] args)
    {
        var itemId = args[0];
        var searchRadius = int.Parse(args[1]);
        var playerPos = await GetPlayerPositionAsync(sender.Name);
        
        var results = new List<(Position, int)>();
        
        // 扫描周围的箱子
        var positions = playerPos.GetSurroundingPositions(searchRadius);
        
        foreach (var pos in positions)
        {
            var blockId = await _blockReader.GetBlockIdAsync(pos);
            
            if (blockId == "minecraft:chest")
            {
                var items = await _blockReader.GetChestItemsAsync(pos);
                var count = items
                    .Where(i => i.Id == itemId)
                    .Sum(i => i.Count);
                
                if (count > 0)
                {
                    results.Add((pos, count));
                }
            }
        }
        
        if (results.Count == 0)
        {
            return CommandResult.Fail($"未找到 {itemId}");
        }
        
        var report = new StringBuilder();
        report.AppendLine($"找到 {results.Count} 个箱子包含 {itemId}:");
        
        foreach (var (pos, count) in results.OrderByDescending(r => r.Item2))
        {
            report.AppendLine($"  {pos.ToFormattedString()}: {count} 个");
        }
        
        return CommandResult.Ok(report.ToString());
    }
}
```

### **示例5：自动压缩系统**

```csharp
public class CompressChestCommand : ICommand
{
    private readonly Dictionary<string, string> _compressionRecipes = new()
    {
        { "minecraft:iron_ingot", "minecraft:iron_block" },      // 9个铁锭 -> 1个铁块
        { "minecraft:gold_ingot", "minecraft:gold_block" },
        { "minecraft:diamond", "minecraft:diamond_block" },
        { "minecraft:emerald", "minecraft:emerald_block" },
        { "minecraft:coal", "minecraft:coal_block" }
    };
    
    public async Task<CommandResult> ExecuteAsync(ICommandSender sender, string[] args)
    {
        var pos = ParsePosition(args);
        var items = await _blockReader.GetChestItemsAsync(pos);
        
        var compressed = new List<ItemStack>();
        var itemGroups = items.GroupBy(i => i.Id);
        
        foreach (var group in itemGroups)
        {
            var totalCount = group.Sum(i => i.Count);
            var itemId = group.Key;
            
            // 检查是否可以压缩
            if (_compressionRecipes.TryGetValue(itemId, out var blockId))
            {
                var blocks = totalCount / 9;
                var remainder = totalCount % 9;
                
                // 添加压缩后的方块
                if (blocks > 0)
                {
                    compressed.Add(new ItemStack
                    {
                        Id = blockId,
                        Count = (byte)blocks
                    });
                }
                
                // 添加剩余的物品
                if (remainder > 0)
                {
                    compressed.Add(new ItemStack
                    {
                        Id = itemId,
                        Count = (byte)remainder
                    });
                }
            }
            else
            {
                // 不能压缩的物品直接保留
                compressed.AddRange(group);
            }
        }
        
        // 重新分配槽位
        for (int i = 0; i < compressed.Count; i++)
        {
            compressed[i].Slot = (byte)i;
        }
        
        await _blockWriter.SetContainerItemsAsync(pos, compressed);
        
        return CommandResult.Ok($"压缩完成，从 {items.Count} 减少到 {compressed.Count} 组");
    }
}
```

### **示例6：箱子商店系统**

```csharp
public class ChestShopPlugin : IPlugin
{
    private readonly Dictionary<Position, ShopConfig> _shops = new();
    
    public void OnEnable(IPluginContext context)
    {
        // 监听箱子交互
        context.EventBus.Subscribe<PlayerInteractEvent>(async e =>
        {
            if (e.Action != InteractionAction.RightClick) return;
            
            var pos = e.BlockPosition;
            if (!_shops.ContainsKey(pos)) return;
            
            var shop = _shops[pos];
            var items = await context.BlockDataReader.GetChestItemsAsync(pos);
            
            // 检查是否有足够的商品
            var availableCount = items
                .Where(i => i.Id == shop.ItemId)
                .Sum(i => i.Count);
            
            if (availableCount < shop.ItemsPerPurchase)
            {
                await context.GameDisplay.SendMessageAsync(
                    e.PlayerName,
                    "§c商店库存不足！"
                );
                return;
            }
            
            // 检查玩家货币
            if (!await HasEnoughMoneyAsync(e.PlayerName, shop.Price))
            {
                await context.GameDisplay.SendMessageAsync(
                    e.PlayerName,
                    $"§c金钱不足！需要 {shop.Price} 金币"
                );
                return;
            }
            
            // 执行交易
            await DeductMoneyAsync(e.PlayerName, shop.Price);
            await GiveItemAsync(e.PlayerName, shop.ItemId, shop.ItemsPerPurchase);
            
            // 从箱子扣除物品
            var remaining = items
                .Where(i => i.Id == shop.ItemId)
                .Take(shop.ItemsPerPurchase)
                .ToList();
            
            items.RemoveAll(i => remaining.Contains(i));
            await context.BlockDataWriter.SetContainerItemsAsync(pos, items);
            
            await context.GameDisplay.SendMessageAsync(
                e.PlayerName,
                $"§a购买成功！花费 {shop.Price} 金币"
            );
        });
    }
}
```

---

## 💡 **最佳实践**

### **1. 错误处理**

✅ **推荐：** 始终处理异常
```csharp
try
{
    var items = await _blockReader.GetChestItemsAsync(pos);
    // 处理物品...
}
catch (Exception ex)
{
    _logger.Error($"读取箱子失败: {ex.Message}");
    return CommandResult.Fail("箱子读取失败");
}
```

### **2. 验证方块类型**

✅ **推荐：** 先检查方块类型
```csharp
var blockId = await _blockReader.GetBlockIdAsync(pos);

if (blockId != "minecraft:chest")
{
    return CommandResult.Fail("目标不是箱子");
}

var items = await _blockReader.GetChestItemsAsync(pos);
```

### **3. 槽位管理**

✅ **推荐：** 正确设置槽位
```csharp
var items = new List<ItemStack>();

for (int i = 0; i < itemData.Count; i++)
{
    items.Add(new ItemStack
    {
        Slot = (byte)i,  // 确保槽位连续
        // ...
    });
}
```

### **4. 结合扩展方法**

✅ **推荐：** 使用扩展方法简化操作
```csharp
var items = await _blockReader.GetChestItemsAsync(pos);

// 使用扩展方法
var sorted = items
    .FilterEnchanted()
    .SortByRarity()
    .ToList();

await _blockWriter.SetContainerItemsAsync(pos, sorted);
```

---

## 📚 **相关文档**

- [NBT数据操作](./NBT数据操作.md)
- [物品组件系统](./物品组件系统.md)
- [扩展方法](../04-高级功能/扩展方法.md)

---

**文档维护者：** NetherGate 开发团队  
**最后更新：** 2025-01-08  
**许可证：** LGPL-3.0

