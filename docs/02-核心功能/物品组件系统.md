# 物品组件系统


---

## 📋 目录

- [概述](#概述)
- [版本兼容性](#版本兼容性)
- [数据组件类型](#数据组件类型)
- [API 设计](#api-设计)
- [读取物品组件](#读取物品组件)
- [写入物品组件](#写入物品组件)
- [组件转换](#组件转换)
- [实战示例](#实战示例)
- [最佳实践](#最佳实践)

---

## 概述

### 什么是数据组件？

**数据组件（Data Component）** 是 Minecraft Java 版 1.20.5 引入的新数据格式，用于取代传统的 NBT 标签系统。它提供了更结构化、更易于维护的数据存储方式。

### 为什么要迁移？

| **传统 NBT 系统** | **数据组件系统** |
|------------------|-----------------|
| 🔴 结构松散，难以验证 | 🟢 强类型，结构化 |
| 🔴 命名不一致 | 🟢 命名空间统一 |
| 🔴 难以扩展 | 🟢 模块化设计 |
| 🔴 兼容性问题 | 🟢 向后兼容 |

### 核心变化

```diff
- // 旧 NBT 格式 (1.20.4 及之前)
- {
-   id: "minecraft:diamond_sword",
-   Count: 1,
-   tag: {
-     Damage: 10,
-     display: {
-       Name: '{"text":"神剑"}'
-     },
-     Enchantments: [...]
-   }
- }

+ // 新组件格式 (1.20.5+)
+ {
+   id: "minecraft:diamond_sword",
+   count: 1,
+   components: {
+     "minecraft:damage": 10,
+     "minecraft:custom_name": '{"text":"神剑"}',
+     "minecraft:enchantments": {...}
+   }
+ }
```

---

## 版本兼容性

| Minecraft 版本 | 数据格式 | NetherGate 支持 |
|---------------|---------|----------------|
| 1.20.4 及之前 | NBT 标签 | ✅ 完全支持 |
| 1.20.5 - 1.21.8 | 数据组件（过渡期） | ✅ 完全支持 |
| 1.21.9+ | 数据组件（标准） | ✅ 完全支持 |

### 自动检测版本

NetherGate 会自动检测服务器版本并使用相应的数据格式：

```csharp
// 自动版本检测
var reader = await context.GetPlayerDataReader();
var version = await reader.GetServerVersion();

if (version >= new Version(1, 20, 5))
{
    // 使用数据组件 API
    var components = await reader.ReadPlayerInventoryComponents(playerName);
}
else
{
    // 使用传统 NBT API
    var nbt = await reader.ReadPlayerInventory(playerName);
}
```

---

## 数据组件类型

### 物品堆叠组件

最常用的组件类型，用于描述物品的各种属性：

| 组件 ID | 说明 | 示例 |
|---------|------|------|
| `minecraft:custom_name` | 自定义名称 | `{"text":"传奇之剑","color":"gold"}` |
| `minecraft:lore` | 物品描述 | `[{"text":"稀有武器"}]` |
| `minecraft:enchantments` | 附魔 | `{levels:{"minecraft:sharpness":5}}` |
| `minecraft:damage` | 损坏值 | `10` |
| `minecraft:max_damage` | 最大耐久 | `1561` |
| `minecraft:max_stack_size` | 最大堆叠数 | `64` |
| `minecraft:unbreakable` | 不可破坏 | `{}` |
| `minecraft:custom_model_data` | 自定义模型 | `1234567` |
| `minecraft:custom_data` | 自定义数据 | `{plugin_data:{...}}` |
| `minecraft:rarity` | 稀有度 | `"epic"` |
| `minecraft:attribute_modifiers` | 属性修饰符 | `{modifiers:[...]}` |
| `minecraft:trim` | 盔甲纹饰 | `{material:"...", pattern:"..."}` |
| `minecraft:dyed_color` | 染色 | `{rgb:16711680}` |
| `minecraft:potion_contents` | 药水内容 | `{potion:"minecraft:healing"}` |
| `minecraft:container` | 容器内容 | `[{slot:0, item:{...}}]` |
| `minecraft:bundle_contents` | 束包内容 | `[{id:"...", count:1}]` |
| `minecraft:written_book_content` | 书本内容 | `{pages:[...], title:"..."}` |
| `minecraft:fireworks` | 烟花 | `{explosions:[...]}` |
| `minecraft:profile` | 玩家头颅 | `{name:"Steve"}` |

### 方块实体组件

用于描述方块实体的数据：

| 组件 ID | 作用方块 | 说明 |
|---------|---------|------|
| `minecraft:custom_name` | 所有容器 | 容器名称 |
| `minecraft:lock` | 所有容器 | 锁定状态 |
| `minecraft:container` | 箱子、潜影盒等 | 容器内容 |
| `minecraft:container_loot` | 战利品容器 | 战利品表 |
| `minecraft:note_block_sound` | 音符盒 | 音符 |
| `minecraft:bees` | 蜂箱 | 蜜蜂数据 |
| `minecraft:banner_patterns` | 旗帜 | 图案 |
| `minecraft:pot_decorations` | 饰纹陶罐 | 装饰 |

### 实体组件

用于描述实体的变种数据：

| 组件 ID | 作用实体 | 说明 |
|---------|---------|------|
| `minecraft:axolotl/variant` | 美西螈 | 变种（蓝色、青色等） |
| `minecraft:cat/variant` | 猫 | 品种 |
| `minecraft:horse/variant` | 马 | 颜色和斑纹 |
| `minecraft:wolf/variant` | 狼 | 变种（生物群系） |
| `minecraft:villager/variant` | 村民 | 职业和等级 |
| `minecraft:tropical_fish/pattern` | 热带鱼 | 图案 |

---

## API 设计

### IItemComponentReader

NetherGate 提供了专门的组件读取 API：

```csharp
namespace NetherGate.API.Data;

/// <summary>
/// 物品组件读取器（1.20.5+）
/// </summary>
public interface IItemComponentReader
{
    /// <summary>
    /// 读取玩家背包所有物品的组件数据
    /// </summary>
    Task<PlayerInventoryComponents> ReadPlayerInventoryComponentsAsync(string playerName);

    /// <summary>
    /// 读取特定槽位的物品组件
    /// </summary>
    Task<ItemComponents?> ReadInventorySlotComponentsAsync(string playerName, int slot);

    /// <summary>
    /// 读取末影箱物品组件
    /// </summary>
    Task<List<ItemComponents>> ReadEnderChestComponentsAsync(string playerName);

    /// <summary>
    /// 检查物品是否有特定组件
    /// </summary>
    Task<bool> HasComponentAsync(string playerName, int slot, string componentId);

    /// <summary>
    /// 读取特定组件的值
    /// </summary>
    Task<T?> GetComponentValueAsync<T>(string playerName, int slot, string componentId);

    /// <summary>
    /// 读取方块实体组件
    /// </summary>
    Task<BlockEntityComponents?> ReadBlockEntityComponentsAsync(int x, int y, int z, string dimension = "overworld");
}
```

### 数据模型

```csharp
namespace NetherGate.API.Data.Models;

/// <summary>
/// 玩家背包组件数据
/// </summary>
public record PlayerInventoryComponents
{
    /// <summary>玩家名称</summary>
    public required string PlayerName { get; init; }

    /// <summary>主背包物品（0-35）</summary>
    public required List<ItemComponents> Inventory { get; init; }

    /// <summary>护甲栏（36-39）</summary>
    public required List<ItemComponents> Armor { get; init; }

    /// <summary>副手（40）</summary>
    public required ItemComponents? Offhand { get; init; }

    /// <summary>末影箱</summary>
    public List<ItemComponents>? EnderChest { get; init; }

    /// <summary>服务器版本</summary>
    public required string ServerVersion { get; init; }
}

/// <summary>
/// 物品组件
/// </summary>
public record ItemComponents
{
    /// <summary>物品 ID</summary>
    public required string Id { get; init; }

    /// <summary>数量</summary>
    public required int Count { get; init; }

    /// <summary>槽位</summary>
    public required int Slot { get; init; }

    /// <summary>组件数据</summary>
    public required Dictionary<string, object> Components { get; init; }

    /// <summary>快捷访问：自定义名称</summary>
    public string? CustomName => GetComponent<string>("minecraft:custom_name");

    /// <summary>快捷访问：描述</summary>
    public List<string>? Lore => GetComponent<List<string>>("minecraft:lore");

    /// <summary>快捷访问：附魔</summary>
    public Dictionary<string, int>? Enchantments => GetComponent<Dictionary<string, int>>("minecraft:enchantments");

    /// <summary>快捷访问：损坏值</summary>
    public int? Damage => GetComponent<int?>("minecraft:damage");

    /// <summary>快捷访问：最大耐久</summary>
    public int? MaxDamage => GetComponent<int?>("minecraft:max_damage");

    /// <summary>快捷访问：自定义数据</summary>
    public Dictionary<string, object>? CustomData => GetComponent<Dictionary<string, object>>("minecraft:custom_data");

    /// <summary>获取特定组件</summary>
    public T? GetComponent<T>(string componentId)
    {
        if (Components.TryGetValue(componentId, out var value))
        {
            return (T)value;
        }
        return default;
    }

    /// <summary>检查是否有特定组件</summary>
    public bool HasComponent(string componentId) => Components.ContainsKey(componentId);
}

/// <summary>
/// 方块实体组件
/// </summary>
public record BlockEntityComponents
{
    /// <summary>方块 ID</summary>
    public required string Id { get; init; }

    /// <summary>位置</summary>
    public required BlockPosition Position { get; init; }

    /// <summary>组件数据</summary>
    public required Dictionary<string, object> Components { get; init; }
}

public record BlockPosition(int X, int Y, int Z, string Dimension);
```

---

## 读取物品组件

### 在线与离线数据读取

NetherGate 支持两种数据读取方式：

| 方式 | 适用场景 | 数据来源 | 实时性 | 需要 RCON |
|------|---------|---------|--------|----------|
| **在线读取** | 玩家在线时 | RCON 命令 `/data get` | ✅ 实时 | ✅ 是 |
| **离线读取** | 玩家离线时或无 RCON | 玩家数据文件（.dat） | ⚠️ 上次保存 | ❌ 否 |

**自动选择机制：**
```csharp
// NetherGate 会自动判断：
// 1. 玩家是否在线
// 2. RCON 是否可用
// 3. 自动选择最佳读取方式
var reader = await context.GetItemComponentReader();
var inventory = await reader.ReadPlayerInventoryComponentsAsync(playerName);
```

**SNBT 解析支持（1.21.9+）：**

在线读取使用内置的 SNBT（字符串化 NBT）解析器，支持：
- ✅ 复合标签（Compound）
- ✅ 列表标签（List）
- ✅ 数组标签（IntArray, LongArray, ByteArray）
- ✅ 所有原始类型（Byte, Short, Int, Long, Float, Double, String）
- ✅ 转义字符和引号字符串
- ✅ 类型后缀（b, s, l, f, d）

### 基础读取

```csharp
using NetherGate.API;
using NetherGate.API.Data;

public class ItemInspectorPlugin : IPlugin
{
    public async Task OnPlayerJoinAsync(PlayerJoinEvent e, IPluginContext context)
    {
        var reader = await context.GetItemComponentReader();
        
        // 读取玩家完整背包（自动选择在线/离线读取）
        var inventory = await reader.ReadPlayerInventoryComponentsAsync(e.PlayerName);

        // 遍历所有物品
        foreach (var item in inventory.Inventory)
        {
            context.Logger.Info($"槽位 {item.Slot}: {item.Id} x{item.Count}");
            
            // 检查自定义名称
            if (item.HasComponent("minecraft:custom_name"))
            {
                context.Logger.Info($"  名称: {item.CustomName}");
            }

            // 检查附魔
            if (item.Enchantments != null)
            {
                foreach (var (enchant, level) in item.Enchantments)
                {
                    context.Logger.Info($"  附魔: {enchant} Lv.{level}");
                }
            }

            // 检查耐久
            if (item.Damage.HasValue && item.MaxDamage.HasValue)
            {
                var durability = item.MaxDamage.Value - item.Damage.Value;
                var percent = (durability * 100.0) / item.MaxDamage.Value;
                context.Logger.Info($"  耐久: {durability}/{item.MaxDamage} ({percent:F1}%)");
            }
        }
    }
}
```

### 强制离线读取

在某些情况下，你可能需要强制使用离线读取：

```csharp
// 方法 1：直接读取玩家数据文件
var playerDataReader = context.PlayerDataReader;
var playerData = await playerDataReader.ReadPlayerDataAsync(playerUuid);

// 方法 2：临时禁用 RCON（如果需要）
// 注意：这会影响其他功能
```

### 读取特定槽位

```csharp
// 读取主手物品（假设玩家选中槽位 0）
var mainHand = await reader.ReadInventorySlotComponentsAsync(playerName, 0);
if (mainHand != null)
{
    context.Logger.Info($"主手: {mainHand.Id}");
    
    // 检查是否有特定组件
    if (mainHand.HasComponent("minecraft:custom_model_data"))
    {
        var modelData = mainHand.GetComponent<int>("minecraft:custom_model_data");
        context.Logger.Info($"自定义模型: {modelData}");
    }
}

// 读取头盔（槽位 39）
var helmet = await reader.ReadInventorySlotComponentsAsync(playerName, 39);
if (helmet != null && helmet.HasComponent("minecraft:trim"))
{
    var trim = helmet.GetComponent<Dictionary<string, string>>("minecraft:trim");
    context.Logger.Info($"盔甲纹饰: {trim["material"]} - {trim["pattern"]}");
}
```

### 读取容器组件

```csharp
// 读取潜影盒内容
var shulkerBox = await reader.ReadInventorySlotComponentsAsync(playerName, 10);
if (shulkerBox?.Id == "minecraft:shulker_box")
{
    if (shulkerBox.HasComponent("minecraft:container"))
    {
        var contents = shulkerBox.GetComponent<List<ItemComponents>>("minecraft:container");
        context.Logger.Info($"潜影盒内有 {contents.Count} 个物品");
        
        foreach (var item in contents)
        {
            context.Logger.Info($"  - {item.Id} x{item.Count}");
        }
    }
}
```

### 读取末影箱

```csharp
var enderChest = await reader.ReadEnderChestComponentsAsync(playerName);
context.Logger.Info($"末影箱内有 {enderChest.Count} 个物品");

foreach (var item in enderChest)
{
    context.Logger.Info($"槽位 {item.Slot}: {item.Id} x{item.Count}");
}
```

---

## 写入物品组件

### IItemComponentWriter

```csharp
namespace NetherGate.API.Data;

/// <summary>
/// 物品组件写入器（1.20.5+）
/// </summary>
public interface IItemComponentWriter
{
    /// <summary>
    /// 给予玩家物品（使用组件）
    /// </summary>
    Task<bool> GiveItemAsync(string playerName, ItemComponents item);

    /// <summary>
    /// 设置特定槽位的物品组件
    /// </summary>
    Task<bool> SetInventorySlotComponentsAsync(string playerName, int slot, ItemComponents item);

    /// <summary>
    /// 修改物品的特定组件
    /// </summary>
    Task<bool> UpdateComponentAsync(string playerName, int slot, string componentId, object value);

    /// <summary>
    /// 移除物品的特定组件
    /// </summary>
    Task<bool> RemoveComponentAsync(string playerName, int slot, string componentId);

    /// <summary>
    /// 批量修改组件
    /// </summary>
    Task<bool> UpdateComponentsAsync(string playerName, int slot, Dictionary<string, object> components);
}
```

### 给予物品

```csharp
var writer = await context.GetItemComponentWriter();

// 创建一把附魔钻石剑
var diamondSword = new ItemComponents
{
    Id = "minecraft:diamond_sword",
    Count = 1,
    Slot = -1, // 自动查找空槽位
    Components = new Dictionary<string, object>
    {
        ["minecraft:custom_name"] = "{\"text\":\"无尽之刃\",\"color\":\"aqua\",\"bold\":true}",
        ["minecraft:lore"] = new List<string>
        {
            "{\"text\":\"传说级武器\",\"color\":\"gray\",\"italic\":true}",
            "{\"text\":\"攻击力 +10\",\"color\":\"red\"}"
        },
        ["minecraft:enchantments"] = new Dictionary<string, object>
        {
            ["levels"] = new Dictionary<string, int>
            {
                ["minecraft:sharpness"] = 5,
                ["minecraft:unbreaking"] = 3,
                ["minecraft:mending"] = 1
            }
        },
        ["minecraft:attribute_modifiers"] = new Dictionary<string, object>
        {
            ["modifiers"] = new List<Dictionary<string, object>>
            {
                new()
                {
                    ["type"] = "minecraft:attack_damage",
                    ["amount"] = 10.0,
                    ["operation"] = "add_value",
                    ["slot"] = "mainhand"
                }
            }
        },
        ["minecraft:unbreakable"] = new Dictionary<string, bool>
        {
            ["show_in_tooltip"] = false
        },
        ["minecraft:rarity"] = "epic",
        ["minecraft:custom_data"] = new Dictionary<string, object>
        {
            ["plugin_id"] = "legendary_weapons",
            ["weapon_tier"] = 5,
            ["bound_player"] = "Steve"
        }
    }
};

await writer.GiveItemAsync(playerName, diamondSword);
```

### 修改现有物品

```csharp
// 修改主手物品的名称
await writer.UpdateComponentAsync(
    playerName,
    slot: 0,
    componentId: "minecraft:custom_name",
    value: "{\"text\":\"强化版\",\"color\":\"gold\"}"
);

// 添加描述
await writer.UpdateComponentAsync(
    playerName,
    slot: 0,
    componentId: "minecraft:lore",
    value: new List<string>
    {
        "{\"text\":\"已强化\",\"color\":\"yellow\"}"
    }
);

// 设置为不可破坏
await writer.UpdateComponentAsync(
    playerName,
    slot: 0,
    componentId: "minecraft:unbreakable",
    value: new Dictionary<string, bool> { ["show_in_tooltip"] = true }
);
```

### 批量修改

```csharp
// 一次性修改多个组件
var updates = new Dictionary<string, object>
{
    ["minecraft:damage"] = 0, // 修复耐久
    ["minecraft:enchantments"] = new Dictionary<string, object>
    {
        ["levels"] = new Dictionary<string, int>
        {
            ["minecraft:efficiency"] = 5
        }
    },
    ["minecraft:custom_data"] = new Dictionary<string, object>
    {
        ["repaired_count"] = 1,
        ["last_repair"] = DateTime.UtcNow.ToString("o")
    }
};

await writer.UpdateComponentsAsync(playerName, slot: 0, updates);
```

### 移除组件

```csharp
// 移除自定义名称
await writer.RemoveComponentAsync(playerName, slot: 0, "minecraft:custom_name");

// 移除附魔
await writer.RemoveComponentAsync(playerName, slot: 0, "minecraft:enchantments");
```

---

## 组件转换

### NBT 到组件的转换

NetherGate 提供了自动转换功能，帮助从旧版本迁移：

```csharp
namespace NetherGate.API.Data;

/// <summary>
/// NBT 到组件的转换器
/// </summary>
public interface IItemComponentConverter
{
    /// <summary>
    /// 将 NBT 数据转换为组件格式
    /// </summary>
    ItemComponents ConvertFromNbt(NbtCompound itemNbt);

    /// <summary>
    /// 将组件格式转换为 NBT 数据
    /// </summary>
    NbtCompound ConvertToNbt(ItemComponents item);

    /// <summary>
    /// 批量转换玩家背包
    /// </summary>
    Task<PlayerInventoryComponents> ConvertPlayerInventoryAsync(string playerName);
}
```

### 转换示例

```csharp
var converter = await context.GetItemComponentConverter();

// 从 NBT 转换
var nbtItem = new NbtCompound
{
    ["id"] = new NbtString("minecraft:diamond_sword"),
    ["Count"] = new NbtByte(1),
    ["tag"] = new NbtCompound
    {
        ["Damage"] = new NbtInt(10),
        ["display"] = new NbtCompound
        {
            ["Name"] = new NbtString("{\"text\":\"传奇之剑\"}")
        }
    }
};

var componentItem = converter.ConvertFromNbt(nbtItem);
// 结果:
// {
//   Id: "minecraft:diamond_sword",
//   Count: 1,
//   Components: {
//     "minecraft:damage": 10,
//     "minecraft:custom_name": "{\"text\":\"传奇之剑\"}"
//   }
// }
```

### 常见组件映射表

| 旧 NBT 路径 | 新组件 ID | 说明 |
|------------|-----------|------|
| `tag.Damage` | `minecraft:damage` | 损坏值 |
| `tag.display.Name` | `minecraft:custom_name` | 自定义名称 |
| `tag.display.Lore` | `minecraft:lore` | 描述 |
| `tag.Enchantments` | `minecraft:enchantments` | 附魔 |
| `tag.Unbreakable` | `minecraft:unbreakable` | 不可破坏 |
| `tag.CustomModelData` | `minecraft:custom_model_data` | 自定义模型 |
| `tag.HideFlags` | `minecraft:hide_tooltip` | 隐藏提示 |
| `tag.AttributeModifiers` | `minecraft:attribute_modifiers` | 属性修饰符 |
| `tag.Trim` | `minecraft:trim` | 盔甲纹饰 |
| `tag.display.color` | `minecraft:dyed_color` | 染色 |
| `tag.BlockEntityTag` | `minecraft:block_entity_data` | 方块实体数据 |
| `tag.Items` | `minecraft:container` | 容器内容 |
| `tag.SkullOwner` | `minecraft:profile` | 玩家头颅 |

---

## 实战示例

### 示例 1：物品耐久度监控

```csharp
public class DurabilityMonitorPlugin : IPlugin
{
    public async Task OnPlayerInteractAsync(PlayerInteractEvent e, IPluginContext context)
    {
        var reader = await context.GetItemComponentReader();
        var mainHand = await reader.ReadInventorySlotComponentsAsync(e.PlayerName, e.Slot);

        if (mainHand == null) return;

        // 检查是否是可损坏物品
        if (mainHand.Damage.HasValue && mainHand.MaxDamage.HasValue)
        {
            var remaining = mainHand.MaxDamage.Value - mainHand.Damage.Value;
            var percent = (remaining * 100.0) / mainHand.MaxDamage.Value;

            // 耐久度低于 10% 时警告
            if (percent < 10)
            {
                await context.SendMessageAsync(
                    e.PlayerName,
                    $"§c⚠ 警告：物品即将损坏！剩余耐久 {remaining}/{mainHand.MaxDamage}"
                );
            }
        }
    }
}
```

### 示例 2：自动修复工具

```csharp
[Command("repair")]
[Permission("nethergate.repair")]
public async Task<bool> RepairItemAsync(
    string playerName,
    IPluginContext context)
{
    var reader = await context.GetItemComponentReader();
    var writer = await context.GetItemComponentWriter();

    // 检查玩家是否在线
    if (!await context.IsPlayerOnlineAsync(playerName))
    {
        await context.SendMessageAsync(playerName, "§c玩家不在线！");
        return false;
    }

    // 读取主手物品（假设选中槽位 0）
    var item = await reader.ReadInventorySlotComponentsAsync(playerName, 0);
    
    if (item == null)
    {
        await context.SendMessageAsync(playerName, "§c请手持要修复的物品！");
        return false;
    }

    if (!item.Damage.HasValue || item.Damage.Value == 0)
    {
        await context.SendMessageAsync(playerName, "§c该物品不需要修复！");
        return false;
    }

    // 修复耐久
    var success = await writer.UpdateComponentAsync(
        playerName,
        slot: 0,
        componentId: "minecraft:damage",
        value: 0
    );

    if (success)
    {
        await context.SendMessageAsync(playerName, "§a✓ 物品已完全修复！");
        
        // 记录修复次数
        var customData = item.CustomData ?? new Dictionary<string, object>();
        var repairCount = customData.ContainsKey("repair_count") 
            ? (int)customData["repair_count"] + 1 
            : 1;

        customData["repair_count"] = repairCount;
        customData["last_repair"] = DateTime.UtcNow.ToString("o");

        await writer.UpdateComponentAsync(
            playerName,
            slot: 0,
            componentId: "minecraft:custom_data",
            value: customData
        );
    }

    return success;
}
```

### 示例 3：高级物品生成器

```csharp
public class LegendaryWeaponGenerator
{
    public static ItemComponents CreateLegendarySword(string playerName)
    {
        return new ItemComponents
        {
            Id = "minecraft:netherite_sword",
            Count = 1,
            Slot = -1,
            Components = new Dictionary<string, object>
            {
                ["minecraft:custom_name"] = 
                    "{\"text\":\"龙牙\",\"color\":\"#FF6B35\",\"bold\":true,\"italic\":false}",
                
                ["minecraft:lore"] = new List<string>
                {
                    "{\"text\":\"\"}",
                    "{\"text\":\"§7§o传说中的神器\"}",
                    "{\"text\":\"§8§o『上古遗物』\"}",
                    "{\"text\":\"\"}",
                    "{\"text\":\"§c⚔ 攻击伤害 +15\"}",
                    "{\"text\":\"§9✦ 暴击几率 +20%\"}",
                    "{\"text\":\"§a❤ 生命偷取 +10%\"}",
                    "{\"text\":\"\"}",
                    "{\"text\":\"§6§l传奇\"}",
                    "{\"text\":\"§7绑定玩家: §f" + playerName + "\"}"
                },
                
                ["minecraft:rarity"] = "epic",
                
                ["minecraft:enchantments"] = new Dictionary<string, object>
                {
                    ["levels"] = new Dictionary<string, int>
                    {
                        ["minecraft:sharpness"] = 10,
                        ["minecraft:sweeping_edge"] = 5,
                        ["minecraft:fire_aspect"] = 3,
                        ["minecraft:looting"] = 5,
                        ["minecraft:unbreaking"] = 10,
                        ["minecraft:mending"] = 1
                    },
                    ["show_in_tooltip"] = true
                },
                
                ["minecraft:attribute_modifiers"] = new Dictionary<string, object>
                {
                    ["modifiers"] = new List<Dictionary<string, object>>
                    {
                        new()
                        {
                            ["type"] = "minecraft:attack_damage",
                            ["id"] = "weapon_damage_boost",
                            ["amount"] = 15.0,
                            ["operation"] = "add_value",
                            ["slot"] = "mainhand"
                        },
                        new()
                        {
                            ["type"] = "minecraft:attack_speed",
                            ["id"] = "weapon_speed_boost",
                            ["amount"] = 0.5,
                            ["operation"] = "add_value",
                            ["slot"] = "mainhand"
                        },
                        new()
                        {
                            ["type"] = "minecraft:movement_speed",
                            ["id"] = "weapon_movement",
                            ["amount"] = 0.1,
                            ["operation"] = "add_multiplied_base",
                            ["slot"] = "mainhand"
                        }
                    ],
                    ["show_in_tooltip"] = true
                },
                
                ["minecraft:unbreakable"] = new Dictionary<string, bool>
                {
                    ["show_in_tooltip"] = false
                },
                
                ["minecraft:custom_model_data"] = 1001,
                
                ["minecraft:custom_data"] = new Dictionary<string, object>
                {
                    ["plugin_id"] = "legendary_weapons",
                    ["weapon_id"] = "dragon_fang",
                    ["tier"] = 5,
                    ["bound_player"] = playerName,
                    ["created_at"] = DateTime.UtcNow.ToString("o"),
                    ["stats"] = new Dictionary<string, object>
                    {
                        ["crit_chance"] = 0.2,
                        ["life_steal"] = 0.1,
                        ["kills"] = 0
                    }
                }
            }
        };
    }
}
```

### 示例 4：检查潜影盒内容

```csharp
public async Task<int> CountItemsInShulkerBoxAsync(
    string playerName,
    int shulkerSlot,
    string itemId,
    IPluginContext context)
{
    var reader = await context.GetItemComponentReader();
    var shulker = await reader.ReadInventorySlotComponentsAsync(playerName, shulkerSlot);

    if (shulker == null || !shulker.Id.Contains("shulker_box"))
    {
        return 0;
    }

    if (!shulker.HasComponent("minecraft:container"))
    {
        return 0; // 空潜影盒
    }

    var contents = shulker.GetComponent<List<ItemComponents>>("minecraft:container");
    return contents
        .Where(item => item.Id == itemId)
        .Sum(item => item.Count);
}
```

### 示例 5：物品追踪系统

```csharp
public class ItemTrackingPlugin : IPlugin
{
    public async Task OnPlayerPickupItemAsync(PlayerPickupItemEvent e, IPluginContext context)
    {
        var reader = await context.GetItemComponentReader();
        var writer = await context.GetItemComponentWriter();

        // 为捡起的物品添加追踪信息
        var item = await reader.ReadInventorySlotComponentsAsync(e.PlayerName, e.TargetSlot);
        if (item == null) return;

        var customData = item.CustomData ?? new Dictionary<string, object>();
        
        var trackingInfo = new Dictionary<string, object>
        {
            ["picked_up_by"] = e.PlayerName,
            ["picked_up_at"] = DateTime.UtcNow.ToString("o"),
            ["location"] = new Dictionary<string, double>
            {
                ["x"] = e.Location.X,
                ["y"] = e.Location.Y,
                ["z"] = e.Location.Z
            }
        };

        if (customData.ContainsKey("tracking_history"))
        {
            var history = (List<object>)customData["tracking_history"];
            history.Add(trackingInfo);
        }
        else
        {
            customData["tracking_history"] = new List<object> { trackingInfo };
        }

        await writer.UpdateComponentAsync(
            e.PlayerName,
            e.TargetSlot,
            "minecraft:custom_data",
            customData
        );
    }
}
```

---

## 最佳实践

### ✅ 推荐做法

1. **优先使用快捷访问属性**
   ```csharp
   // ✅ 好
   var name = item.CustomName;
   var enchants = item.Enchantments;
   
   // ❌ 不推荐
   var name = item.GetComponent<string>("minecraft:custom_name");
   ```

2. **检查组件是否存在**
   ```csharp
   // ✅ 好
   if (item.HasComponent("minecraft:damage"))
   {
       var damage = item.Damage;
   }
   
   // ❌ 可能导致 NullReferenceException
   var damage = item.Damage.Value;
   ```

3. **使用类型安全的访问**
   ```csharp
   // ✅ 好
   var modelData = item.GetComponent<int>("minecraft:custom_model_data");
   
   // ❌ 需要手动类型转换
   var modelData = (int)item.Components["minecraft:custom_model_data"];
   ```

4. **批量操作使用批量 API**
   ```csharp
   // ✅ 好 - 一次调用
   await writer.UpdateComponentsAsync(playerName, slot, new Dictionary<string, object>
   {
       ["minecraft:damage"] = 0,
       ["minecraft:custom_name"] = "修复版"
   });
   
   // ❌ 不推荐 - 多次调用
   await writer.UpdateComponentAsync(playerName, slot, "minecraft:damage", 0);
   await writer.UpdateComponentAsync(playerName, slot, "minecraft:custom_name", "修复版");
   ```

### ⚠️ 注意事项

1. **版本兼容性**
   - 始终检查服务器版本
   - 对于 1.20.4 及之前版本，使用 NBT API
   - 对于 1.20.5+ 版本，使用组件 API

2. **组件命名空间**
   - 始终使用完整的命名空间 ID（如 `minecraft:custom_name`）
   - 自定义组件建议使用插件的命名空间（如 `myplugin:custom_stat`）

3. **数据类型**
   - 确保使用正确的数据类型
   - 参考 Minecraft Wiki 的组件数据格式

4. **性能考虑**
   - 避免频繁读取整个背包
   - 使用槽位特定的读取 API
   - 缓存不经常变化的数据

5. **在线/离线数据读取**
   - **在线读取（RCON）**：实时数据，需要 RCON 启用
   - **离线读取（文件）**：可能不是最新数据，但不需要 RCON
   - API 会自动选择最佳方式，无需手动判断
   - 读取离线玩家数据时会从文件系统读取

6. **玩家在线状态**
   - 修改物品前始终检查玩家是否在线
   - 离线玩家的修改可能不会立即生效

7. **RCON 依赖**
   - **写入操作**：必需 RCON（使用 `/item` 命令）
   - **在线读取**：需要 RCON（使用 `/data get` 命令）
   - **离线读取**：不需要 RCON（直接读取 .dat 文件）
   - 如果 RCON 未启用，会自动降级为离线模式

### 🔒 安全建议

1. **验证物品 ID**
   ```csharp
   var validItemIds = new HashSet<string> { "minecraft:diamond", "minecraft:gold_ingot" };
   if (!validItemIds.Contains(item.Id))
   {
       // 拒绝非法物品
   }
   ```

2. **限制组件值范围**
   ```csharp
   // 限制附魔等级
   if (enchantLevel > 10)
   {
       enchantLevel = 10;
   }
   ```

3. **保护关键组件**
   ```csharp
   // 防止修改绑定信息
   if (item.CustomData?.ContainsKey("bound_player") == true)
   {
       var boundPlayer = (string)item.CustomData["bound_player"];
       if (boundPlayer != currentPlayer)
       {
           // 拒绝修改
       }
   }
   ```

4. **日志记录**
   ```csharp
   context.Logger.Info($"[ItemComponent] {playerName} 修改了物品组件: {componentId}");
   ```

---

## 相关文档

- [NBT 数据操作](./NBT数据操作.md) - 传统 NBT 格式操作
- [玩家数据读取](./玩家数据读取.md) - 玩家数据访问
- [事件系统](./事件系统.md) - 物品相关事件
- [Minecraft Wiki - 数据组件](https://zh.minecraft.wiki/w/数据组件) - 官方文档

---

## 技术实现细节

### SNBT 解析器

NetherGate v1.0.1 引入了完整的 SNBT 解析器，用于解析 RCON 命令返回的字符串化 NBT 数据：

**支持的特性：**
- ✅ 所有 NBT 标签类型（Compound, List, Array, Primitive）
- ✅ 引号字符串和非引号字符串
- ✅ 转义字符处理
- ✅ 类型后缀识别（1b, 1s, 1l, 1.0f, 1.0d）
- ✅ 嵌套结构解析
- ✅ 数组类型（[I;...], [L;...], [B;...]）

**示例：**
```csharp
// RCON 返回：player has the following entity data: [{Slot:0b,id:"minecraft:diamond_sword",count:1}]
// SNBT 解析器自动将其转换为 C# 对象
var items = SnbtParser.Parse(snbtString);
```

### 在线读取流程

```
1. 检查玩家是否在线（/list 命令）
   ↓
2. 使用 RCON 执行 /data get entity <player> Inventory
   ↓
3. 解析返回的 SNBT 字符串
   ↓
4. 转换为 ItemComponents 对象
   ↓
5. 返回 PlayerInventoryComponents
```

### 离线读取流程

```
1. 从 usercache.json 获取玩家 UUID
   ↓
2. 读取 world/playerdata/<uuid>.dat 文件
   ↓
3. 解析 NBT 二进制数据
   ↓
4. 转换为 ItemComponents 对象
   ↓
5. 返回 PlayerInventoryComponents
```

---

**最后更新**：2025-10-09  
**基于**：Minecraft Java 版 1.21.9+ / NetherGate v1.0.1

