# 标签系统

NetherGate 提供了完整的标签系统 API，支持查询和管理 Minecraft 的方块、物品、实体、流体、游戏事件和生物群系标签。

> **参考资料：** [Minecraft Wiki - 标签](https://zh.minecraft.wiki/w/标签)

---

## 📋 **目录**

- [什么是标签系统](#什么是标签系统)
- [标签类型](#标签类型)
- [标签 JSON 格式](#标签-json-格式)
- [API 接口](#api-接口)
- [使用示例](#使用示例)
- [在命令中使用标签](#在命令中使用标签)
- [预定义标签常量](#预定义标签常量)
- [最佳实践](#最佳实践)

---

## 🏷️ **什么是标签系统**

**标签（Tag）**是 Minecraft 中的一种技术性 JSON 文件，允许使用数据包将游戏资源分组。标签存储于数据包的 `data/<命名空间>/tags/<注册名>` 目录下。

### **核心特性**

- ✅ 将相似的方块、物品、实体等分组管理
- ✅ 在命令、配方、进度中使用 `#` 前缀引用标签
- ✅ 支持标签嵌套引用
- ✅ 数据包可以扩展或覆盖原版标签

### **常见用途**

- 检查方块是否属于某个材质类型（如铜方块、木质方块）
- 判断物品是否可用于修复特定装备
- 确定实体是否符合某些条件（如可接受礼物的实体）
- 在命令中批量选择多个方块/物品/实体
- 定义合成配方的材料范围

---

## 📁 **标签类型**

NetherGate 支持以下标签类型：

| 注册名 | 注册表 | 存储路径 | 用途 |
|--------|--------|----------|------|
| **方块标签** | `minecraft:block` | `data/<命名空间>/tags/block/` | 控制方块行为（可挖掘性、可攀爬性等） |
| **物品标签** | `minecraft:item` | `data/<命名空间>/tags/item/` | 控制物品行为（可染色、可修复等） |
| **实体类型标签** | `minecraft:entity_type` | `data/<命名空间>/tags/entity_type/` | 控制实体行为（是否为节肢生物等） |
| **流体标签** | `minecraft:fluid` | `data/<命名空间>/tags/fluid/` | 定义流体类型（水、熔岩等） |
| **游戏事件标签** | `minecraft:game_event` | `data/<命名空间>/tags/game_event/` | 定义游戏事件类型（振动等） |
| **生物群系标签** | `minecraft:worldgen/biome` | `data/<命名空间>/tags/worldgen/biome/` | 用于世界生成和结构生成 |

---

## 📄 **标签 JSON 格式**

### **基本格式**

```json
{
  "replace": false,
  "values": [
    "minecraft:copper_block",
    "minecraft:exposed_copper",
    "#minecraft:oxidized_copper"
  ]
}
```

### **字段说明**

| 字段 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `replace` | 布尔值 | `false` | 是否完全覆盖低优先级数据包中的同名标签 |
| `values` | 数组 | `[]` | 标签包含的值列表 |

### **值格式**

`values` 数组中的每个元素可以是：

1. **资源 ID**（字符串）
   ```json
   "minecraft:copper_block"
   ```

2. **标签引用**（以 `#` 开头）
   ```json
   "#minecraft:copper"
   ```

3. **带选项的对象**
   ```json
   {
     "id": "minecraft:copper_block",
     "required": false
   }
   ```
   - `required`: 若为 `false`，ID 不存在时不会报错

### **示例：铜方块标签**

文件路径：`data/minecraft/tags/block/copper.json`

```json
{
  "replace": false,
  "values": [
    "minecraft:copper_block",
    "minecraft:exposed_copper",
    "minecraft:weathered_copper",
    "minecraft:oxidized_copper",
    "#minecraft:waxed_copper"
  ]
}
```

---

## 📖 **API 接口**

### **ITagApi 接口**

```csharp
namespace NetherGate.API.Data
{
    public interface ITagApi
    {
        // 方块标签
        Task<bool> IsBlockInTagAsync(string blockId, string tag);
        Task<List<string>> GetBlocksInTagAsync(string tag);
        Task<List<string>> GetAllBlockTagsAsync();
        
        // 物品标签
        Task<bool> IsItemInTagAsync(string itemId, string tag);
        Task<List<string>> GetItemsInTagAsync(string tag);
        Task<List<string>> GetAllItemTagsAsync();
        
        // 实体类型标签
        Task<bool> IsEntityInTagAsync(string entityType, string tag);
        Task<List<string>> GetEntitiesInTagAsync(string tag);
        Task<List<string>> GetAllEntityTagsAsync();
        
        // 流体标签
        Task<bool> IsFluidInTagAsync(string fluidId, string tag);
        Task<List<string>> GetFluidsInTagAsync(string tag);
        Task<List<string>> GetAllFluidTagsAsync();
        
        // 游戏事件标签
        Task<bool> IsGameEventInTagAsync(string eventId, string tag);
        Task<List<string>> GetGameEventsInTagAsync(string tag);
        Task<List<string>> GetAllGameEventTagsAsync();
        
        // 生物群系标签
        Task<bool> IsBiomeInTagAsync(string biomeId, string tag);
        Task<List<string>> GetBiomesInTagAsync(string tag);
        Task<List<string>> GetAllBiomeTagsAsync();
    }
}
```

**注意：** API 中调用标签时**无需**添加 `#` 前缀，只在 Minecraft 命令中使用时才需要。

---

## 💡 **使用示例**

### **示例 1：检查方块类型**

```csharp
public class BlockCheckerPlugin : IPlugin
{
    private IPluginContext _context = null!;

    public async Task OnEnableAsync(IPluginContext context)
    {
        _context = context;
        
        // 检查方块是否是铜方块
        bool isCopper = await _context.TagApi.IsBlockInTagAsync(
            "minecraft:copper_block", 
            "minecraft:copper"
        );
        
        _context.Logger.Info($"copper_block 是铜方块: {isCopper}");
    }
}
```

### **示例 2：获取标签中的所有方块**

```csharp
// 获取所有铜方块
var copperBlocks = await _context.TagApi.GetBlocksInTagAsync("minecraft:copper");

_context.Logger.Info($"找到 {copperBlocks.Count} 个铜方块:");
foreach (var block in copperBlocks)
{
    _context.Logger.Info($"  - {block}");
}
```

### **示例 3：检查物品是否可修复装备**

```csharp
// 检查物品是否可以修复铜盔甲
bool canRepair = await _context.TagApi.IsItemInTagAsync(
    "minecraft:copper_ingot",
    "minecraft:repairs_copper_armor"
);

if (canRepair)
{
    _context.Logger.Info("铜锭可以修复铜盔甲");
}
```

### **示例 4：铜方块过滤系统**

创建一个插件，过滤和处理所有铜质方块：

```csharp
public class CopperFilterPlugin : IPlugin
{
    private IPluginContext _context = null!;
    private List<string> _copperBlocks = new();

    public async Task OnEnableAsync(IPluginContext context)
    {
        _context = context;
        
        // 加载所有铜方块
        _copperBlocks = await _context.TagApi.GetBlocksInTagAsync(
            MinecraftTags.Blocks.Copper
        );
        
        _context.Logger.Info($"已加载 {_copperBlocks.Count} 个铜方块");
        
        // 注册命令
        _context.CommandManager.RegisterCommand(new CheckCopperCommand(_context, this));
    }

    public bool IsCopperBlock(string blockId)
    {
        return _copperBlocks.Contains(blockId);
    }
}

public class CheckCopperCommand : ICommand
{
    private readonly IPluginContext _context;
    private readonly CopperFilterPlugin _plugin;

    public string Name => "checkcopper";
    public string Description => "检查方块是否为铜方块";
    public List<string> Aliases => new() { "cc" };
    public string PluginId => "CopperFilter";
    public string? Permission => null;
    public string Usage => "#checkcopper <方块ID>";

    public CheckCopperCommand(IPluginContext context, CopperFilterPlugin plugin)
    {
        _context = context;
        _plugin = plugin;
    }

    public async Task<CommandResult> ExecuteAsync(ICommandSender sender, string[] args)
    {
        if (args.Length < 1)
            return CommandResult.Fail($"用法: {Usage}");

        var blockId = args[0];
        var isCopper = _plugin.IsCopperBlock(blockId);
        
        sender.SendMessage(isCopper 
            ? $"§a{blockId} 是铜方块" 
            : $"§c{blockId} 不是铜方块");
        
        return CommandResult.Ok();
    }
}
```

---

## 🔖 **预定义标签常量**

NetherGate 提供了常用的 Minecraft 1.21.9 标签常量：

```csharp
using static NetherGate.API.Data.MinecraftTags;

// 方块标签
bool hasChest = await _context.TagApi.IsBlockInTagAsync(
    blockId, 
    Blocks.CopperChests  // "minecraft:copper_chests"
);

// 物品标签
bool isCopperTool = await _context.TagApi.IsItemInTagAsync(
    itemId, 
    Items.CopperToolMaterials  // "minecraft:copper_tool_materials"
);

// 实体标签
bool canAccept = await _context.TagApi.IsEntityInTagAsync(
    entityType, 
    EntityTypes.AcceptsIronGolemGift  // "minecraft:accepts_iron_golem_gift"
);
```

### **可用的标签常量**

#### **方块标签 (MinecraftTags.Blocks)**

| 常量 | 值 | 说明 |
|------|-----|------|
| `CopperChests` | `minecraft:copper_chests` | 铜箱子 |
| `Copper` | `minecraft:copper` | 铜方块 |
| `CopperGolemStatues` | `minecraft:copper_golem_statues` | 铜傀儡像 |
| `LightningRods` | `minecraft:lightning_rods` | 避雷针 |
| `WoodenShelves` | `minecraft:wooden_shelves` | 木架 |
| `Chains` | `minecraft:chains` | 链条 |
| `Lanterns` | `minecraft:lanterns` | 灯笼 |
| `Bars` | `minecraft:bars` | 栏杆 |

#### **物品标签 (MinecraftTags.Items)**

| 常量 | 值 | 说明 |
|------|-----|------|
| `CopperToolMaterials` | `minecraft:copper_tool_materials` | 铜质工具材料 |
| `RepairsCopperArmor` | `minecraft:repairs_copper_armor` | 修复铜盔甲的物品 |
| `ShearableFromCopperGolem` | `minecraft:shearable_from_copper_golem` | 可从铜傀儡剪取的物品 |

#### **实体标签 (MinecraftTags.EntityTypes)**

| 常量 | 值 | 说明 |
|------|-----|------|
| `AcceptsIronGolemGift` | `minecraft:accepts_iron_golem_gift` | 接受铁傀儡礼物的实体 |
| `CandidateForIronGolemGift` | `minecraft:candidate_for_iron_golem_gift` | 有资格获得铁傀儡礼物的实体 |
| `CannotBePushedOntoBoats` | `minecraft:cannot_be_pushed_onto_boats` | 不会被推上船的实体 |

---

## 🎮 **在命令中使用标签**

在 Minecraft 命令中引用标签时，**必须**以 `#` 开头。

### **示例 1：使用方块标签填充区域**

```mcfunction
# 用任意原木填充区域
/fill ~-5 ~ ~-5 ~5 ~5 ~5 #minecraft:logs
```

### **示例 2：清除指定标签的物品**

```mcfunction
# 清除所有羊毛类物品
/clear @a #minecraft:wool
```

### **示例 3：选择实体类型**

```mcfunction
# 杀死所有节肢生物
/kill @e[type=#minecraft:arthropod]
```

### **通过 NetherGate 执行带标签的命令**

```csharp
public async Task FillWithCopperBlocks()
{
    // 使用铜方块标签填充区域
    await _context.RconClient!.ExecuteCommandAsync(
        "fill 0 64 0 10 74 10 #minecraft:copper"
    );
}

public async Task ClearCopperItems()
{
    // 清除所有玩家的铜物品
    await _context.RconClient!.ExecuteCommandAsync(
        "clear @a #minecraft:copper"
    );
}
```

---

## 🔖 **预定义标签常量**

### **使用方式**

```csharp
using static NetherGate.API.Data.MinecraftTags;

// 方块标签
await _context.TagApi.IsBlockInTagAsync(blockId, Blocks.Copper);

// 物品标签
await _context.TagApi.IsItemInTagAsync(itemId, Items.CopperToolMaterials);

// 实体标签
await _context.TagApi.IsEntityInTagAsync(entityType, EntityTypes.AcceptsIronGolemGift);

// 流体标签
await _context.TagApi.IsFluidInTagAsync(fluidId, Fluids.Water);

// 生物群系标签
await _context.TagApi.IsBiomeInTagAsync(biomeId, Biomes.IsOcean);
```

### **完整标签列表**

#### **流体标签 (MinecraftTags.Fluids)**

| 常量 | 值 | 说明 |
|------|-----|------|
| `Water` | `minecraft:water` | 水（包括流动水和静止水） |
| `Lava` | `minecraft:lava` | 熔岩（包括流动熔岩和静止熔岩） |

#### **游戏事件标签 (MinecraftTags.GameEvents)**

| 常量 | 值 | 说明 |
|------|-----|------|
| `Vibrations` | `minecraft:vibrations` | 振动事件 |
| `IgnoreVibrationsSneaking` | `minecraft:ignore_vibrations_sneaking` | 潜行时忽略的振动 |

#### **生物群系标签 (MinecraftTags.Biomes)**

| 常量 | 值 | 说明 |
|------|-----|------|
| `HasStructureVillage` | `minecraft:has_structure/village` | 可生成村庄 |
| `HasStructureDesertPyramid` | `minecraft:has_structure/desert_pyramid` | 可生成沙漠神殿 |
| `HasStructureWoodlandMansion` | `minecraft:has_structure/woodland_mansion` | 可生成林地府邸 |
| `HasStructureOceanMonument` | `minecraft:has_structure/ocean_monument` | 可生成海底神殿 |
| `HasStructureStronghold` | `minecraft:has_structure/stronghold` | 可生成要塞 |
| `IsNether` | `minecraft:is_nether` | 下界生物群系 |
| `IsEnd` | `minecraft:is_end` | 末地生物群系 |
| `IsOverworld` | `minecraft:is_overworld` | 主世界生物群系 |
| `IsOcean` | `minecraft:is_ocean` | 海洋生物群系 |
| `IsRiver` | `minecraft:is_river` | 河流生物群系 |
| `IsBeach` | `minecraft:is_beach` | 沙滩生物群系 |

---

## 💡 **高级使用示例**

### **示例 5：生物群系检测系统**

```csharp
public class BiomeDetectorPlugin : IPlugin
{
    private IPluginContext _context = null!;

    public async Task OnEnableAsync(IPluginContext context)
    {
        _context = context;
        
        _context.CommandManager.RegisterCommand(new CheckBiomeCommand(_context));
    }
}

public class CheckBiomeCommand : ICommand
{
    private readonly IPluginContext _context;

    public string Name => "checkbiome";
    public string Description => "检查当前生物群系类型";
    public string Usage => "#checkbiome";
    public List<string> Aliases => new() { "cb" };
    public string PluginId => "BiomeDetector";
    public string? Permission => null;

    public CheckBiomeCommand(IPluginContext context)
    {
        _context = context;
    }

    public async Task<CommandResult> ExecuteAsync(ICommandSender sender, string[] args)
    {
        // 通过 RCON 获取玩家当前生物群系
        var result = await _context.RconClient!.ExecuteCommandAsync(
            $"data get entity {sender.Name} Dimension"
        );
        
        // 假设获取到了生物群系 ID
        string biomeId = "minecraft:plains";  // 实际需要解析命令结果
        
        // 检查生物群系类型
        bool isOcean = await _context.TagApi.IsBiomeInTagAsync(biomeId, Biomes.IsOcean);
        bool isNether = await _context.TagApi.IsBiomeInTagAsync(biomeId, Biomes.IsNether);
        bool canVillageSpawn = await _context.TagApi.IsBiomeInTagAsync(biomeId, Biomes.HasStructureVillage);
        
        var message = $"""
            §6═══════════════════════════════
            §f  生物群系信息
            
            §7  ID: §f{biomeId}
            §7  类型: §f{(isOcean ? "海洋" : isNether ? "下界" : "主世界")}
            §7  可生成村庄: §f{(canVillageSpawn ? "是" : "否")}
            §6═══════════════════════════════
            """;
        
        sender.SendMessage(message);
        return CommandResult.Ok();
    }
}
```

### **示例 6：流体检测插件**

```csharp
public class FluidCheckerPlugin : IPlugin
{
    private IPluginContext _context = null!;

    public async Task OnEnableAsync(IPluginContext context)
    {
        _context = context;
        
        // 检查某个位置的流体
        await CheckFluidAt(0, 64, 0);
    }

    private async Task CheckFluidAt(int x, int y, int z)
    {
        // 假设通过某种方式获取了流体 ID
        string fluidId = "minecraft:water";
        
        // 检查是否为水
        bool isWater = await _context.TagApi.IsFluidInTagAsync(fluidId, Fluids.Water);
        
        if (isWater)
        {
            _context.Logger.Info($"位置 ({x}, {y}, {z}) 是水");
        }
        
        // 检查是否为熔岩
        bool isLava = await _context.TagApi.IsFluidInTagAsync(fluidId, Fluids.Lava);
        
        if (isLava)
        {
            _context.Logger.Info($"位置 ({x}, {y}, {z}) 是熔岩");
        }
    }
}
```

### **示例 7：游戏事件监听**

```csharp
public class VibrationMonitorPlugin : IPlugin
{
    private IPluginContext _context = null!;

    public async Task OnEnableAsync(IPluginContext context)
    {
        _context = context;
        
        // 获取所有振动类型的游戏事件
        var vibrations = await _context.TagApi.GetGameEventsInTagAsync(GameEvents.Vibrations);
        
        _context.Logger.Info($"共有 {vibrations.Count} 种振动事件:");
        foreach (var vibration in vibrations)
        {
            _context.Logger.Info($"  - {vibration}");
        }
    }
}
```

---

## ✅ **最佳实践**

### **1. 使用预定义常量**

优先使用 `MinecraftTags` 类中的常量，避免硬编码字符串：

```csharp
// ✅ 推荐
await _context.TagApi.IsBlockInTagAsync(blockId, Blocks.Copper);

// ❌ 不推荐
await _context.TagApi.IsBlockInTagAsync(blockId, "minecraft:copper");
```

### **2. API 调用不需要 # 前缀**

```csharp
// ✅ 正确：API 调用
await _context.TagApi.IsBlockInTagAsync("minecraft:copper_block", "minecraft:copper");

// ❌ 错误：不要添加 # 前缀
await _context.TagApi.IsBlockInTagAsync("minecraft:copper_block", "#minecraft:copper");

// ✅ 正确：命令中使用
await _context.RconClient!.ExecuteCommandAsync("fill ~ ~ ~ ~10 ~10 ~10 #minecraft:copper");
```

### **3. 缓存标签数据**

如果需要频繁查询，可以缓存标签数据：

```csharp
public class MyPlugin : IPlugin
{
    private List<string> _copperBlocks = new();
    private DateTime _lastCacheTime;

    public async Task OnEnableAsync(IPluginContext context)
    {
        // 启动时加载一次
        _copperBlocks = await context.TagApi.GetBlocksInTagAsync(Blocks.Copper);
        _lastCacheTime = DateTime.Now;
        
        // 后续使用缓存的数据
        bool isCopper = _copperBlocks.Contains(blockId);
    }

    private async Task RefreshCacheIfNeeded()
    {
        // 缓存 10 分钟后刷新
        if ((DateTime.Now - _lastCacheTime).TotalMinutes > 10)
        {
            _copperBlocks = await _context.TagApi.GetBlocksInTagAsync(Blocks.Copper);
            _lastCacheTime = DateTime.Now;
        }
    }
}
```

### **4. 处理命名空间**

标签 API 会自动处理命名空间，以下两种写法等效：

```csharp
// 两种写法都可以
await _context.TagApi.IsBlockInTagAsync("copper_block", "copper");
await _context.TagApi.IsBlockInTagAsync("minecraft:copper_block", "minecraft:copper");
```

### **5. 错误处理**

始终检查返回结果：

```csharp
try
{
    var blocks = await _context.TagApi.GetBlocksInTagAsync("custom:my_tag");
    if (blocks.Count == 0)
    {
        _context.Logger.Warning("标签为空或不存在");
    }
}
catch (Exception ex)
{
    _context.Logger.Error("获取标签失败", ex);
}
```

### **6. 标签引用**

创建自定义标签时，可以引用其他标签：

```json
{
  "replace": false,
  "values": [
    "minecraft:copper_block",
    "#minecraft:oxidized_copper",
    "#minecraft:waxed_copper"
  ]
}
```

对应的 API 查询会自动解析标签引用。

---

## ⚙️ **技术细节**

### **缓存机制**

- 标签数据会缓存 **10 分钟**
- 修改数据包后需要重启服务器或等待缓存过期
- 缓存可提高查询性能，减少文件读取

### **文件解析**

标签系统会自动解析服务器数据包中的标签文件：
- 支持标准 JSON 格式
- 支持标签引用（`#namespace:tag_name`）
- 自动处理 `replace` 字段

---

## 📦 **依赖要求**

- ✅ Minecraft Java 版 **1.21.9+**
- ✅ NetherGate **1.0.0+**
- ✅ 服务器数据包正确配置

---

## 🐛 **已知限制**

1. **缓存时间**：标签数据缓存 10 分钟，实时修改数据包不会立即生效
2. **标签引用**：当前版本暂不支持递归解析标签引用（`#` 开头的标签）
3. **自定义数据包**：仅扫描 `minecraft` 命名空间的标签，自定义命名空间需要指定完整路径
4. **函数标签**：当前版本不支持函数标签（`tick` 和 `load` 标签）的直接管理

---

## 📚 **标签文件示例**

### **示例 1：自定义铜方块标签**

文件路径：`data/mypack/tags/block/all_copper.json`

```json
{
  "replace": false,
  "values": [
    "#minecraft:copper",
    "minecraft:copper_door",
    "minecraft:copper_trapdoor",
    "minecraft:lightning_rod"
  ]
}
```

### **示例 2：自定义工具材料标签**

文件路径：`data/mypack/tags/item/advanced_tools.json`

```json
{
  "replace": false,
  "values": [
    "minecraft:diamond_pickaxe",
    "minecraft:netherite_pickaxe",
    {
      "id": "mypack:custom_pickaxe",
      "required": false
    }
  ]
}
```

### **示例 3：覆盖原版标签**

文件路径：`data/minecraft/tags/block/logs.json`

```json
{
  "replace": true,
  "values": [
    "#minecraft:logs_that_burn",
    "minecraft:crimson_stem",
    "minecraft:warped_stem"
  ]
}
```

---

## 📚 **相关文档**

- [NBT 数据操作](./NBT数据操作.md)
- [方块数据操作](./方块数据操作.md)
- [物品组件系统](./物品组件系统.md)

---

**文档维护者：** NetherGate 开发团队  
**最后更新：** 2025-10-09
