# NetherGate 事件系统

NetherGate 提供了全面的事件系统，允许插件监听和响应服务器、玩家、网络等各种事件。

---

## 📋 **目录**

- [快速开始](#快速开始)
- [事件类型](#事件类型)
- [订阅事件](#订阅事件)
- [发布自定义事件](#发布自定义事件)
- [事件优先级](#事件优先级)
- [异步事件处理](#异步事件处理)
- [最佳实践](#最佳实践)

---

## 🚀 **快速开始**

### **订阅事件**

```csharp
using NetherGate.API.Plugins;
using NetherGate.API.Events;

public class MyPlugin : PluginBase
{
    public override Task OnEnableAsync()
    {
        // 订阅玩家加入事件（带优先级）
        Events.Subscribe<PlayerJoinedEvent>(OnPlayerJoined, EventPriority.Normal);
        
        // 订阅玩家离开事件
        Events.Subscribe<PlayerLeftEvent>(OnPlayerLeft, EventPriority.Normal);
        
        // 订阅服务器启动事件（高优先级）
        Events.Subscribe<ServerReadyEvent>(OnServerReady, EventPriority.High);
        
        Logger.Info("事件已订阅");
        return Task.CompletedTask;
    }

    private async Task OnPlayerJoined(PlayerJoinedEvent e)
    {
        Logger.Info($"玩家 {e.Player.Name} 加入了服务器");
        
        // 发送欢迎消息
        await GameDisplay.SendChatMessage(
            e.Player.Name, 
            "§a欢迎来到服务器！"
        );
    }

    private Task OnPlayerLeft(PlayerLeftEvent e)
    {
        Logger.Info($"玩家 {e.Player.Name} 离开了服务器");
        return Task.CompletedTask;
    }
    
    private Task OnServerReady(ServerReadyEvent e)
    {
        Logger.Info($"服务器启动完成，耗时 {e.StartupTime}");
        return Task.CompletedTask;
    }

    public override Task OnDisableAsync()
    {
        // 插件禁用时自动取消订阅
        Logger.Info("事件订阅已取消");
        return Task.CompletedTask;
    }
}
```

---

## 📚 **事件类型**

### **1. 服务器生命周期事件**

#### **ServerStartingEvent**
服务器进程即将启动

```csharp
_context.EventBus.Subscribe<ServerStartingEvent>(e =>
{
    _context.Logger.Info("服务器即将启动");
});
```

#### **ServerReadyEvent**
服务器完全启动（检测到 "Done (X.XXXs)!" 日志）

```csharp
_context.EventBus.Subscribe<ServerReadyEvent>(e =>
{
    _context.Logger.Info($"服务器启动完成，耗时 {e.StartupTime}");
    // 可以开始发送命令
});
```

#### **ServerShuttingDownEvent**
服务器开始关闭（检测到 "Stopping server" 日志）

```csharp
_context.EventBus.Subscribe<ServerShuttingDownEvent>(e =>
{
    _context.Logger.Info("服务器正在关闭");
    // 保存数据
});
```

#### **ServerStoppedEvent**
服务器进程已停止

```csharp
_context.EventBus.Subscribe<ServerStoppedEvent>(e =>
{
    _context.Logger.Info("服务器已停止");
});
```

#### **ServerCrashedEvent**
服务器崩溃

```csharp
_context.EventBus.Subscribe<ServerCrashedEvent>(e =>
{
    _context.Logger.Error($"服务器崩溃: {e.Reason}");
    _context.Logger.Error($"退出代码: {e.ExitCode}");
    // 发送告警通知
});
```

#### **ServerHeartbeatEvent**
服务器心跳（通过 SMP 定期接收服务器状态）

```csharp
_context.EventBus.Subscribe<ServerHeartbeatEvent>(e =>
{
    _context.Logger.Debug($"TPS: {e.State.Tps}, 在线玩家: {e.State.PlayerCount}");
});
```

---

### **2. 玩家事件**

#### **PlayerJoinedEvent**
玩家加入服务器

```csharp
public record PlayerJoinedEvent(PlayerInfo Player, string JoinMessage);

_context.EventBus.Subscribe<PlayerJoinedEvent>(async e =>
{
    _context.Logger.Info($"{e.Player.Name} 加入了服务器");
    
    // 欢迎消息
    await _context.GameDisplayApi.ShowTitle(
        e.Player.Name,
        "§6欢迎回来",
        $"§e{e.Player.Name}",
        fadeIn: 10, stay: 70, fadeOut: 20
    );
});
```

#### **PlayerLeftEvent**
玩家离开服务器

```csharp
public record PlayerLeftEvent(PlayerInfo Player, string LeaveMessage);

_context.EventBus.Subscribe<PlayerLeftEvent>(e =>
{
    _context.Logger.Info($"{e.Player.Name} 离开了服务器");
    
    // 保存玩家数据
    SavePlayerData(e.Player);
});
```

#### **PlayerChatEvent**
玩家聊天

```csharp
public record PlayerChatEvent(string PlayerName, string Message);

_context.EventBus.Subscribe<PlayerChatEvent>(async e =>
{
    // 检测敏感词
    if (ContainsBadWords(e.Message))
    {
        _context.Logger.Warning($"{e.PlayerName} 发送了不当消息: {e.Message}");
        await _context.GameDisplayApi.SendChatMessage(
            e.PlayerName, 
            "§c请注意言辞！"
        );
    }
});
```

#### **PlayerDeathEvent**
玩家死亡

```csharp
public record PlayerDeathEvent(string PlayerName, string DeathMessage);

_context.EventBus.Subscribe<PlayerDeathEvent>(async e =>
{
    _context.Logger.Info($"{e.PlayerName} 死亡: {e.DeathMessage}");
    
    // 发送复活提示
    await Task.Delay(3000);
    await _context.GameDisplayApi.SendChatMessage(
        e.PlayerName, 
        "§e输入 #back 返回死亡地点"
    );
});
```

#### **PlayerAdvancementEvent**
玩家获得成就

```csharp
public record PlayerAdvancementEvent(string PlayerName, string AdvancementKey, string Title);

_context.EventBus.Subscribe<PlayerAdvancementEvent>(async e =>
{
    _context.Logger.Info($"{e.PlayerName} 获得成就: {e.Title}");
    
    // 广播消息
    await _context.GameDisplayApi.BroadcastMessage(
        $"§6[成就] §e{e.PlayerName} §f获得了成就 §a{e.Title}"
    );
});
```

---

### **3. 允许列表/封禁事件**

#### **AllowlistAddedEvent / AllowlistRemovedEvent**

```csharp
public record AllowlistAddedEvent(string PlayerName, string Operator);

_context.EventBus.Subscribe<AllowlistAddedEvent>(e =>
{
    _context.Logger.Info($"{e.PlayerName} 被 {e.Operator} 添加到白名单");
});

_context.EventBus.Subscribe<AllowlistRemovedEvent>(e =>
{
    _context.Logger.Info($"{e.PlayerName} 被 {e.Operator} 从白名单移除");
});
```

#### **AllowlistSetEvent / AllowlistClearedEvent**

```csharp
// 批量设置白名单
_context.EventBus.Subscribe<AllowlistSetEvent>(e =>
{
    _context.Logger.Info($"白名单已批量设置，共 {e.PlayerNames.Count} 个玩家");
});

// 白名单清空
_context.EventBus.Subscribe<AllowlistClearedEvent>(e =>
{
    _context.Logger.Warning("白名单已清空");
});
```

#### **BanAddedEvent / BanRemovedEvent**

```csharp
public record BanAddedEvent(string PlayerName, string Reason, string Operator, DateTime? Expires);

_context.EventBus.Subscribe<BanAddedEvent>(e =>
{
    var expireStr = e.Expires.HasValue ? $"至 {e.Expires.Value}" : "永久";
    _context.Logger.Info($"{e.PlayerName} 被 {e.Operator} 封禁 ({expireStr}): {e.Reason}");
});
```

#### **IpBanAddedEvent / IpBanRemovedEvent**

```csharp
_context.EventBus.Subscribe<IpBanAddedEvent>(e =>
{
    _context.Logger.Info($"IP {e.IpAddress} 被 {e.Operator} 封禁: {e.Reason}");
});
```

#### **OperatorAddedEvent / OperatorRemovedEvent**

```csharp
_context.EventBus.Subscribe<OperatorAddedEvent>(e =>
{
    _context.Logger.Info($"{e.PlayerName} 被授予 OP 权限 (等级 {e.Level})");
});
```

---

### **4. 网络层事件**

#### **PlayerConnectionAttemptEvent**
玩家尝试连接

```csharp
public record PlayerConnectionAttemptEvent(string PlayerName, string IpAddress, DateTime Timestamp);

_context.EventBus.Subscribe<PlayerConnectionAttemptEvent>(e =>
{
    _context.Logger.Info($"{e.PlayerName} 尝试连接，IP: {e.IpAddress}");
    
    // 检查 IP 黑名单
    if (IsBlacklisted(e.IpAddress))
    {
        _context.Logger.Warning($"阻止黑名单 IP 连接: {e.IpAddress}");
    }
});
```

#### **PlayerLoginEvent**
玩家登录

```csharp
public record PlayerLoginEvent(string PlayerName, string Uuid, string IpAddress);

_context.EventBus.Subscribe<PlayerLoginEvent>(e =>
{
    _context.Logger.Info($"{e.PlayerName} ({e.Uuid}) 登录成功");
});
```

#### **PlayerDisconnectEvent**
玩家断开连接

```csharp
public record PlayerDisconnectEvent(string PlayerName, string Reason);

_context.EventBus.Subscribe<PlayerDisconnectEvent>(e =>
{
    _context.Logger.Info($"{e.PlayerName} 断开连接: {e.Reason}");
});
```

#### **PacketSentEvent / PacketReceivedEvent**
数据包发送/接收（调试用）

```csharp
_context.EventBus.Subscribe<PacketReceivedEvent>(e =>
{
    _context.Logger.Debug($"收到数据包: {e.PacketType}, 大小: {e.Size} 字节");
});
```

---

### **5. SMP 事件**

#### **SmpConnectedEvent / SmpDisconnectedEvent**

```csharp
_context.EventBus.Subscribe<SmpConnectedEvent>(e =>
{
    _context.Logger.Info("SMP 连接已建立");
});

_context.EventBus.Subscribe<SmpDisconnectedEvent>(e =>
{
    _context.Logger.Warning("SMP 连接已断开");
});
```

---

## 🔧 **订阅事件**

### **基本订阅**

```csharp
// 订阅事件
_context.EventBus.Subscribe<PlayerJoinedEvent>(OnPlayerJoined);

// 处理方法
private void OnPlayerJoined(PlayerJoinedEvent e)
{
    _context.Logger.Info($"玩家加入: {e.Player.Name}");
}
```

### **Lambda 表达式**

```csharp
_context.EventBus.Subscribe<PlayerJoinedEvent>(e =>
{
    _context.Logger.Info($"玩家加入: {e.Player.Name}");
});
```

### **异步处理**

```csharp
_context.EventBus.Subscribe<PlayerJoinedEvent>(async e =>
{
    await Task.Delay(1000);
    await _context.GameDisplayApi.SendChatMessage(e.Player.Name, "欢迎！");
});
```

### **取消订阅**

```csharp
// 手动取消订阅
_context.EventBus.Unsubscribe<PlayerJoinedEvent>(OnPlayerJoined);

// 插件禁用时自动取消所有订阅
public void OnDisable()
{
    // 框架会自动处理
}
```

---

## 📣 **发布自定义事件**

### **定义事件**

```csharp
// 使用 record 定义事件（推荐）
public record EconomyTransactionEvent(
    string FromPlayer,
    string ToPlayer,
    decimal Amount,
    string Reason
);

// 或使用 class
public class CustomEvent
{
    public string Data { get; set; }
    public DateTime Timestamp { get; set; }
}
```

### **发布事件**

```csharp
// 发布事件
var transactionEvent = new EconomyTransactionEvent(
    FromPlayer: "Steve",
    ToPlayer: "Alex",
    Amount: 100.0m,
    Reason: "购买物品"
);

await _context.EventBus.PublishAsync(transactionEvent);
```

### **订阅自定义事件**

```csharp
// 其他插件可以订阅
_context.EventBus.Subscribe<EconomyTransactionEvent>(e =>
{
    _context.Logger.Info($"交易: {e.FromPlayer} -> {e.ToPlayer}, 金额: {e.Amount}");
});
```

---

## ⚡ **事件优先级**

### **优先级枚举**

```csharp
public enum EventPriority
{
    Lowest = 0,    // 最低（最先执行）
    Low = 1,
    Normal = 2,    // 默认
    High = 3,
    Highest = 4,   // 最高（最后执行）
    Monitor = 5    // 监视器（仅用于监听，不应修改事件）
}
```

### **使用优先级**

```csharp
// 高优先级（后执行）
_context.EventBus.Subscribe<PlayerJoinedEvent>(e =>
{
    // 在其他插件处理后执行
    _context.Logger.Info("最后的欢迎消息");
}, EventPriority.Highest);

// 低优先级（先执行）
_context.EventBus.Subscribe<PlayerJoinedEvent>(e =>
{
    // 在其他插件之前执行
    _context.Logger.Info("首先检查玩家");
}, EventPriority.Lowest);

// 监视器优先级（只读）
_context.EventBus.Subscribe<PlayerJoinedEvent>(e =>
{
    // 仅用于记录，不修改任何数据
    LogPlayerJoin(e.Player);
}, EventPriority.Monitor);
```

### **执行顺序**

```
Lowest (0) → Low (1) → Normal (2) → High (3) → Highest (4) → Monitor (5)
   ↓           ↓          ↓           ↓           ↓            ↓
 先执行     优先处理    默认优先级   后处理      最后执行      仅监听
```

---

## 📡 **三层事件监听策略**

NetherGate 采用**智能三层事件监听策略**，按优先级从高到低自动选择最优的事件源：

### **监听优先级**

```
1️⃣ SMP 协议（Server Management Protocol） - 🟢 最高优先级
    ↓ 如果 SMP 不支持该事件
2️⃣ RCON 协议（Remote Console） - 🟡 次优先级
    ↓ 如果 RCON 不支持该事件
3️⃣ 日志解析（Log Parsing） - 🔴 最低优先级
```

### **协议对比**

| 协议/方式 | 优势 | 劣势 | 适用场景 |
|----------|------|------|---------|
| **SMP** | ✅ 结构化数据<br>✅ 实时推送<br>✅ 包含 UUID<br>✅ 官方支持 | ❌ 覆盖范围有限<br>❌ 需要 MC 1.21.9+ | 管理操作、玩家加入/离开 |
| **RCON** | ✅ 命令执行<br>✅ 广泛支持 | ❌ 无事件监听<br>❌ 单向通信 | 执行游戏命令 |
| **日志解析** | ✅ 覆盖所有事件<br>✅ 无版本限制 | ❌ 不可靠（格式变更）<br>❌ 缺少结构化数据<br>❌ 有延迟 | SMP/RCON 不支持的事件 |

### **第一层：SMP 协议事件**

SMP 支持以下实时通知：

#### **玩家事件**
- ✅ **玩家加入** (`players/joined`) → `PlayerJoinedEvent`
  - 包含：UUID、玩家名、IP 地址
- ✅ **玩家离开** (`players/left`) → `PlayerLeftEvent`
  - 包含：UUID、玩家名

#### **管理操作事件**
- ✅ **管理员添加/移除** → `OperatorAddedEvent` / `OperatorRemovedEvent`
- ✅ **白名单操作** → `AllowlistChangedEvent`
- ✅ **玩家封禁/解封** → `PlayerBannedEvent` / `PlayerUnbannedEvent`
- ✅ **IP 封禁/解封** → `IpBannedEvent` / `IpUnbannedEvent`

#### **服务器事件**
- ✅ **游戏规则更新** → `GameRuleChangedEvent`
- ✅ **服务器状态心跳** → `ServerHeartbeatEvent`

**实现文件**：
- `src/NetherGate.Core/Protocol/SmpClient.cs`
- `src/NetherGate.API/Events/SmpEvents.cs`

### **第二层：RCON 协议**

#### **支持的功能**
- ✅ **执行游戏命令** (`SendCommandAsync()`)
  - 示例：`/say`, `/give`, `/tp`, `/gamemode`, `/effect` 等

#### **不支持的功能**
- ❌ **事件监听**（RCON 是单向通信协议，只能发送命令，无法接收事件推送）

**实现文件**：
- `src/NetherGate.Core/Protocol/RconClient.cs`
- `src/NetherGate.API/Protocol/IRconClient.cs`

### **第三层：日志解析事件**

用于监听 SMP 和 RCON 都不支持的事件。

#### **支持的事件**
- ✅ **玩家聊天** → `PlayerChatEvent`
  - 解析：`<PlayerName> message`
- ✅ **玩家命令** → `PlayerCommandEvent`
  - 解析：`PlayerName issued server command: /command`
- ✅ **玩家死亡** → `PlayerDeathEvent`
  - 解析：关键词匹配（was killed, died, drowned 等）
- ✅ **玩家成就** → `PlayerAchievementEvent`
  - 解析：`PlayerName has made the advancement [Achievement]`
- ✅ **通用日志** → `ServerLogEvent`
  - 所有服务器输出

#### **服务器进程监控**
- ✅ **进程启动** → `ServerProcessStartedEvent`
- ✅ **进程停止** → `ServerProcessStoppedEvent`
- ✅ **进程崩溃** → `ServerProcessCrashedEvent`

**实现文件**：
- `src/NetherGate.Core/Process/LogParser.cs`
- `src/NetherGate.Core/Process/ServerProcessManager.cs`

**注意事项**：
- 日志格式可能因 Minecraft 版本、语言、MOD 而变化
- 不如 SMP 可靠，建议仅用于补充

### **事件覆盖矩阵**

| 事件类型 | SMP | RCON | 日志解析 | 当前实现 |
|---------|-----|------|---------|---------|
| 玩家加入 | ✅ | ❌ | ✅ | **SMP** |
| 玩家离开 | ✅ | ❌ | ✅ | **SMP** |
| 玩家聊天 | ❌ | ❌ | ✅ | **日志解析** |
| 玩家命令 | ❌ | ❌ | ✅ | **日志解析** |
| 玩家死亡 | ❌ | ❌ | ✅ | **日志解析** |
| 玩家成就 | ❌ | ❌ | ✅ | **日志解析** |
| 管理员操作 | ✅ | ❌ | ❌ | **SMP** |
| 白名单操作 | ✅ | ❌ | ❌ | **SMP** |
| 封禁操作 | ✅ | ❌ | ❌ | **SMP** |
| 游戏规则变更 | ✅ | ❌ | ❌ | **SMP** |
| 执行命令 | ❌ | ✅ | ❌ | **RCON** |
| 服务器进程 | ❌ | ❌ | ✅ | **进程监控** |

### **避免重复监听**

NetherGate 内部已实现智能去重，优先使用 SMP 事件，仅在 SMP 不支持时才使用日志解析。

**已移除的日志解析**（改用 SMP）：
- ~~玩家加入~~ → 改用 SMP `players/joined`
- ~~玩家离开~~ → 改用 SMP `players/left`

**保留的日志解析**（SMP 不支持）：
- ✅ 玩家聊天
- ✅ 玩家命令
- ✅ 玩家死亡
- ✅ 玩家成就

---

## 🔄 **异步事件处理**

### **async/await**

```csharp
_context.EventBus.Subscribe<PlayerJoinedEvent>(async e =>
{
    // 异步操作
    await Task.Delay(1000);
    await _context.GameDisplayApi.SendChatMessage(e.Player.Name, "欢迎！");
    
    // 加载玩家数据
    var playerData = await LoadPlayerDataAsync(e.Player.Name);
    
    // 更新玩家状态
    await UpdatePlayerStatusAsync(e.Player.Name, playerData);
});
```

### **并发处理**

```csharp
_context.EventBus.Subscribe<ServerReadyEvent>(async e =>
{
    // 并发执行多个任务
    var tasks = new List<Task>
    {
        InitializeDatabaseAsync(),
        LoadConfigurationsAsync(),
        ConnectToExternalServiceAsync()
    };
    
    await Task.WhenAll(tasks);
    
    _context.Logger.Info("所有初始化任务完成");
});
```

---

## 💡 **最佳实践**

### **1. 使用 record 定义事件**

✅ **推荐：**
```csharp
public record PlayerJoinedEvent(PlayerInfo Player, string JoinMessage);
```

❌ **不推荐：**
```csharp
public class PlayerJoinedEvent
{
    public PlayerInfo Player { get; set; }
    public string JoinMessage { get; set; }
}
```

**原因：** `record` 提供不可变性、值比较和简洁语法。

### **2. 命名约定**

- 事件名称使用 **过去时** 或 **现在进行时**
  - ✅ `PlayerJoinedEvent` (已加入)
  - ✅ `ServerStartingEvent` (正在启动)
  - ❌ `PlayerJoinEvent` (模糊)

### **3. 异常处理**

```csharp
_context.EventBus.Subscribe<PlayerJoinedEvent>(async e =>
{
    try
    {
        await ProcessPlayerJoin(e.Player);
    }
    catch (Exception ex)
    {
        _context.Logger.Error($"处理玩家加入事件时出错: {ex.Message}");
        // 不要抛出异常，避免影响其他订阅者
    }
});
```

### **4. 避免长时间阻塞**

```csharp
// ❌ 不推荐：阻塞事件处理
_context.EventBus.Subscribe<PlayerJoinedEvent>(e =>
{
    Thread.Sleep(5000);  // 阻塞 5 秒
    // 会影响其他订阅者
});

// ✅ 推荐：使用异步
_context.EventBus.Subscribe<PlayerJoinedEvent>(async e =>
{
    await Task.Delay(5000);  // 异步等待
});
```

### **5. 监视器优先级的正确使用**

```csharp
// ✅ 监视器：只读，不修改数据
_context.EventBus.Subscribe<PlayerJoinedEvent>(e =>
{
    LogToDatabase(e.Player);  // 仅记录
}, EventPriority.Monitor);

// ❌ 错误：在监视器中修改数据
_context.EventBus.Subscribe<PlayerJoinedEvent>(e =>
{
    e.Player.Name = "Modified";  // 不应该修改
}, EventPriority.Monitor);
```

### **6. 取消订阅**

```csharp
private Action<PlayerJoinedEvent> _joinHandler;

public void OnEnable(IPluginContext context)
{
    _joinHandler = OnPlayerJoined;
    _context.EventBus.Subscribe(_joinHandler);
}

public void OnDisable()
{
    // 手动取消订阅（可选，框架会自动处理）
    if (_joinHandler != null)
    {
        _context.EventBus.Unsubscribe(_joinHandler);
    }
}
```

---

## 🔍 **调试事件**

### **事件日志**

```csharp
_context.EventBus.Subscribe<PlayerJoinedEvent>(e =>
{
    _context.Logger.Debug($"[Event] PlayerJoinedEvent: {e.Player.Name}");
});
```

### **事件统计**

```csharp
private int _joinCount = 0;

_context.EventBus.Subscribe<PlayerJoinedEvent>(e =>
{
    _joinCount++;
    _context.Logger.Info($"总加入次数: {_joinCount}");
});
```

---

## 📚 **相关文档**

- [插件开发指南](../03-插件开发/插件开发指南.md)
- [API 参考](../03-插件开发/API参考.md)
- [SMP 协议](../02-核心功能/SMP协议.md)

---

**文档维护者：** NetherGate 开发团队  
**最后更新：** 2025-10-05
