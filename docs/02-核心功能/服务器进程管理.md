# NetherGate 服务器进程管理

NetherGate 提供了完整的 Minecraft 服务器进程管理功能，支持自动启动、监控、崩溃检测和自动重启。

---

## 📋 **目录**

- [快速开始](#快速开始)
- [架构设计](#架构设计)
- [启动流程](#启动流程)
- [进程监控](#进程监控)
- [崩溃检测](#崩溃检测)
- [自动重启](#自动重启)
- [状态管理](#状态管理)
- [最佳实践](#最佳实践)

---

## 🚀 **快速开始**

### **基础配置**

```yaml
server_process:
  # 是否启用进程管理
  enabled: true
  
  # 启动方式
  launch_method: java
  
  # Java 配置
  java:
    path: java
    version_check: true
  
  # 服务器配置
  server:
    jar: server.jar
    working_directory: ./minecraft_server
  
  # 内存配置
  memory:
    min: 2048  # 最小内存（MB）
    max: 4096  # 最大内存（MB）
  
  # 监控配置
  monitoring:
    startup_timeout: 300  # 启动超时（秒）
    show_server_output: true
    
    startup_detection:
      enabled: true
      keywords:
        - "Done ("
    
    crash_detection:
      enabled: true
      keywords:
        - "Exception in server tick loop"
  
  # 自动重启配置
  auto_restart:
    enabled: true
    delay_seconds: 5
    max_retries: 3
    retry_delay: 5000
    reset_timer: 600000
```

---

## 🏗️ **架构设计**

### **模块结构**

```
ServerProcessManager
├── ProcessLauncher          # 进程启动器
│   ├── 命令构建
│   ├── 进程创建
│   └── 环境配置
│
├── OutputMonitor            # 输出监控器
│   ├── 标准输出监听
│   ├── 错误输出监听
│   └── 输出转发
│
├── StateDetector            # 状态检测器
│   ├── 启动完成检测
│   ├── 崩溃检测
│   └── 心跳检测
│
├── CrashHandler             # 崩溃处理器
│   ├── 崩溃分析
│   ├── 日志收集
│   └── 重启决策
│
└── CommandBuilder           # 命令构建器
    ├── JVM 参数构建
    ├── 内存参数构建
    └── 服务器参数构建
```

---

## 🔄 **启动流程**

### **完整启动流程图**

```
┌─────────────────────────────────────────────────────────┐
│ 1. NetherGate 启动                                      │
└──────────────────┬──────────────────────────────────────┘
                   │
┌──────────────────▼──────────────────────────────────────┐
│ 2. 读取配置文件                                         │
│    - nethergate-config.yaml                             │
│    - 验证配置有效性                                     │
└──────────────────┬──────────────────────────────────────┘
                   │
┌──────────────────▼──────────────────────────────────────┐
│ 3. 检查 Java 环境                                       │
│    - 检测 Java 版本                                     │
│    - 验证 Java 路径                                     │
│    - 确认版本兼容性                                     │
└──────────────────┬──────────────────────────────────────┘
                   │
┌──────────────────▼──────────────────────────────────────┐
│ 4. 构建 Java 启动命令                                   │
│    java [jvm_prefix] -Xms2048M -Xmx4096M [jvm_middle]  │
│         -jar server.jar [server_args]                   │
└──────────────────┬──────────────────────────────────────┘
                   │
┌──────────────────▼──────────────────────────────────────┐
│ 5. 启动服务器进程                                       │
│    - 设置工作目录                                       │
│    - 启动进程                                           │
│    - 记录进程 ID                                        │
│    - 发布 ServerProcessStartedEvent                     │
└──────────────────┬──────────────────────────────────────┘
                   │
┌──────────────────▼──────────────────────────────────────┐
│ 6. 监听输出流                                           │
│    ├─ 标准输出（stdout）────→ 转发到 NetherGate 控制台 │
│    └─ 错误输出（stderr）────→ 记录到日志文件           │
└──────────────────┬──────────────────────────────────────┘
                   │
┌──────────────────▼──────────────────────────────────────┐
│ 7. 检测启动完成                                         │
│    - 扫描输出日志                                       │
│    - 匹配关键字 "Done ("                                │
│    - 计算启动耗时                                       │
│    - 发布 ServerReadyEvent                              │
└──────────────────┬──────────────────────────────────────┘
                   │
┌──────────────────▼──────────────────────────────────────┐
│ 8. 连接管理协议                                         │
│    ├─ RCON 连接                                         │
│    └─ SMP 连接                                          │
└──────────────────┬──────────────────────────────────────┘
                   │
┌──────────────────▼──────────────────────────────────────┐
│ 9. 加载和初始化插件                                     │
│    - 扫描 plugins 目录                                  │
│    - 加载插件程序集                                     │
│    - 调用插件 OnLoad/OnEnable                           │
└──────────────────┬──────────────────────────────────────┘
                   │
┌──────────────────▼──────────────────────────────────────┐
│ 10. NetherGate 就绪                                     │
│     - 系统完全可用                                      │
│     - 开始处理命令和事件                                │
└─────────────────────────────────────────────────────────┘
```

### **命令构建详解**

**完整命令格式**：
```bash
java [jvm_prefix] -Xms<min>M -Xmx<max>M [jvm_middle] -jar <server.jar> [server]
```

**示例**：
```bash
java -Xms2048M -Xmx4096M -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -Dfile.encoding=UTF-8 -jar server.jar --nogui
```

**参数顺序**：
1. `java` - Java 可执行文件
2. `jvm_prefix` - JVM 前置参数
3. `-Xms<min>M` - 最小内存
4. `-Xmx<max>M` - 最大内存
5. `jvm_middle` - JVM 中间参数（GC、性能优化等）
6. `-jar <server.jar>` - 服务器 JAR 文件
7. `server` - 服务器参数

---

## 📊 **进程监控**

### **输出监控器（OutputMonitor）**

监听服务器的标准输出和错误输出，实时转发到 NetherGate 控制台。

#### **工作原理**

```csharp
// 伪代码示例
public class OutputMonitor
{
    public void StartMonitoring(Process process)
    {
        // 监听标准输出
        process.OutputDataReceived += (sender, e) =>
        {
            if (!string.IsNullOrEmpty(e.Data))
            {
                // 转发到控制台
                Console.WriteLine($"[MC] {e.Data}");
                
                // 检测启动完成
                CheckStartupComplete(e.Data);
                
                // 检测崩溃
                CheckCrash(e.Data);
                
                // 发布事件
                OnOutputReceived(e.Data);
            }
        };
        
        // 监听错误输出
        process.ErrorDataReceived += (sender, e) =>
        {
            if (!string.IsNullOrEmpty(e.Data))
            {
                Logger.Error($"[MC Error] {e.Data}");
                OnErrorReceived(e.Data);
            }
        };
        
        // 开始异步读取
        process.BeginOutputReadLine();
        process.BeginErrorReadLine();
    }
}
```

#### **输出格式化**

```
[14:23:45 INFO]: [MC] Starting minecraft server version 1.20.1
[14:23:45 INFO]: [MC] Loading properties
[14:23:46 INFO]: [MC] Default game type: SURVIVAL
[14:23:50 INFO]: [MC] Done (4.827s)! For help, type "help"
```

---

## 🔍 **启动完成检测**

### **检测机制**

监听服务器输出，匹配关键字判断服务器是否启动完成。

#### **默认关键字**

```yaml
startup_detection:
  enabled: true
  keywords:
    - "Done ("                    # 主要检测点
    - "For help, type \"help\""   # 辅助检测点
```

#### **检测流程**

```
服务器输出流
    ↓
[MC] Starting minecraft server...
    ↓
[MC] Loading libraries...
    ↓
[MC] Preparing level "world"
    ↓
[MC] Done (4.827s)! For help, type "help"  ← 匹配到关键字
    ↓
计算启动耗时: 4.827 秒
    ↓
发布 ServerReadyEvent
    ↓
更新状态: Starting → Running
```

#### **超时处理**

```yaml
monitoring:
  startup_timeout: 300  # 超时时间（秒）
```

如果超过 300 秒未检测到启动完成：
1. 记录警告日志
2. 强制终止进程
3. 发布 `ServerCrashedEvent`
4. 根据配置决定是否重启

---

## 🚨 **崩溃检测**

### **检测策略**

#### **1. 退出码检测**

```csharp
process.Exited += (sender, e) =>
{
    int exitCode = process.ExitCode;
    
    if (exitCode == 0)
    {
        // 正常退出
        OnServerStopped(new ServerStoppedEventArgs 
        { 
            ExitCode = 0,
            WasClean = true 
        });
    }
    else
    {
        // 异常退出（崩溃）
        OnServerCrashed(new ServerCrashedEventArgs 
        { 
            ExitCode = exitCode,
            WillRestart = ShouldRestart()
        });
    }
};
```

#### **2. 关键字检测**

```yaml
crash_detection:
  enabled: true
  keywords:
    - "Exception in server tick loop"
    - "OutOfMemoryError"
    - "StackOverflowError"
    - "java.lang.Error"
```

匹配到这些关键字时，即使进程未退出也标记为潜在崩溃。

#### **3. 心跳检测**

定期检查服务器是否响应（通过 RCON 或 SMP）：

```csharp
// 每 30 秒检查一次
Timer heartbeatTimer = new(30000);
heartbeatTimer.Elapsed += async (sender, e) =>
{
    if (!await PingServerAsync())
    {
        Logger.Warning("Server is not responding!");
        // 可选：触发重启
    }
};
```

### **崩溃分析**

崩溃时自动收集以下信息：

1. **退出码**
2. **最后 100 行日志**
3. **崩溃时间**
4. **运行时长**
5. **重启次数**
6. **系统资源使用情况**

---

## 🔄 **自动重启**

### **重启策略**

```yaml
auto_restart:
  enabled: true         # 是否启用自动重启
  delay_seconds: 5      # 重启前延迟（秒）
  max_retries: 3        # 最大重试次数
  retry_delay: 5000     # 重试延迟（毫秒）
  reset_timer: 600000   # 重启计数器重置时间（毫秒，10分钟）
```

### **工作流程**

```
服务器崩溃
    ↓
检查 auto_restart.enabled
    ├─ false → 停止，等待手动处理
    └─ true  → 继续
    ↓
检查重试次数 < max_retries
    ├─ false → 停止，记录错误日志
    └─ true  → 继续
    ↓
等待 delay_seconds 秒
    ↓
记录日志："Restarting server... (Attempt X/Y)"
    ↓
重新启动服务器
    ↓
重试次数 +1
    ↓
监控启动结果
    ├─ 成功 → 启动计时器，X 分钟后重置计数器
    └─ 失败 → 返回"服务器崩溃"步骤
```

### **计数器重置**

```
服务器启动成功
    ↓
启动计时器（10 分钟）
    ↓
服务器稳定运行 10 分钟
    ↓
重置重试计数器为 0
    ↓
下次崩溃时从头开始计数
```

### **示例场景**

#### **场景 1：连续崩溃**

```
时间    事件              重试次数  动作
0:00   服务器崩溃         0      → 等待 5 秒
0:05   重启              1      → 启动失败
0:05   再次崩溃          1      → 等待 5 秒
0:10   重启              2      → 启动失败
0:10   再次崩溃          2      → 等待 5 秒
0:15   重启              3      → 启动失败
0:15   再次崩溃          3      → 达到最大重试次数
0:15   停止重启          3      → 需要手动处理
```

#### **场景 2：稳定运行后崩溃**

```
时间    事件              重试次数  动作
0:00   服务器崩溃         0      → 重启
0:05   成功启动          1      → 启动计时器
10:05  计时器触发         1      → 重置计数器为 0
15:00  服务器崩溃         0      → 重启（重新计数）
```

---

## 📡 **状态管理**

### **进程状态**

```csharp
public enum ServerProcessState
{
    Stopped,        // 未启动
    Starting,       // 启动中
    Running,        // 运行中
    Stopping,       // 停止中
    Crashed,        // 崩溃
    Restarting      // 重启中
}
```

### **状态转换图**

```
              ┌──────────┐
              │ Stopped  │ ◄──────────┐
              └────┬─────┘            │
                   │ Start()          │
                   ▼                  │
              ┌──────────┐            │
              │ Starting │            │
              └────┬─────┘            │
                   │                  │
          ┌────────┴────────┐         │
          │                 │         │
    启动成功               启动失败    │
          │                 │         │
          ▼                 ▼         │
    ┌──────────┐      ┌─────────┐    │
    │ Running  │      │ Crashed │    │
    └────┬─────┘      └────┬────┘    │
         │                 │         │
         │ Stop()    自动重启/       │
         │           手动处理        │
         ▼                 │         │
    ┌──────────┐           │         │
    │ Stopping │           │         │
    └────┬─────┘           │         │
         │                 │         │
    完成停止          ┌──────▼──────┐ │
         │           │ Restarting  │ │
         │           └──────┬──────┘ │
         │                  │        │
         └──────────────────┴────────┘
```

### **状态查询**

```csharp
// 在插件中查询服务器状态
var state = await Context.Server.GetStateAsync();

switch (state)
{
    case ServerProcessState.Running:
        Logger.Info("服务器正在运行");
        break;
    
    case ServerProcessState.Starting:
        Logger.Info("服务器正在启动...");
        break;
    
    case ServerProcessState.Crashed:
        Logger.Error("服务器已崩溃！");
        break;
}
```

---

## 💡 **最佳实践**

### **1. 内存配置**

```yaml
# ✅ 推荐：根据服务器规模配置
memory:
  min: 2048  # 小型服务器（<10人）
  max: 4096

memory:
  min: 4096  # 中型服务器（10-50人）
  max: 8192

memory:
  min: 8192  # 大型服务器（50+人）
  max: 16384

# ❌ 不推荐：min 和 max 相差过大
memory:
  min: 1024
  max: 16384  # 可能导致 GC 压力
```

### **2. JVM 参数优化**

**G1GC 推荐配置**（Java 8+）：

```yaml
jvm_middle:
  - -XX:+UseG1GC
  - -XX:+ParallelRefProcEnabled
  - -XX:MaxGCPauseMillis=200
  - -XX:+UnlockExperimentalVMOptions
  - -XX:+DisableExplicitGC
  - -XX:+AlwaysPreTouch
  - -XX:G1NewSizePercent=30
  - -XX:G1MaxNewSizePercent=40
  - -XX:G1HeapRegionSize=8M
  - -Dfile.encoding=UTF-8
```

**ZGC 配置**（Java 17+，大内存服务器）：

```yaml
jvm_middle:
  - -XX:+UseZGC
  - -XX:AllocatePrefetchStyle=1
  - -XX:-ZProactive
  - -Dfile.encoding=UTF-8
```

### **3. 崩溃检测配置**

```yaml
# 根据服务器类型调整关键字
crash_detection:
  keywords:
    # 通用崩溃
    - "Exception in server tick loop"
    - "OutOfMemoryError"
    
    # Paper/Spigot 特定
    - "Could not pass event"
    
    # 模组服务器
    - "FML ModContainer"
    - "Exception loading model"
```

### **4. 自动重启策略**

```yaml
# 生产环境推荐配置
auto_restart:
  enabled: true
  delay_seconds: 10      # 稍长延迟，便于查看崩溃日志
  max_retries: 5         # 适当增加重试次数
  retry_delay: 10000     # 10 秒延迟
  reset_timer: 3600000   # 1 小时后重置计数器
```

### **5. 启动超时时间**

```yaml
# 根据世界大小调整
monitoring:
  startup_timeout: 300   # 小世界（<500MB）
  startup_timeout: 600   # 中等世界（500MB-2GB）
  startup_timeout: 1200  # 大世界（>2GB）
```

---

## 🔧 **故障排查**

### **问题 1：服务器无法启动**

**症状**：启动后立即退出，退出码非 0

**排查步骤**：

1. 检查 Java 版本：
   ```bash
   java -version
   ```

2. 检查服务器 JAR 是否存在：
   ```bash
   ls minecraft_server/server.jar
   ```

3. 尝试手动启动：
   ```bash
   cd minecraft_server
   java -Xms2048M -Xmx4096M -jar server.jar nogui
   ```

4. 查看 NetherGate 日志：
   ```bash
   tail -f logs/latest.log
   ```

### **问题 2：启动超时**

**症状**：服务器启动时间超过 `startup_timeout`

**解决方案**：

1. 增加超时时间：
   ```yaml
   monitoring:
     startup_timeout: 600  # 从 300 增加到 600
   ```

2. 检查世界大小，考虑优化或备份旧世界

3. 升级硬件（特别是磁盘 I/O）

### **问题 3：频繁崩溃重启**

**症状**：服务器不断崩溃和重启

**解决方案**：

1. 禁用自动重启，手动排查：
   ```yaml
   auto_restart:
     enabled: false
   ```

2. 检查崩溃日志：
   ```bash
   tail -100 minecraft_server/logs/latest.log
   ```

3. 常见原因：
   - 内存不足：增加 `memory.max`
   - 插件冲突：逐个禁用插件测试
   - 世界损坏：恢复备份或修复世界

---

## 📚 **相关文档**

- [配置文件详解](../01-快速开始/配置文件详解.md) - 完整配置参数说明
- [事件系统](./事件系统.md) - 服务器生命周期事件
- [故障排查](../05-配置和部署/故障排查.md) - 常见问题解决方案

---

**最后更新**: 2025-10-05  
**NetherGate 版本**: v0.1.0

