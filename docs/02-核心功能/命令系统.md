# NetherGate 命令系统

NetherGate 提供了一个功能强大且易于使用的命令系统，支持控制台命令和游戏内命令，并集成了权限检查、Tab 补全和命令别名等功能。

---

## 📋 **目录**

- [快速开始](#快速开始)
- [命令类型](#命令类型)
- [创建命令](#创建命令)
- [注册命令](#注册命令)
- [命令前缀](#命令前缀)
- [权限检查](#权限检查)
- [Tab 补全](#tab-补全)
- [命令别名](#命令别名)
- [最佳实践](#最佳实践)

---

## 🚀 **快速开始**

### **1. 创建简单命令**

```csharp
using NetherGate.API.Commands;
using NetherGate.API.Plugins;

public class HelloCommand : ICommand
{
    private readonly PluginBase _plugin;
    
    public string Name => "hello";
    public string Description => "向玩家打招呼";
    public string Usage => "/hello [name]";
    public string[] Aliases => new[] { "hi", "greet" };
    public string Permission => "myplugin.hello";  // 可选，null 表示无需权限
    public string PluginId => _plugin.Metadata.Id;

    public HelloCommand(PluginBase plugin)
    {
        _plugin = plugin;
    }

    public async Task<CommandResult> ExecuteAsync(ICommandSender sender, string[] args)
    {
        if (sender.IsConsole)
        {
            return CommandResult.Ok("你好！来自控制台");
        }
        
        string target = args.Length > 0 ? args[0] : sender.Name;
        await _plugin.GameDisplay.SendChatMessage(sender.Name, $"§a你好, {target}！");
        
        return CommandResult.Ok($"向 {target} 打招呼成功");
    }
    
    public async Task<List<string>> TabCompleteAsync(ICommandSender sender, string[] args)
    {
        // 第一个参数：提示在线玩家
        if (args.Length == 1)
        {
            var players = await _plugin.Server.GetOnlinePlayersAsync();
            return players
                .Select(p => p.Name)
                .Where(name => name.StartsWith(args[0], StringComparison.OrdinalIgnoreCase))
                .ToList();
        }
        return new List<string>();
    }
}
```

### **2. 注册命令**

```csharp
public class MyPlugin : PluginBase
{
    public override Task OnEnableAsync()
    {
        // 注册命令
        Commands.RegisterCommand(new HelloCommand(this));
        
        Logger.Info("Hello 命令已注册");
        return Task.CompletedTask;
    }
}
```

### **3. 使用命令**

```bash
# 控制台执行（无前缀）
hello

# 游戏内执行（使用 # 前缀）
#hello
#hi        # 使用别名
```

---

## 🎯 **命令类型**

### **1. 控制台命令**

从 NetherGate 控制台执行，**不需要前缀**：

```bash
plugin list
permission reload
stop
```

### **2. 游戏内命令**

从 Minecraft 聊天框执行，**使用 `#` 前缀**（避免与原版命令冲突）：

```
#help
#spawn
#tpa Steve
```

### **3. RCON 命令**

通过 RCON 发送到 Minecraft 服务器的原生命令：

```bash
/say Hello
/give Steve diamond 64
/tp Steve 0 64 0
```

**注意：** NetherGate 框架命令使用 `#` 前缀，原版 Minecraft 命令使用 `/` 前缀。

---

## 🛠️ **创建命令**

### **ICommand 接口**

```csharp
namespace NetherGate.API.Commands
{
    public interface ICommand
    {
        /// <summary>
        /// 命令名称（主要名称）
        /// </summary>
        string Name { get; }
        
        /// <summary>
        /// 命令描述
        /// </summary>
        string Description { get; }
        
        /// <summary>
        /// 使用方法提示
        /// </summary>
        string Usage { get; }
        
        /// <summary>
        /// 命令别名列表（可选）
        /// </summary>
        string[] Aliases { get; }
        
        /// <summary>
        /// 所属插件 ID
        /// </summary>
        string PluginId { get; }
        
        /// <summary>
        /// 所需权限节点（null 表示无需权限）
        /// </summary>
        string? Permission { get; }
        
        /// <summary>
        /// 执行命令
        /// </summary>
        /// <param name="sender">命令发送者</param>
        /// <param name="args">命令参数</param>
        Task<CommandResult> ExecuteAsync(ICommandSender sender, string[] args);
        
        /// <summary>
        /// Tab 补全（可选实现）
        /// </summary>
        /// <param name="sender">命令发送者</param>
        /// <param name="args">当前输入的参数</param>
        Task<List<string>> TabCompleteAsync(ICommandSender sender, string[] args);
    }
}
```

### **ICommandSender 接口**

```csharp
namespace NetherGate.API.Commands
{
    public interface ICommandSender
    {
        /// <summary>
        /// 发送者名称
        /// </summary>
        string Name { get; }
        
        /// <summary>
        /// 是否是控制台
        /// </summary>
        bool IsConsole { get; }
        
        /// <summary>
        /// 发送消息给命令发送者
        /// </summary>
        /// <param name="message">消息内容</param>
        void SendMessage(string message);
        
        /// <summary>
        /// 检查是否拥有指定权限
        /// </summary>
        /// <param name="permission">权限节点</param>
        /// <returns>是否拥有权限</returns>
        bool HasPermission(string permission);
    }
}
```

### **CommandResult 记录**

```csharp
namespace NetherGate.API.Commands
{
    public record CommandResult
    {
        public bool Success { get; init; }
        public string Message { get; init; }
        
        // 静态工厂方法
        public static CommandResult Ok(string message) 
            => new CommandResult { Success = true, Message = message };
        
        public static CommandResult Fail(string message) 
            => new CommandResult { Success = false, Message = message };
    }
}
```

### **基本命令示例**

```csharp
using NetherGate.API.Commands;
using NetherGate.API.Plugins;

public class SpawnCommand : ICommand
{
    private readonly PluginBase _plugin;
    
    public string Name => "spawn";
    public string Description => "传送到出生点";
    public string Usage => "#spawn";
    public string[] Aliases => new[] { "s" };
    public string PluginId => _plugin.Metadata.Id;
    public string? Permission => "myplugin.spawn";

    public SpawnCommand(PluginBase plugin)
    {
        _plugin = plugin;
    }

    public async Task<CommandResult> ExecuteAsync(string[] args, ICommandSender? sender = null)
    {
        // 只能在游戏内使用
        if (sender == null)
        {
            return CommandResult.Fail("此命令只能在游戏内使用");
        }
        
        // 检查权限（可选，框架会自动检查）
        if (!await _context.PermissionManager.HasPermissionAsync(sender.Name, Permission))
        {
            return CommandResult.Fail("§c你没有权限使用此命令");
        }
        
        // 传送到出生点
        await _context.GameDisplayApi.TeleportPlayer(sender.Name, 0, 64, 0);
        
        return CommandResult.Success("§a已传送到出生点");
    }
}
```

### **带参数的命令**

```csharp
public class TeleportCommand : ICommand
{
    private readonly IPluginContext _context;
    
    public string Name => "tp";
    public string Description => "传送到指定坐标或玩家";
    public string[] Aliases => new[] { "teleport" };
    public string? Permission => "myplugin.tp";
    public string? Usage => "#tp <x> <y> <z> 或 #tp <玩家>";

    public TeleportCommand(IPluginContext context)
    {
        _context = context;
    }

    public async Task<CommandResult> ExecuteAsync(string[] args, ICommandSender? sender = null)
    {
        if (sender == null)
        {
            return CommandResult.Fail("此命令只能在游戏内使用");
        }
        
        if (args.Length == 0)
        {
            return CommandResult.Fail($"用法: {Usage}");
        }
        
        // 传送到玩家
        if (args.Length == 1)
        {
            string targetPlayer = args[0];
            await _context.GameDisplayApi.TeleportPlayerToPlayer(sender.Name, targetPlayer);
            return CommandResult.Success($"§a已传送到 {targetPlayer}");
        }
        
        // 传送到坐标
        if (args.Length == 3)
        {
            if (!int.TryParse(args[0], out int x) ||
                !int.TryParse(args[1], out int y) ||
                !int.TryParse(args[2], out int z))
            {
                return CommandResult.Fail("§c坐标必须是整数");
            }
            
            await _context.GameDisplayApi.TeleportPlayer(sender.Name, x, y, z);
            return CommandResult.Success($"§a已传送到 ({x}, {y}, {z})");
        }
        
        return CommandResult.Fail($"用法: {Usage}");
    }

    public async Task<List<string>> TabCompleteAsync(string[] args, ICommandSender? sender = null)
    {
        // 第一个参数：在线玩家列表
        if (args.Length == 1)
        {
            return GetOnlinePlayerNames();
        }
        
        return new List<string>();
    }
    
    private List<string> GetOnlinePlayerNames()
    {
        // 实现获取在线玩家列表的逻辑
        return new List<string> { "Steve", "Alex" };
    }
}
```

### **子命令系统**

```csharp
public class PluginCommand : ICommand
{
    private readonly IPluginContext _context;
    
    public string Name => "plugin";
    public string Description => "插件管理命令";
    public string? Permission => "nethergate.plugin";
    public string? Usage => "#plugin <list|reload|info> [name]";

    public PluginCommand(IPluginContext context)
    {
        _context = context;
    }

    public async Task<CommandResult> ExecuteAsync(string[] args, ICommandSender? sender = null)
    {
        if (args.Length == 0)
        {
            return CommandResult.Fail($"用法: {Usage}");
        }
        
        string subCommand = args[0].ToLower();
        
        return subCommand switch
        {
            "list" => await ListPlugins(),
            "reload" => await ReloadPlugin(args),
            "info" => await ShowPluginInfo(args),
            _ => CommandResult.Fail($"未知子命令: {subCommand}\n用法: {Usage}")
        };
    }

    private async Task<CommandResult> ListPlugins()
    {
        var plugins = _context.PluginManager.GetLoadedPlugins();
        var message = $"§a已加载插件 ({plugins.Count}):\n";
        
        foreach (var plugin in plugins)
        {
            message += $"§f- {plugin.Name} v{plugin.Version}\n";
        }
        
        return CommandResult.Success(message);
    }

    private async Task<CommandResult> ReloadPlugin(string[] args)
    {
        if (args.Length < 2)
        {
            return CommandResult.Fail("用法: #plugin reload <name>");
        }
        
        string pluginName = args[1];
        await _context.PluginManager.ReloadPluginAsync(pluginName);
        
        return CommandResult.Success($"§a插件 {pluginName} 已重载");
    }

    private async Task<CommandResult> ShowPluginInfo(string[] args)
    {
        if (args.Length < 2)
        {
            return CommandResult.Fail("用法: #plugin info <name>");
        }
        
        string pluginName = args[1];
        var plugin = _context.PluginManager.GetPlugin(pluginName);
        
        if (plugin == null)
        {
            return CommandResult.Fail($"§c插件 {pluginName} 未找到");
        }
        
        var info = $"§6插件信息:\n" +
                   $"§f名称: {plugin.Name}\n" +
                   $"§f版本: {plugin.Version}\n" +
                   $"§f作者: {plugin.Author}\n" +
                   $"§f描述: {plugin.Description}";
        
        return CommandResult.Success(info);
    }

    public async Task<List<string>> TabCompleteAsync(string[] args, ICommandSender? sender = null)
    {
        // 第一个参数：子命令
        if (args.Length == 1)
        {
            return new List<string> { "list", "reload", "info" };
        }
        
        // 第二个参数：插件名称
        if (args.Length == 2 && (args[0] == "reload" || args[0] == "info"))
        {
            return _context.PluginManager.GetLoadedPlugins()
                .Select(p => p.Name)
                .ToList();
        }
        
        return new List<string>();
    }
}
```

---

## 📝 **注册命令**

### **在插件中注册**

```csharp
public class MyPlugin : IPlugin
{
    private IPluginContext _context;

    public void OnEnable(IPluginContext context)
    {
        _context = context;
        
        // 注册多个命令
        context.CommandManager.RegisterCommand(new SpawnCommand(context));
        context.CommandManager.RegisterCommand(new TeleportCommand(context));
        context.CommandManager.RegisterCommand(new HomeCommand(context));
        
        context.Logger.Info("命令已注册");
    }

    public void OnDisable()
    {
        // 框架会自动注销插件的命令
        _context.Logger.Info("命令已注销");
    }
}
```

### **动态注册和注销**

```csharp
// 动态注册
var command = new MyCommand();
_context.CommandManager.RegisterCommand(command);

// 动态注销
_context.CommandManager.UnregisterCommand("mycommand");
```

---

## 🎨 **命令前缀**

### **控制台命令（无前缀）**

从 NetherGate 控制台执行的命令**不需要任何前缀**：

```bash
> help
> plugin list
> permission reload
> stop
```

### **游戏内命令（# 前缀）**

从 Minecraft 聊天框执行的框架命令**必须使用 `#` 前缀**：

```
#help
#spawn
#tp Steve
#home
```

**为什么使用 `#` 而不是 `/`？**
- `/` 是 Minecraft 原生命令的前缀（如 `/give`, `/tp` 等）
- `#` 是 NetherGate 框架命令的前缀，避免冲突
- 这样可以同时使用原版命令和框架命令

### **RCON 命令（/ 前缀）**

通过 `GameDisplayApi` 发送的命令是原生 Minecraft 命令，使用 `/` 前缀：

```csharp
await _context.GameDisplayApi.TeleportPlayer("Steve", 0, 64, 0);
// 内部执行: /tp Steve 0 64 0
```

---

## 🔒 **权限检查**

### **自动权限检查**

框架会自动检查命令的 `Permission` 属性：

```csharp
public class AdminCommand : ICommand
{
    public string Name => "admin";
    public string? Permission => "myplugin.admin";  // 框架自动检查

    public async Task<CommandResult> ExecuteAsync(string[] args, ICommandSender? sender = null)
    {
        // 如果玩家没有 myplugin.admin 权限，框架会自动拒绝执行
        return CommandResult.Success("管理员操作成功");
    }
}
```

### **手动权限检查**

```csharp
public async Task<CommandResult> ExecuteAsync(string[] args, ICommandSender? sender = null)
{
    if (sender != null)
    {
        // 手动检查权限
        if (!await _context.PermissionManager.HasPermissionAsync(sender.Name, "myplugin.vip"))
        {
            return CommandResult.Fail("§c此功能仅限 VIP 使用");
        }
    }
    
    // 执行命令逻辑
    return CommandResult.Success("操作成功");
}
```

### **多权限检查**

```csharp
public async Task<CommandResult> ExecuteAsync(string[] args, ICommandSender? sender = null)
{
    if (sender != null)
    {
        bool hasAnyPermission = 
            await _context.PermissionManager.HasPermissionAsync(sender.Name, "myplugin.admin") ||
            await _context.PermissionManager.HasPermissionAsync(sender.Name, "myplugin.moderator");
        
        if (!hasAnyPermission)
        {
            return CommandResult.Fail("§c你需要管理员或版主权限");
        }
    }
    
    return CommandResult.Success("操作成功");
}
```

---

## ⌨️ **Tab 补全**

### **基本补全**

```csharp
public async Task<List<string>> TabCompleteAsync(string[] args, ICommandSender? sender = null)
{
    // 第一个参数：子命令
    if (args.Length == 1)
    {
        return new List<string> { "create", "delete", "list" };
    }
    
    // 第二个参数：名称
    if (args.Length == 2)
    {
        return GetAvailableNames();
    }
    
    return new List<string>();
}
```

### **动态补全**

```csharp
public async Task<List<string>> TabCompleteAsync(string[] args, ICommandSender? sender = null)
{
    if (args.Length == 1)
    {
        // 根据已输入内容过滤
        string input = args[0].ToLower();
        var allPlayers = GetOnlinePlayerNames();
        return allPlayers.Where(p => p.ToLower().StartsWith(input)).ToList();
    }
    
    return new List<string>();
}
```

### **多级补全**

```csharp
public async Task<List<string>> TabCompleteAsync(string[] args, ICommandSender? sender = null)
{
    if (args.Length == 1)
    {
        // 第一级：子命令
        return new List<string> { "add", "remove", "list" };
    }
    
    if (args.Length == 2)
    {
        // 第二级：根据子命令返回不同选项
        return args[0].ToLower() switch
        {
            "add" => GetAvailableItems(),
            "remove" => GetPlayerItems(sender?.Name),
            "list" => new List<string>(),
            _ => new List<string>()
        };
    }
    
    return new List<string>();
}
```

---

## 🔗 **命令别名**

命令别名允许用户使用不同的名称执行同一命令，支持多语言和自定义缩写。

### **定义别名**

```csharp
public class TeleportCommand : ICommand
{
    public string Name => "teleport";
    public string[] Aliases => new[] { "tp", "tele", "传送", "瞬移" };  // 支持多个别名

    // ...
}
```

使用别名：
```bash
#teleport Steve 0 64 0
#tp Steve 0 64 0        # 使用别名 tp
#tele Steve 0 64 0      # 使用别名 tele
#传送 Steve 0 64 0      # 中文别名
#瞬移 Steve 0 64 0      # 中文同义词
```

### **多语言支持示例**

完整的多语言命令别名示例：

```csharp
public class BackupCommand : ICommand
{
    private readonly PluginBase _plugin;
    
    public string Name => "backup";
    public string Description => "创建服务器备份";
    public string Usage => "#backup [create|restore|list] [name]";
    
    // 多语言别名
    public string[] Aliases => new[]
    {
        // 英文
        "bak",              // 缩写
        "save",             // 同义词
        "backup-server",    // 详细描述
        
        // 中文
        "备份",
        "保存",
        "存档",
        
        // 日文
        "バックアップ",
        
        // 其他语言
        "sicherung",        // 德语
        "sauvegarde"        // 法语
    };
    
    public string PluginId => _plugin.Metadata.Id;
    public string? Permission => "myplugin.backup";
    
    public BackupCommand(PluginBase plugin)
    {
        _plugin = plugin;
    }
    
    public async Task<CommandResult> ExecuteAsync(ICommandSender sender, string[] args)
    {
        if (args.Length == 0)
        {
            // 创建备份
            var name = DateTime.Now.ToString("yyyyMMdd_HHmmss");
            await _plugin.BackupManager.CreateBackupAsync(name);
            return CommandResult.Ok($"✓ 备份已创建: {name}");
        }
        
        var action = args[0].ToLower();
        
        return action switch
        {
            "list" or "列表" or "リスト" => await ListBackupsAsync(),
            "restore" or "恢复" or "復元" => await RestoreBackupAsync(args),
            "create" or "创建" or "作成" => await CreateBackupAsync(args),
            _ => CommandResult.Fail($"未知操作: {action}")
        };
    }
    
    public async Task<List<string>> TabCompleteAsync(ICommandSender sender, string[] args)
    {
        if (args.Length == 1)
        {
            // 补全子命令（多语言）
            return new List<string> 
            { 
                "create", "创建", "作成",
                "restore", "恢复", "復元",
                "list", "列表", "リスト"
            }
            .Where(cmd => cmd.StartsWith(args[0], StringComparison.OrdinalIgnoreCase))
            .ToList();
        }
        
        if (args.Length == 2 && (args[0] == "restore" || args[0] == "恢复" || args[0] == "復元"))
        {
            // 补全备份名称
            var backups = await _plugin.BackupManager.ListBackupsAsync();
            return backups.Where(b => b.StartsWith(args[1])).ToList();
        }
        
        return new List<string>();
    }
}
```

**使用示例**：

```bash
# 英文用户
backup list
bak create world1
save restore world1_20250105

# 中文用户
备份 列表
保存 创建 world1
存档 恢复 world1_20250105

# 日文用户
バックアップ リスト
バックアップ 作成 world1

# 所有别名都支持 Tab 补全
bak li[Tab]      → list, 列表, リスト
备份 创[Tab]     → 创建, 作成
```

### **别名最佳实践**

#### **1. 提供常用缩写**

```csharp
public string Name => "gamemode";
public string[] Aliases => new[]
{
    "gm",          // 通用缩写
    "mode",        // 简短同义词
    "游戏模式",    // 本地化
    "ゲームモード"  // 日文
};
```

#### **2. 支持同义词**

```csharp
public string Name => "home";
public string[] Aliases => new[]
{
    "h",           // 缩写
    "spawn",       // 英文同义词
    "回家",        // 中文
    "家",          // 中文简写
    "ホーム"       // 日文
};
```

#### **3. 考虑用户习惯**

```csharp
// 如果用户习惯 MCDR 或其他工具的命令
public string Name => "reload";
public string[] Aliases => new[]
{
    "rl",          // MCDR 风格缩写
    "重载",        // 中文
    "リロード"     // 日文
};
```

### **动态别名注册**

某些情况下，您可能需要动态注册别名：

```csharp
public class MyPlugin : PluginBase
{
    public override async Task OnEnableAsync()
    {
        // 注册主命令
        var command = new MyCommand(this);
        Commands.RegisterCommand(command);
        
        // 根据配置文件动态添加别名
        var config = await Config.LoadAsync<MyConfig>();
        foreach (var alias in config.CustomAliases)
        {
            Commands.RegisterAlias("mycommand", alias);
        }
    }
}
```

### **注意事项**

- ✅ **别名必须唯一**：不能与其他命令或别名冲突
- ✅ **支持 Unicode**：支持任意 Unicode 字符（中文、日文、表情符号等）
- ✅ **Tab 补全**：Tab 补全会同时匹配主命令和所有别名
- ✅ **区分大小写**：默认不区分大小写（`TP` 和 `tp` 相同）
- ⚠️ **避免过于通用**：不要使用过于简短的别名（如 `a`, `b`），可能导致混淆
- ⚠️ **保持直观**：别名应该易记且与命令功能相关

---

## 💡 **最佳实践**

### **1. 清晰的使用说明**

✅ **推荐：**
```csharp
public string? Usage => "#tp <x> <y> <z> 或 #tp <玩家>";
```

❌ **不推荐：**
```csharp
public string? Usage => "#tp";  // 不够详细
```

### **2. 参数验证**

```csharp
public async Task<CommandResult> ExecuteAsync(string[] args, ICommandSender? sender = null)
{
    // 检查参数数量
    if (args.Length < 2)
    {
        return CommandResult.Fail($"§c用法: {Usage}");
    }
    
    // 验证参数类型
    if (!int.TryParse(args[0], out int value))
    {
        return CommandResult.Fail("§c第一个参数必须是整数");
    }
    
    // 验证参数范围
    if (value < 0 || value > 100)
    {
        return CommandResult.Fail("§c数值必须在 0-100 之间");
    }
    
    return CommandResult.Success("操作成功");
}
```

### **3. 友好的错误消息**

```csharp
// ✅ 提供具体的错误信息和解决方案
return CommandResult.Fail("§c玩家 'Steve' 不在线\n§7提示: 使用 #list 查看在线玩家");

// ❌ 模糊的错误信息
return CommandResult.Fail("错误");
```

### **4. 异步操作**

```csharp
public async Task<CommandResult> ExecuteAsync(string[] args, ICommandSender? sender = null)
{
    // 使用 await 进行异步操作
    await _context.GameDisplayApi.TeleportPlayer(sender.Name, 0, 64, 0);
    await Task.Delay(1000);
    await _context.GameDisplayApi.SendChatMessage(sender.Name, "传送完成");
    
    return CommandResult.Success("操作成功");
}
```

### **5. 控制台兼容性**

```csharp
public async Task<CommandResult> ExecuteAsync(string[] args, ICommandSender? sender = null)
{
    // 某些命令只能在游戏内使用
    if (sender == null)
    {
        return CommandResult.Fail("此命令只能在游戏内使用");
    }
    
    // 某些命令可以在控制台和游戏内使用
    if (sender == null)
    {
        // 控制台执行
        _context.Logger.Info("命令执行成功");
    }
    else
    {
        // 游戏内执行
        await _context.GameDisplayApi.SendChatMessage(sender.Name, "§a命令执行成功");
    }
    
    return CommandResult.Success();
}
```

---

## 📚 **相关文档**

- [权限系统](./权限系统.md)
- [游戏显示 API](../04-高级功能/游戏显示API.md)
- [插件开发指南](../03-插件开发/插件开发指南.md)

---

**文档维护者：** NetherGate 开发团队  
**最后更新：** 2025-10-05
