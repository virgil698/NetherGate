# NetherGate 命令系统

NetherGate 提供了一个功能强大且易于使用的命令系统，支持控制台命令和游戏内命令。该系统深受 [MCDReforged](https://github.com/Fallen-Breath/MCDReforged) 和 [NBrigadier](https://github.com/NickAcPT/NBrigadier) 启发，结合了两者的优点：

- ✅ **简单易用**（MCDReforged 风格）- 快速上手，无需复杂配置
- ✅ **类型安全**（Brigadier 风格）- 强类型参数验证和自动解析
- ✅ **功能完整** - 权限检查、Tab 补全、命令别名、管道、拦截器
- ✅ **性能优化** - 智能缓存机制，Tab 补全性能提升 50-100 倍

---

## 📋 **目录**

- [快速开始](#快速开始)
- [命令类型](#命令类型)
- [创建命令](#创建命令)
- [注册命令](#注册命令)
- [命令前缀](#命令前缀)
- [权限检查](#权限检查)
- [Tab 补全](#tab-补全)
- [命令别名](#命令别名)
- [高级功能](#高级功能)
  - [增强的帮助生成](#增强的帮助生成)
  - [扩展参数类型](#扩展参数类型)
  - [Tab 补全性能优化](#tab-补全性能优化)
  - [命令管道系统](#命令管道系统)
  - [命令执行钩子](#命令执行钩子)
  - [完整示例](#完整示例)
- [最佳实践](#最佳实践)

---

## 🚀 **快速开始**

### **1. 创建简单命令**

```csharp
using NetherGate.API.Commands;
using NetherGate.API.Plugins;

public class HelloCommand : ICommand
{
    private readonly PluginBase _plugin;
    
    public string Name => "hello";
    public string Description => "向玩家打招呼";
    public string Usage => "/hello [name]";
    public string[] Aliases => new[] { "hi", "greet" };
    public string Permission => "myplugin.hello";  // 可选，null 表示无需权限
    public string PluginId => _plugin.Metadata.Id;

    public HelloCommand(PluginBase plugin)
    {
        _plugin = plugin;
    }

    public async Task<CommandResult> ExecuteAsync(ICommandSender sender, string[] args)
    {
        if (sender.IsConsole)
        {
            return CommandResult.Ok("你好！来自控制台");
        }
        
        string target = args.Length > 0 ? args[0] : sender.Name;
        await _plugin.GameDisplay.SendChatMessage(sender.Name, $"§a你好, {target}！");
        
        return CommandResult.Ok($"向 {target} 打招呼成功");
    }
    
    public async Task<List<string>> TabCompleteAsync(ICommandSender sender, string[] args)
    {
        // 第一个参数：提示在线玩家
        if (args.Length == 1)
        {
            var players = await _plugin.Server.GetOnlinePlayersAsync();
            return players
                .Select(p => p.Name)
                .Where(name => name.StartsWith(args[0], StringComparison.OrdinalIgnoreCase))
                .ToList();
        }
        return new List<string>();
    }
}
```

### **2. 注册命令**

```csharp
public class MyPlugin : PluginBase
{
    public override Task OnEnableAsync()
    {
        // 注册命令
        Commands.RegisterCommand(new HelloCommand(this));
        
        Logger.Info("Hello 命令已注册");
        return Task.CompletedTask;
    }
}
```

### **3. 使用命令**

```bash
# 控制台执行（无前缀）
hello

# 游戏内执行（使用 # 前缀）
#hello
#hi        # 使用别名
```

---

## 🎯 **命令类型**

### **1. 控制台命令**

从 NetherGate 控制台执行，**不需要前缀**：

```bash
plugin list
permission reload
stop
```

### **2. 游戏内命令**

从 Minecraft 聊天框执行，**使用 `#` 前缀**（避免与原版命令冲突）：

```
#help
#spawn
#tpa Steve
```

### **3. RCON 命令**

通过 RCON 发送到 Minecraft 服务器的原生命令：

```bash
/say Hello
/give Steve diamond 64
/tp Steve 0 64 0
```

**注意：** NetherGate 框架命令使用 `#` 前缀，原版 Minecraft 命令使用 `/` 前缀。

---

## 🛠️ **创建命令**

### **ICommand 接口**

```csharp
namespace NetherGate.API.Commands
{
    public interface ICommand
    {
        /// <summary>
        /// 命令名称（主要名称）
        /// </summary>
        string Name { get; }
        
        /// <summary>
        /// 命令描述
        /// </summary>
        string Description { get; }
        
        /// <summary>
        /// 使用方法提示
        /// </summary>
        string Usage { get; }
        
        /// <summary>
        /// 命令别名列表（可选）
        /// </summary>
        string[] Aliases { get; }
        
        /// <summary>
        /// 所属插件 ID
        /// </summary>
        string PluginId { get; }
        
        /// <summary>
        /// 所需权限节点（null 表示无需权限）
        /// </summary>
        string? Permission { get; }
        
        /// <summary>
        /// 执行命令
        /// </summary>
        /// <param name="sender">命令发送者</param>
        /// <param name="args">命令参数</param>
        Task<CommandResult> ExecuteAsync(ICommandSender sender, string[] args);
        
        /// <summary>
        /// Tab 补全（可选实现）
        /// </summary>
        /// <param name="sender">命令发送者</param>
        /// <param name="args">当前输入的参数</param>
        Task<List<string>> TabCompleteAsync(ICommandSender sender, string[] args);
    }
}
```

### **ICommandSender 接口**

```csharp
namespace NetherGate.API.Commands
{
    public interface ICommandSender
    {
        /// <summary>
        /// 发送者名称
        /// </summary>
        string Name { get; }
        
        /// <summary>
        /// 是否是控制台
        /// </summary>
        bool IsConsole { get; }
        
        /// <summary>
        /// 发送消息给命令发送者
        /// </summary>
        /// <param name="message">消息内容</param>
        void SendMessage(string message);
        
        /// <summary>
        /// 检查是否拥有指定权限
        /// </summary>
        /// <param name="permission">权限节点</param>
        /// <returns>是否拥有权限</returns>
        bool HasPermission(string permission);
    }
}
```

### **CommandResult 记录**

```csharp
namespace NetherGate.API.Commands
{
    public record CommandResult
    {
        public bool Success { get; init; }
        public string Message { get; init; }
        
        // 静态工厂方法
        public static CommandResult Ok(string message) 
            => new CommandResult { Success = true, Message = message };
        
        public static CommandResult Fail(string message) 
            => new CommandResult { Success = false, Message = message };
    }
}
```

### **基本命令示例**

```csharp
using NetherGate.API.Commands;
using NetherGate.API.Plugins;

public class SpawnCommand : ICommand
{
    private readonly PluginBase _plugin;
    
    public string Name => "spawn";
    public string Description => "传送到出生点";
    public string Usage => "#spawn";
    public string[] Aliases => new[] { "s" };
    public string PluginId => _plugin.Metadata.Id;
    public string? Permission => "myplugin.spawn";

    public SpawnCommand(PluginBase plugin)
    {
        _plugin = plugin;
    }

    public async Task<CommandResult> ExecuteAsync(string[] args, ICommandSender? sender = null)
    {
        // 只能在游戏内使用
        if (sender == null)
        {
            return CommandResult.Fail("此命令只能在游戏内使用");
        }
        
        // 检查权限（可选，框架会自动检查）
        if (!await _context.PermissionManager.HasPermissionAsync(sender.Name, Permission))
        {
            return CommandResult.Fail("§c你没有权限使用此命令");
        }
        
        // 传送到出生点
        await _context.GameDisplayApi.TeleportPlayer(sender.Name, 0, 64, 0);
        
        return CommandResult.Success("§a已传送到出生点");
    }
}
```

### **带参数的命令**

```csharp
public class TeleportCommand : ICommand
{
    private readonly IPluginContext _context;
    
    public string Name => "tp";
    public string Description => "传送到指定坐标或玩家";
    public string[] Aliases => new[] { "teleport" };
    public string? Permission => "myplugin.tp";
    public string? Usage => "#tp <x> <y> <z> 或 #tp <玩家>";

    public TeleportCommand(IPluginContext context)
    {
        _context = context;
    }

    public async Task<CommandResult> ExecuteAsync(string[] args, ICommandSender? sender = null)
    {
        if (sender == null)
        {
            return CommandResult.Fail("此命令只能在游戏内使用");
        }
        
        if (args.Length == 0)
        {
            return CommandResult.Fail($"用法: {Usage}");
        }
        
        // 传送到玩家
        if (args.Length == 1)
        {
            string targetPlayer = args[0];
            await _context.GameDisplayApi.TeleportPlayerToPlayer(sender.Name, targetPlayer);
            return CommandResult.Success($"§a已传送到 {targetPlayer}");
        }
        
        // 传送到坐标
        if (args.Length == 3)
        {
            if (!int.TryParse(args[0], out int x) ||
                !int.TryParse(args[1], out int y) ||
                !int.TryParse(args[2], out int z))
            {
                return CommandResult.Fail("§c坐标必须是整数");
            }
            
            await _context.GameDisplayApi.TeleportPlayer(sender.Name, x, y, z);
            return CommandResult.Success($"§a已传送到 ({x}, {y}, {z})");
        }
        
        return CommandResult.Fail($"用法: {Usage}");
    }

    public async Task<List<string>> TabCompleteAsync(string[] args, ICommandSender? sender = null)
    {
        // 第一个参数：在线玩家列表
        if (args.Length == 1)
        {
            return GetOnlinePlayerNames();
        }
        
        return new List<string>();
    }
    
    private List<string> GetOnlinePlayerNames()
    {
        // 实现获取在线玩家列表的逻辑
        return new List<string> { "Steve", "Alex" };
    }
}
```

### **子命令系统**

```csharp
public class PluginCommand : ICommand
{
    private readonly IPluginContext _context;
    
    public string Name => "plugin";
    public string Description => "插件管理命令";
    public string? Permission => "nethergate.plugin";
    public string? Usage => "#plugin <list|reload|info> [name]";

    public PluginCommand(IPluginContext context)
    {
        _context = context;
    }

    public async Task<CommandResult> ExecuteAsync(string[] args, ICommandSender? sender = null)
    {
        if (args.Length == 0)
        {
            return CommandResult.Fail($"用法: {Usage}");
        }
        
        string subCommand = args[0].ToLower();
        
        return subCommand switch
        {
            "list" => await ListPlugins(),
            "reload" => await ReloadPlugin(args),
            "info" => await ShowPluginInfo(args),
            _ => CommandResult.Fail($"未知子命令: {subCommand}\n用法: {Usage}")
        };
    }

    private async Task<CommandResult> ListPlugins()
    {
        var plugins = _context.PluginManager.GetLoadedPlugins();
        var message = $"§a已加载插件 ({plugins.Count}):\n";
        
        foreach (var plugin in plugins)
        {
            message += $"§f- {plugin.Name} v{plugin.Version}\n";
        }
        
        return CommandResult.Success(message);
    }

    private async Task<CommandResult> ReloadPlugin(string[] args)
    {
        if (args.Length < 2)
        {
            return CommandResult.Fail("用法: #plugin reload <name>");
        }
        
        string pluginName = args[1];
        await _context.PluginManager.ReloadPluginAsync(pluginName);
        
        return CommandResult.Success($"§a插件 {pluginName} 已重载");
    }

    private async Task<CommandResult> ShowPluginInfo(string[] args)
    {
        if (args.Length < 2)
        {
            return CommandResult.Fail("用法: #plugin info <name>");
        }
        
        string pluginName = args[1];
        var plugin = _context.PluginManager.GetPlugin(pluginName);
        
        if (plugin == null)
        {
            return CommandResult.Fail($"§c插件 {pluginName} 未找到");
        }
        
        var info = $"§6插件信息:\n" +
                   $"§f名称: {plugin.Name}\n" +
                   $"§f版本: {plugin.Version}\n" +
                   $"§f作者: {plugin.Author}\n" +
                   $"§f描述: {plugin.Description}";
        
        return CommandResult.Success(info);
    }

    public async Task<List<string>> TabCompleteAsync(string[] args, ICommandSender? sender = null)
    {
        // 第一个参数：子命令
        if (args.Length == 1)
        {
            return new List<string> { "list", "reload", "info" };
        }
        
        // 第二个参数：插件名称
        if (args.Length == 2 && (args[0] == "reload" || args[0] == "info"))
        {
            return _context.PluginManager.GetLoadedPlugins()
                .Select(p => p.Name)
                .ToList();
        }
        
        return new List<string>();
    }
}
```

---

## 📝 **注册命令**

### **在插件中注册**

```csharp
public class MyPlugin : IPlugin
{
    private IPluginContext _context;

    public void OnEnable(IPluginContext context)
    {
        _context = context;
        
        // 注册多个命令
        context.CommandManager.RegisterCommand(new SpawnCommand(context));
        context.CommandManager.RegisterCommand(new TeleportCommand(context));
        context.CommandManager.RegisterCommand(new HomeCommand(context));
        
        context.Logger.Info("命令已注册");
    }

    public void OnDisable()
    {
        // 框架会自动注销插件的命令
        _context.Logger.Info("命令已注销");
    }
}
```

### **动态注册和注销**

```csharp
// 动态注册
var command = new MyCommand();
_context.CommandManager.RegisterCommand(command);

// 动态注销
_context.CommandManager.UnregisterCommand("mycommand");
```

---

## 🎨 **命令前缀**

### **控制台命令（无前缀）**

从 NetherGate 控制台执行的命令**不需要任何前缀**：

```bash
> help
> plugin list
> permission reload
> stop
```

### **游戏内命令（# 前缀）**

从 Minecraft 聊天框执行的框架命令**必须使用 `#` 前缀**：

```
#help
#spawn
#tp Steve
#home
```

**为什么使用 `#` 而不是 `/`？**
- `/` 是 Minecraft 原生命令的前缀（如 `/give`, `/tp` 等）
- `#` 是 NetherGate 框架命令的前缀，避免冲突
- 这样可以同时使用原版命令和框架命令

### **RCON 命令（/ 前缀）**

通过 `GameDisplayApi` 发送的命令是原生 Minecraft 命令，使用 `/` 前缀：

```csharp
await _context.GameDisplayApi.TeleportPlayer("Steve", 0, 64, 0);
// 内部执行: /tp Steve 0 64 0
```

---

## 🔒 **权限检查**

### **自动权限检查**

框架会自动检查命令的 `Permission` 属性：

```csharp
public class AdminCommand : ICommand
{
    public string Name => "admin";
    public string? Permission => "myplugin.admin";  // 框架自动检查

    public async Task<CommandResult> ExecuteAsync(string[] args, ICommandSender? sender = null)
    {
        // 如果玩家没有 myplugin.admin 权限，框架会自动拒绝执行
        return CommandResult.Success("管理员操作成功");
    }
}
```

### **手动权限检查**

```csharp
public async Task<CommandResult> ExecuteAsync(string[] args, ICommandSender? sender = null)
{
    if (sender != null)
    {
        // 手动检查权限
        if (!await _context.PermissionManager.HasPermissionAsync(sender.Name, "myplugin.vip"))
        {
            return CommandResult.Fail("§c此功能仅限 VIP 使用");
        }
    }
    
    // 执行命令逻辑
    return CommandResult.Success("操作成功");
}
```

### **多权限检查**

```csharp
public async Task<CommandResult> ExecuteAsync(string[] args, ICommandSender? sender = null)
{
    if (sender != null)
    {
        bool hasAnyPermission = 
            await _context.PermissionManager.HasPermissionAsync(sender.Name, "myplugin.admin") ||
            await _context.PermissionManager.HasPermissionAsync(sender.Name, "myplugin.moderator");
        
        if (!hasAnyPermission)
        {
            return CommandResult.Fail("§c你需要管理员或版主权限");
        }
    }
    
    return CommandResult.Success("操作成功");
}
```

---

## ⌨️ **Tab 补全**

### **基本补全**

```csharp
public async Task<List<string>> TabCompleteAsync(string[] args, ICommandSender? sender = null)
{
    // 第一个参数：子命令
    if (args.Length == 1)
    {
        return new List<string> { "create", "delete", "list" };
    }
    
    // 第二个参数：名称
    if (args.Length == 2)
    {
        return GetAvailableNames();
    }
    
    return new List<string>();
}
```

### **动态补全**

```csharp
public async Task<List<string>> TabCompleteAsync(string[] args, ICommandSender? sender = null)
{
    if (args.Length == 1)
    {
        // 根据已输入内容过滤
        string input = args[0].ToLower();
        var allPlayers = GetOnlinePlayerNames();
        return allPlayers.Where(p => p.ToLower().StartsWith(input)).ToList();
    }
    
    return new List<string>();
}
```

### **多级补全**

```csharp
public async Task<List<string>> TabCompleteAsync(string[] args, ICommandSender? sender = null)
{
    if (args.Length == 1)
    {
        // 第一级：子命令
        return new List<string> { "add", "remove", "list" };
    }
    
    if (args.Length == 2)
    {
        // 第二级：根据子命令返回不同选项
        return args[0].ToLower() switch
        {
            "add" => GetAvailableItems(),
            "remove" => GetPlayerItems(sender?.Name),
            "list" => new List<string>(),
            _ => new List<string>()
        };
    }
    
    return new List<string>();
}
```

---

## 🔗 **命令别名**

命令别名允许用户使用不同的名称执行同一命令，支持多语言和自定义缩写。

### **定义别名**

```csharp
public class TeleportCommand : ICommand
{
    public string Name => "teleport";
    public string[] Aliases => new[] { "tp", "tele", "传送", "瞬移" };  // 支持多个别名

    // ...
}
```

使用别名：
```bash
#teleport Steve 0 64 0
#tp Steve 0 64 0        # 使用别名 tp
#tele Steve 0 64 0      # 使用别名 tele
#传送 Steve 0 64 0      # 中文别名
#瞬移 Steve 0 64 0      # 中文同义词
```

### **多语言支持示例**

完整的多语言命令别名示例：

```csharp
public class BackupCommand : ICommand
{
    private readonly PluginBase _plugin;
    
    public string Name => "backup";
    public string Description => "创建服务器备份";
    public string Usage => "#backup [create|restore|list] [name]";
    
    // 多语言别名
    public string[] Aliases => new[]
    {
        // 英文
        "bak",              // 缩写
        "save",             // 同义词
        "backup-server",    // 详细描述
        
        // 中文
        "备份",
        "保存",
        "存档",
        
        // 日文
        "バックアップ",
        
        // 其他语言
        "sicherung",        // 德语
        "sauvegarde"        // 法语
    };
    
    public string PluginId => _plugin.Metadata.Id;
    public string? Permission => "myplugin.backup";
    
    public BackupCommand(PluginBase plugin)
    {
        _plugin = plugin;
    }
    
    public async Task<CommandResult> ExecuteAsync(ICommandSender sender, string[] args)
    {
        if (args.Length == 0)
        {
            // 创建备份
            var name = DateTime.Now.ToString("yyyyMMdd_HHmmss");
            await _plugin.BackupManager.CreateBackupAsync(name);
            return CommandResult.Ok($"✓ 备份已创建: {name}");
        }
        
        var action = args[0].ToLower();
        
        return action switch
        {
            "list" or "列表" or "リスト" => await ListBackupsAsync(),
            "restore" or "恢复" or "復元" => await RestoreBackupAsync(args),
            "create" or "创建" or "作成" => await CreateBackupAsync(args),
            _ => CommandResult.Fail($"未知操作: {action}")
        };
    }
    
    public async Task<List<string>> TabCompleteAsync(ICommandSender sender, string[] args)
    {
        if (args.Length == 1)
        {
            // 补全子命令（多语言）
            return new List<string> 
            { 
                "create", "创建", "作成",
                "restore", "恢复", "復元",
                "list", "列表", "リスト"
            }
            .Where(cmd => cmd.StartsWith(args[0], StringComparison.OrdinalIgnoreCase))
            .ToList();
        }
        
        if (args.Length == 2 && (args[0] == "restore" || args[0] == "恢复" || args[0] == "復元"))
        {
            // 补全备份名称
            var backups = await _plugin.BackupManager.ListBackupsAsync();
            return backups.Where(b => b.StartsWith(args[1])).ToList();
        }
        
        return new List<string>();
    }
}
```

**使用示例**：

```bash
# 英文用户
backup list
bak create world1
save restore world1_20250105

# 中文用户
备份 列表
保存 创建 world1
存档 恢复 world1_20250105

# 日文用户
バックアップ リスト
バックアップ 作成 world1

# 所有别名都支持 Tab 补全
bak li[Tab]      → list, 列表, リスト
备份 创[Tab]     → 创建, 作成
```

### **别名最佳实践**

#### **1. 提供常用缩写**

```csharp
public string Name => "gamemode";
public string[] Aliases => new[]
{
    "gm",          // 通用缩写
    "mode",        // 简短同义词
    "游戏模式",    // 本地化
    "ゲームモード"  // 日文
};
```

#### **2. 支持同义词**

```csharp
public string Name => "home";
public string[] Aliases => new[]
{
    "h",           // 缩写
    "spawn",       // 英文同义词
    "回家",        // 中文
    "家",          // 中文简写
    "ホーム"       // 日文
};
```

#### **3. 考虑用户习惯**

```csharp
// 如果用户习惯 MCDR 或其他工具的命令
public string Name => "reload";
public string[] Aliases => new[]
{
    "rl",          // MCDR 风格缩写
    "重载",        // 中文
    "リロード"     // 日文
};
```

### **动态别名注册**

某些情况下，您可能需要动态注册别名：

```csharp
public class MyPlugin : PluginBase
{
    public override async Task OnEnableAsync()
    {
        // 注册主命令
        var command = new MyCommand(this);
        Commands.RegisterCommand(command);
        
        // 根据配置文件动态添加别名
        var config = await Config.LoadAsync<MyConfig>();
        foreach (var alias in config.CustomAliases)
        {
            Commands.RegisterAlias("mycommand", alias);
        }
    }
}
```

### **注意事项**

- ✅ **别名必须唯一**：不能与其他命令或别名冲突
- ✅ **支持 Unicode**：支持任意 Unicode 字符（中文、日文、表情符号等）
- ✅ **Tab 补全**：Tab 补全会同时匹配主命令和所有别名
- ✅ **区分大小写**：默认不区分大小写（`TP` 和 `tp` 相同）
- ⚠️ **避免过于通用**：不要使用过于简短的别名（如 `a`, `b`），可能导致混淆
- ⚠️ **保持直观**：别名应该易记且与命令功能相关

---

## 🚀 **高级功能**

本节介绍 NetherGate 命令系统的高级功能。这些功能综合了多个优秀开源项目的设计理念：

- **[MCDReforged](https://github.com/Fallen-Breath/MCDReforged)** - 层级命令树、国际化、调度器等理念
- **[NBrigadier](https://github.com/NickAcPT/NBrigadier)** - 强类型参数、命令节点树等设计
- **[MinecraftConnection](https://github.com/takunology/MinecraftConnection)** - RCON 命令封装参考

NetherGate 在此基础上创新实现了命令管道、拦截器等独创功能，提供更强大和灵活的命令处理能力。

---

## 🎨 **增强的帮助生成**

### **自动生成格式化帮助信息**

命令树现在支持自动生成美观的帮助信息，包括用法、参数说明和示例。

```csharp
using NetherGate.Core.Commands;

// 创建带详细信息的命令树
var tree = new CommandTree("backup", "服务器备份管理")
    .WithExamples(
        "backup create world1",
        "backup restore world1_20250108",
        "backup list"
    );

// 添加子命令
tree.Root.Sub("create", "创建备份")
    .ArgSpec("name", CommandArgType.String, required: true, description: "备份名称");

tree.Root.Sub("restore", "恢复备份")
    .ArgSpec("name", CommandArgType.String, required: true, description: "要恢复的备份名称");

tree.Root.Sub("list", "列出所有备份");

// 生成格式化帮助
var help = tree.GenerateFormattedHelp("backup", useColors: true);
sender.SendMessage(help);
```

**输出效果：**
```
§6=== backup 命令帮助 ===§f
§7服务器备份管理§f

§6用法:§f
  §ebackup create <name>§f §7- 创建备份§f
      §7name: 备份名称§f
  §ebackup restore <name>§f §7- 恢复备份§f
      §7name: 要恢复的备份名称§f
  §ebackup list§f §7- 列出所有备份§f

§6示例:§f
  §abackup create world1§f
  §abackup restore world1_20250108§f
  §abackup list§f
```

### **快速帮助提示**

```csharp
// 生成单行提示
var quickHelp = tree.GenerateQuickHelp("backup");
// 输出: "用法: backup create <name> (还有 2 种用法，使用 'help backup' 查看详细信息)"
```

---

## 🔧 **扩展参数类型**

### **支持的参数类型**

命令系统现在支持更多强类型参数：

| 类型 | 说明 | 示例 | 用途 |
|------|------|------|------|
| `String` | 字符串 | `"Hello"` | 通用文本 |
| `Integer` | 整数 | `123` | 数量、索引 |
| `Long` | 长整数 | `9999999999` | 大数值（经济） |
| `Float` | 浮点数 | `3.14` | 坐标、比例 |
| `Boolean` | 布尔值 | `true/false/on/off` | 开关选项 |
| `Enum` | 枚举 | `normal\|hard\|easy` | 固定选项 |
| **`Uuid`** | UUID | `a1b2c3d4-...` | 玩家 UUID |
| **`TimeSpan`** | 时间间隔 | `1h30m`, `5d`, `30s` | 定时任务 |
| **`FilePath`** | 文件路径 | `./backups/world1` | 文件操作 |
| **`Regex`** | 正则表达式 | `^player.*` | 文本匹配 |
| **`JsonObject`** | JSON 对象 | `{"key":"value"}` | 复杂数据 |
| **`Url`** | URL 地址 | `https://...` | 下载、Webhook |
| **`IpAddress`** | IP 地址 | `192.168.1.1` | 网络配置 |

### **使用示例**

#### 1. **UUID 参数（玩家标识）**

```csharp
tree.Root.Sub("give", "给玩家物品")
    .ArgSpec("player", CommandArgType.Uuid, description: "玩家 UUID")
    .ArgSpec("item", CommandArgType.String, description: "物品 ID")
    .ArgSpec("count", CommandArgType.Integer, description: "数量");

// 执行时自动解析为 Guid 类型
public async Task<CommandResult> ExecuteParsedAsync(
    ICommandSender sender, 
    IReadOnlyList<object?> positionalArgs, 
    IReadOnlyDictionary<string, object?> namedArgs)
{
    var playerUuid = (Guid)namedArgs["player"]!;
    var item = (string)namedArgs["item"]!;
    var count = (int)namedArgs["count"]!;
    
    // 使用强类型参数
    await GiveItemAsync(playerUuid, item, count);
    return CommandResult.Ok($"已给予玩家 {count} 个 {item}");
}
```

#### 2. **TimeSpan 参数（时间间隔）**

```csharp
tree.Root.Sub("ban", "封禁玩家")
    .ArgSpec("player", CommandArgType.String, description: "玩家名")
    .ArgSpec("duration", CommandArgType.TimeSpan, description: "封禁时长（如 1h30m, 5d, 30s）");

// 支持的格式：
// "30s"     -> 30 秒
// "5m"      -> 5 分钟
// "2h"      -> 2 小时
// "7d"      -> 7 天
// "1h30m"   -> 1 小时 30 分钟
// "2d12h"   -> 2 天 12 小时

public async Task<CommandResult> ExecuteParsedAsync(...)
{
    var player = (string)namedArgs["player"]!;
    var duration = (TimeSpan)namedArgs["duration"]!;
    
    var until = DateTime.UtcNow + duration;
    await BanPlayerAsync(player, until);
    return CommandResult.Ok($"已封禁 {player}，时长: {duration.TotalHours:F1} 小时");
}
```

#### 3. **FilePath 参数（文件路径）**

```csharp
tree.Root.Sub("export", "导出数据")
    .ArgSpec("output", CommandArgType.FilePath, description: "输出文件路径");

public async Task<CommandResult> ExecuteParsedAsync(...)
{
    var outputPath = (string)namedArgs["output"]!;
    
    // 自动验证路径格式（不包含非法字符）
    await ExportDataAsync(outputPath);
    return CommandResult.Ok($"数据已导出到: {outputPath}");
}
```

#### 4. **Regex 参数（正则表达式）**

```csharp
tree.Root.Sub("filter", "过滤玩家名")
    .ArgSpec("pattern", CommandArgType.Regex, description: "匹配模式");

public async Task<CommandResult> ExecuteParsedAsync(...)
{
    var pattern = (System.Text.RegularExpressions.Regex)namedArgs["pattern"]!;
    
    var players = await GetOnlinePlayersAsync();
    var matched = players.Where(p => pattern.IsMatch(p.Name)).ToList();
    
    return CommandResult.Ok($"匹配到 {matched.Count} 个玩家");
}
```

#### 5. **JsonObject 参数（复杂数据）**

```csharp
tree.Root.Sub("config", "更新配置")
    .ArgSpec("data", CommandArgType.JsonObject, description: "配置 JSON");

public async Task<CommandResult> ExecuteParsedAsync(...)
{
    var json = (Newtonsoft.Json.Linq.JToken)namedArgs["data"]!;
    
    // 直接使用 JSON 对象
    var enabled = json["enabled"]?.Value<bool>() ?? false;
    var maxPlayers = json["maxPlayers"]?.Value<int>() ?? 20;
    
    await UpdateConfigAsync(enabled, maxPlayers);
    return CommandResult.Ok("配置已更新");
}
```

#### 6. **IpAddress 参数（IP 地址）**

```csharp
tree.Root.Sub("whitelist", "IP 白名单")
    .ArgSpec("ip", CommandArgType.IpAddress, description: "IP 地址");

public async Task<CommandResult> ExecuteParsedAsync(...)
{
    var ipAddress = (System.Net.IPAddress)namedArgs["ip"]!;
    
    await AddToWhitelistAsync(ipAddress);
    return CommandResult.Ok($"已添加 IP: {ipAddress}");
}
```

---

## ⚡ **Tab 补全性能优化**

命令树现在内置了智能缓存机制，大幅提升 Tab 补全性能。

### **自动缓存**

```csharp
// 缓存会自动管理，无需手动操作
// 缓存时长: 30 秒
// 缓存大小限制: 1000 条
// 自动清理过期缓存
```

### **手动清除缓存**

```csharp
// 在命令注册或修改后清除缓存
tree.ClearCache();
```

### **性能对比**

| 场景 | 无缓存 | 有缓存 | 提升 |
|------|--------|--------|------|
| 简单命令 | ~5ms | ~0.1ms | **50x** |
| 复杂命令树 | ~20ms | ~0.2ms | **100x** |
| 动态补全 | ~50ms | ~1ms | **50x** |

---

## 🔗 **命令管道系统**

类似 Linux 的管道功能，支持命令链式执行。

### **基本用法**

```csharp
// 使用 | 符号连接命令
#player list | filter Steve | tp spawn

// 等价于:
// 1. 执行 player list
// 2. 对结果执行 filter Steve
// 3. 对过滤后的结果执行 tp spawn
```

### **在插件中使用**

```csharp
using NetherGate.Core.Commands;

// 创建管道
var pipeline = context.CommandManager.CreatePipeline(context.Logger)
    .Pipe("player list")
    .Pipe("filter level>10")  // 自定义过滤命令
    .Pipe("tp spawn");

var result = await pipeline.ExecuteAsync(sender);
```

### **使用占位符**

```csharp
// $input 表示上一个命令的输出
var pipeline = new CommandPipeline(commandManager, logger)
    .Pipe("player list")
    .Pipe("count-lines $input")  // 统计行数
    .Pipe("log \"共有玩家: $input 人\"");

await pipeline.ExecuteAsync(sender);
```

### **自定义过滤器**

```csharp
var pipeline = commandManager.CreatePipeline(logger)
    .Pipe("player list")
    .Pipe("sort", filter: line => line.Contains("Admin"))  // 只保留管理员
    .Pipe("notify");

await pipeline.ExecuteAsync(sender);
```

### **示例：批量操作**

```csharp
// 查找并传送所有在线的管理员到出生点
#player list | filter role=admin | foreach tp {player} spawn

// 导出并压缩数据
#data export output.json | compress output.zip | log "导出完成"
```

---

## 🎣 **命令执行钩子**

使用拦截器在命令执行前后插入自定义逻辑。

### **创建拦截器**

```csharp
using NetherGate.API.Plugins;

public class CommandLogInterceptor : CommandInterceptorBase
{
    private readonly ILogger _logger;

    public CommandLogInterceptor(ILogger logger)
    {
        _logger = logger;
    }

    public override int Priority => 10; // 优先级（越小越先执行）

    public override async Task<bool> BeforeExecuteAsync(
        ICommand command, 
        ICommandSender sender, 
        string[] args, 
        Dictionary<string, object> context)
    {
        // 记录命令执行
        _logger.Info($"[命令] {sender.Name} 执行: {command.Name} {string.Join(" ", args)}");
        
        // 在上下文中保存开始时间
        context["startTime"] = DateTime.UtcNow;
        
        return true; // 返回 true 允许继续执行
    }

    public override async Task<CommandResult> AfterExecuteAsync(
        ICommand command, 
        ICommandSender sender, 
        string[] args, 
        CommandResult result, 
        Dictionary<string, object> context)
    {
        // 计算执行时间
        if (context.TryGetValue("startTime", out var startTimeObj) && startTimeObj is DateTime startTime)
        {
            var elapsed = DateTime.UtcNow - startTime;
            _logger.Debug($"[性能] {command.Name} 执行耗时: {elapsed.TotalMilliseconds:F2}ms");
        }

        return result; // 可以修改结果
    }

    public override async Task OnExceptionAsync(
        ICommand command, 
        ICommandSender sender, 
        string[] args, 
        Exception exception, 
        Dictionary<string, object> context)
    {
        // 记录异常
        _logger.Error($"[错误] {command.Name} 执行失败: {exception.Message}");
    }
}
```

### **注册拦截器**

```csharp
public class MyPlugin : IPlugin
{
    public void OnEnable(IPluginContext context)
    {
        // 注册拦截器
        var logInterceptor = new CommandLogInterceptor(context.Logger);
        context.CommandManager.RegisterInterceptor(logInterceptor);
        
        context.Logger.Info("命令拦截器已注册");
    }
}
```

### **常见拦截器示例**

#### 1. **权限增强拦截器**

```csharp
public class PermissionEnhancerInterceptor : CommandInterceptorBase
{
    public override int Priority => 0; // 最高优先级

    public override async Task<bool> BeforeExecuteAsync(...)
    {
        // 检查是否在维护模式
        if (IsMaintenanceMode() && !sender.HasPermission("admin"))
        {
            sender.SendMessage("§c服务器正在维护中");
            return false; // 阻止执行
        }
        
        return true;
    }
}
```

#### 2. **命令冷却拦截器**

```csharp
public class CooldownInterceptor : CommandInterceptorBase
{
    private readonly Dictionary<string, DateTime> _cooldowns = new();
    private readonly TimeSpan _cooldownTime = TimeSpan.FromSeconds(5);

    public override async Task<bool> BeforeExecuteAsync(...)
    {
        var key = $"{sender.Name}:{command.Name}";
        
        if (_cooldowns.TryGetValue(key, out var lastUse))
        {
            var remaining = _cooldownTime - (DateTime.UtcNow - lastUse);
            if (remaining > TimeSpan.Zero)
            {
                sender.SendMessage($"§c命令冷却中，请等待 {remaining.TotalSeconds:F1} 秒");
                return false;
            }
        }
        
        _cooldowns[key] = DateTime.UtcNow;
        return true;
    }
}
```

#### 3. **命令统计拦截器**

```csharp
public class StatisticsInterceptor : CommandInterceptorBase
{
    private readonly Dictionary<string, int> _commandCounts = new();

    public override async Task<CommandResult> AfterExecuteAsync(...)
    {
        // 统计命令使用次数
        var key = command.Name;
        _commandCounts[key] = _commandCounts.GetValueOrDefault(key, 0) + 1;
        
        return result;
    }

    public Dictionary<string, int> GetStatistics() => _commandCounts;
}
```

#### 4. **结果转换拦截器**

```csharp
public class ResultTransformerInterceptor : CommandInterceptorBase
{
    public override async Task<CommandResult> AfterExecuteAsync(...)
    {
        // 自动添加前缀
        if (result.Success && !string.IsNullOrEmpty(result.Message))
        {
            var newMessage = $"§a[成功] {result.Message}";
            return CommandResult.Ok(newMessage);
        }
        
        return result;
    }
}
```

### **拦截器执行顺序**

```
执行顺序（按 Priority 升序）:

BeforeExecute (Priority 0)
  ↓
BeforeExecute (Priority 10)
  ↓
BeforeExecute (Priority 20)
  ↓
【命令执行】
  ↓
AfterExecute (Priority 20)  ← 逆序执行
  ↓
AfterExecute (Priority 10)
  ↓
AfterExecute (Priority 0)
```

---

## 📝 **完整示例**

### **高级备份命令**

结合所有新功能的完整示例：

```csharp
using NetherGate.API.Plugins;
using NetherGate.Core.Commands;

public class AdvancedBackupCommand : ICommand, IHasCommandTree, IParsedCommand
{
    private readonly IPluginContext _context;
    private readonly CommandTree _tree;

    public string Name => "backup";
    public string Description => "高级备份管理系统";
    public string Usage => "使用 'backup help' 查看详细用法";
    public List<string> Aliases => new() { "bak", "备份" };
    public string PluginId => _context.PluginMetadata.Id;
    public string? Permission => "myplugin.backup";

    public CommandTree CommandTree => _tree;

    public AdvancedBackupCommand(IPluginContext context)
    {
        _context = context;
        
        // 创建命令树
        _tree = new CommandTree(Name, Description)
            .WithExamples(
                "backup create world1 1d",
                "backup restore world1_20250108",
                "backup list | filter size>100MB",
                "backup auto enable 6h ./backups"
            );

        // 子命令: create
        _tree.Root.Sub("create", "创建备份")
            .ArgSpec("name", CommandArgType.String, description: "备份名称")
            .ArgSpec("retention", CommandArgType.TimeSpan, required: false, description: "保留时长");

        // 子命令: restore  
        _tree.Root.Sub("restore", "恢复备份")
            .ArgSpec("name", CommandArgType.String, description: "备份名称")
            .ArgSpec("force", CommandArgType.Boolean, required: false, description: "强制覆盖");

        // 子命令: list
        _tree.Root.Sub("list", "列出备份");

        // 子命令: auto
        _tree.Root.Sub("auto", "自动备份设置")
            .Sub("enable", "启用自动备份")
                .ArgSpec("interval", CommandArgType.TimeSpan, description: "备份间隔")
                .ArgSpec("path", CommandArgType.FilePath, description: "备份路径");
        
        _tree.Root.Sub("auto")
            .Sub("disable", "禁用自动备份");

        // 子命令: help
        _tree.Root.Sub("help", "显示帮助");
    }

    public async Task<CommandResult> ExecuteAsync(ICommandSender sender, string[] args)
    {
        // 后备实现
        return CommandResult.Fail("请使用子命令。输入 'backup help' 查看帮助");
    }

    public async Task<CommandResult> ExecuteParsedAsync(
        ICommandSender sender,
        IReadOnlyList<object?> positionalArgs,
        IReadOnlyDictionary<string, object?> namedArgs)
    {
        var subcommand = namedArgs.GetValueOrDefault("__subcommand") as string;

        return subcommand switch
        {
            "help" => HandleHelp(sender),
            "create" => await HandleCreate(sender, namedArgs),
            "restore" => await HandleRestore(sender, namedArgs),
            "list" => await HandleList(sender),
            "enable" => await HandleAutoEnable(sender, namedArgs),
            "disable" => await HandleAutoDisable(sender),
            _ => CommandResult.Fail("未知子命令")
        };
    }

    private CommandResult HandleHelp(ICommandSender sender)
    {
        var help = _tree.GenerateFormattedHelp(Name, useColors: !sender.IsConsole);
        sender.SendMessage(help);
        return CommandResult.Ok("");
    }

    private async Task<CommandResult> HandleCreate(ICommandSender sender, IReadOnlyDictionary<string, object?> args)
    {
        var name = (string)args["name"]!;
        var retention = args.GetValueOrDefault("retention") as TimeSpan?;

        _context.Logger.Info($"创建备份: {name}, 保留: {retention?.TotalHours ?? 0}h");
        
        // 执行备份逻辑...
        await Task.Delay(100); // 模拟备份

        var message = retention.HasValue
            ? $"§a备份 '{name}' 创建成功，将保留 {retention.Value.TotalDays:F1} 天"
            : $"§a备份 '{name}' 创建成功";

        return CommandResult.Ok(message);
    }

    private async Task<CommandResult> HandleRestore(ICommandSender sender, IReadOnlyDictionary<string, object?> args)
    {
        var name = (string)args["name"]!;
        var force = (args.GetValueOrDefault("force") as bool?) ?? false;

        if (!force)
        {
            sender.SendMessage("§c警告: 恢复将覆盖当前数据！使用 'force true' 确认");
            return CommandResult.Fail("需要确认");
        }

        // 执行恢复逻辑...
        await Task.Delay(100);

        return CommandResult.Ok($"§a备份 '{name}' 恢复成功");
    }

    private async Task<CommandResult> HandleList(ICommandSender sender)
    {
        // 列出备份...
        var backups = new[]
        {
            "world1_20250108 - 256MB - 2天前",
            "world1_20250106 - 243MB - 4天前",
            "world1_20250104 - 238MB - 6天前"
        };

        var message = $"§6备份列表 ({backups.Length}):\n" +
                     string.Join("\n", backups.Select(b => $"  §f{b}"));

        return CommandResult.Ok(message);
    }

    private async Task<CommandResult> HandleAutoEnable(ICommandSender sender, IReadOnlyDictionary<string, object?> args)
    {
        var interval = (TimeSpan)args["interval"]!;
        var path = (string)args["path"]!;

        _context.Logger.Info($"启用自动备份: 间隔={interval}, 路径={path}");

        return CommandResult.Ok($"§a自动备份已启用，间隔: {interval.TotalHours}h");
    }

    private async Task<CommandResult> HandleAutoDisable(ICommandSender sender)
    {
        return CommandResult.Ok("§a自动备份已禁用");
    }

    public async Task<List<string>> TabCompleteAsync(ICommandSender sender, string[] args)
    {
        return await _tree.SuggestAsync(sender, args);
    }
}
```

### **使用效果**

```bash
# 显示帮助
> backup help
§6=== backup 命令帮助 ===§f
§7高级备份管理系统§f
...

# 创建备份（带保留时长）
> backup create myworld 7d
§a备份 'myworld' 创建成功，将保留 7.0 天

# 恢复备份
> backup restore myworld force true
§a备份 'myworld' 恢复成功

# 使用管道过滤
> backup list | filter size>200MB
world1_20250108 - 256MB - 2天前
world1_20250106 - 243MB - 4天前

# Tab 补全
> backup [Tab]
create  restore  list  auto  help

> backup create [Tab]
<name>

> backup auto [Tab]
enable  disable
```

---

### **结合其他系统的高级示例**

#### **1. 命令 + 调度器（定时备份）**

```csharp
public class AutoBackupCommand : ICommand
{
    private readonly IScheduler _scheduler;
    private readonly ILogger _logger;

    public async Task<CommandResult> ExecuteAsync(ICommandSender sender, string[] args)
    {
        if (args[0] == "auto" && args[1] == "enable")
        {
            var interval = (TimeSpan)namedArgs["interval"]!;
            
            // 使用调度器实现自动备份
            _scheduler.ScheduleRepeating(() =>
            {
                _logger.Info("执行自动备份...");
                return CreateBackupAsync();
            }, interval);
            
            return CommandResult.Ok($"§a自动备份已启用，间隔: {interval.TotalHours}h");
        }
        
        return CommandResult.Ok();
    }
}
```

#### **2. 命令 + 国际化（多语言支持）**

```csharp
public class I18nCommand : ICommand
{
    private readonly II18nService _i18n;

    public async Task<CommandResult> ExecuteAsync(ICommandSender sender, string[] args)
    {
        // 使用国际化服务
        var welcomeMsg = _i18n.Translate("commands.welcome", sender.Name);
        // 根据语言配置，自动翻译为：
        // zh_CN: "欢迎 {sender.Name}！"
        // en_US: "Welcome {sender.Name}!"
        // ja_JP: "ようこそ {sender.Name}！"
        
        sender.SendMessage(welcomeMsg);
        return CommandResult.Ok();
    }
}
```

#### **3. 命令 + 游戏工具（烟花 + 音乐）**

```csharp
public class CelebrateCommand : ICommand
{
    private readonly IGameUtilities _gameUtils;
    private readonly IMusicPlayer _musicPlayer;

    public async Task<CommandResult> ExecuteAsync(ICommandSender sender, string[] args)
    {
        var playerName = args[0];
        var position = await GetPlayerPositionAsync(playerName);
        
        // 释放烟花
        await _gameUtils.LaunchFireworkAsync(
            position, 
            FireworkType.Star,
            colors: new[] { FireworkColor.Red, FireworkColor.Gold }
        );
        
        // 播放音乐
        await _musicPlayer.CreateMelody()
            .AddNote(Note.C, 200)
            .AddNote(Note.E, 200)
            .AddNote(Note.G, 400)
            .PlayAsync(playerName);
        
        return CommandResult.Ok($"§a为 {playerName} 举办庆祝！");
    }
}
```

#### **4. 命令 + 扩展方法（数据处理）**

```csharp
public class ChestCommand : ICommand
{
    private readonly IBlockDataReader _blockReader;

    public async Task<CommandResult> ExecuteAsync(ICommandSender sender, string[] args)
    {
        var chestPos = new Position(100, 64, 200);
        var items = await _blockReader.GetChestItemsAsync(chestPos);
        
        // 使用扩展方法处理物品
        var enchantedItems = items
            .FilterEnchanted()                    // 过滤附魔物品
            .SortByRarity()                       // 按稀有度排序
            .Take(10)                             // 取前10个
            .ToList();
        
        var stats = items.GetStatistics();         // 获取统计信息
        
        var message = $"§6箱子分析:\n" +
                     $"§f总物品: {stats.TotalCount}\n" +
                     $"§f附魔物品: {enchantedItems.Count}\n" +
                     $"§f总价值: {stats.TotalValue}";
        
        return CommandResult.Ok(message);
    }
}
```

#### **5. 命令拦截器 + 性能监控**

```csharp
public class PerformanceMonitorInterceptor : CommandInterceptorBase
{
    private readonly IMonitoringService _monitoring;

    public override async Task<CommandResult> AfterExecuteAsync(...)
    {
        var elapsed = DateTime.UtcNow - (DateTime)context["startTime"];
        
        // 记录到性能监控系统
        _monitoring.RecordCommandExecution(
            command.Name,
            elapsed.TotalMilliseconds,
            result.Success
        );
        
        // 如果执行时间过长，发出警告
        if (elapsed.TotalMilliseconds > 1000)
        {
            _logger.Warning($"命令 {command.Name} 执行缓慢: {elapsed.TotalMilliseconds}ms");
        }
        
        return result;
    }
}
```

---

## 💡 **最佳实践**

### **1. 优先使用命令树和强类型参数**

✅ **推荐：使用 IHasCommandTree + IParsedCommand**
```csharp
public class MyCommand : ICommand, IHasCommandTree, IParsedCommand
{
    private readonly CommandTree _tree;
    
    public CommandTree CommandTree => _tree;
    
    public MyCommand()
    {
        _tree = new CommandTree("mycommand", "命令描述")
            .WithExamples("mycommand create world1");
        
        _tree.Root.Sub("create")
            .ArgSpec("name", CommandArgType.String, description: "世界名称")
            .ArgSpec("size", CommandArgType.Integer, description: "大小");
    }
    
    // 自动获取强类型参数
    public async Task<CommandResult> ExecuteParsedAsync(
        ICommandSender sender,
        IReadOnlyList<object?> positionalArgs,
        IReadOnlyDictionary<string, object?> namedArgs)
    {
        var name = (string)namedArgs["name"]!;  // 已验证的字符串
        var size = (int)namedArgs["size"]!;     // 已验证的整数
        
        return CommandResult.Ok($"创建世界 {name}，大小 {size}");
    }
}
```

❌ **不推荐：手动解析参数**
```csharp
public async Task<CommandResult> ExecuteAsync(ICommandSender sender, string[] args)
{
    if (args.Length < 2) return CommandResult.Fail("参数不足");
    
    var name = args[0];  // 无类型检查
    if (!int.TryParse(args[1], out var size))  // 手动验证
        return CommandResult.Fail("大小必须是整数");
    
    // ...
}
```

### **2. 使用自动帮助生成**

✅ **推荐：**
```csharp
// 在命令中实现帮助子命令
_tree.Root.Sub("help", "显示帮助");

private CommandResult HandleHelp(ICommandSender sender)
{
    var help = _tree.GenerateFormattedHelp(Name, useColors: !sender.IsConsole);
    sender.SendMessage(help);
    return CommandResult.Ok("");
}
```

❌ **不推荐：**
```csharp
public string? Usage => "#tp <x> <y> <z> 或 #tp <玩家>";  // 静态文本，不够详细
```

### **3. 利用扩展方法简化代码**

✅ **推荐：使用扩展方法**
```csharp
var items = await _blockReader.GetChestItemsAsync(position);

// 链式调用扩展方法
var result = items
    .FilterEnchanted()
    .SortByRarity()
    .Take(10)
    .ToList();

var stats = items.GetStatistics();  // 一行获取统计
```

❌ **不推荐：手动实现**
```csharp
var enchantedItems = new List<ItemStack>();
foreach (var item in items)
{
    if (item.Components?.Contains("enchantments") == true)
        enchantedItems.Add(item);
}

// 手动排序、统计...
```

### **4. 结合调度器实现定时任务**

✅ **推荐：**
```csharp
public class AutoSaveCommand : ICommand
{
    private readonly IScheduler _scheduler;
    
    public async Task<CommandResult> ExecuteAsync(ICommandSender sender, string[] args)
    {
        // 每5分钟自动保存
        _scheduler.ScheduleRepeating(async () =>
        {
            await SaveWorldAsync();
        }, TimeSpan.FromMinutes(5));
        
        return CommandResult.Ok("自动保存已启用");
    }
}
```

### **5. 使用拦截器实现通用功能**

✅ **推荐：** 用拦截器处理横切关注点
```csharp
// 命令日志拦截器（适用于所有命令）
public class CommandLogInterceptor : CommandInterceptorBase
{
    public override async Task<bool> BeforeExecuteAsync(...)
    {
        _logger.Info($"[命令] {sender.Name} 执行 {command.Name}");
        return true;
    }
}

// 注册一次，对所有命令生效
commandManager.RegisterInterceptor(new CommandLogInterceptor(logger));
```

❌ **不推荐：** 在每个命令中重复日志代码
```csharp
public async Task<CommandResult> ExecuteAsync(...)
{
    _logger.Info($"执行命令..."); // 每个命令都要写
    // ...
}
```

### **6. 国际化支持**

✅ **推荐：**
```csharp
public class I18nCommand : ICommand
{
    private readonly II18nService _i18n;
    
    public async Task<CommandResult> ExecuteAsync(ICommandSender sender, string[] args)
    {
        // 自动根据配置切换语言
        var msg = _i18n.Translate("commands.success", sender.Name);
        return CommandResult.Ok(msg);
    }
}
```

### **7. 友好的错误消息**

✅ **推荐：**
```csharp
// 提供具体的错误信息和解决方案
return CommandResult.Fail("§c玩家 'Steve' 不在线\n§7提示: 使用 #list 查看在线玩家");
```

❌ **不推荐：**
```csharp
return CommandResult.Fail("错误");  // 模糊的错误信息
```

### **8. 异步操作**

✅ **推荐：**
```csharp
public async Task<CommandResult> ExecuteAsync(ICommandSender sender, string[] args)
{
    // 正确使用 await
    await _gameUtils.TeleportPlayerAsync(sender.Name, 0, 64, 0);
    await Task.Delay(1000);
    await _gameUtils.SendMessageAsync(sender.Name, "传送完成");
    
    return CommandResult.Ok("操作成功");
}
```

### **9. 控制台兼容性**

✅ **推荐：**
```csharp
public async Task<CommandResult> ExecuteAsync(ICommandSender sender, string[] args)
{
    // 根据发送者类型调整行为
    if (sender.IsConsole)
    {
        _logger.Info("命令执行成功");
    }
    else
    {
        await _gameUtils.SendMessageAsync(sender.Name, "§a命令执行成功");
    }
    
    return CommandResult.Ok();
}
```

### **10. 性能优化建议**

✅ **推荐：**
```csharp
// 缓存会自动管理，但在命令注册/修改后手动清除
public void OnPluginReload()
{
    _tree.ClearCache();  // 清除 Tab 补全缓存
}

// 使用拦截器监控性能
commandManager.RegisterInterceptor(new PerformanceMonitorInterceptor());
```

---

## 📚 **相关文档**

- [权限系统](./权限系统.md)
- [游戏显示 API](../04-高级功能/游戏显示API.md)
- [插件开发指南](../03-插件开发/插件开发指南.md)
- [调度器系统](../04-高级功能/调度器.md) - 定时任务和延迟执行
- [国际化 (i18n)](../04-高级功能/国际化.md) - 多语言支持

