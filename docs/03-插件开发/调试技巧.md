# 插件调试技巧

本文档介绍如何高效地调试 NetherGate 插件，快速定位和解决问题。

---

## 📋 **目录**

- [调试环境配置](#调试环境配置)
- [日志调试](#日志调试)
- [断点调试](#断点调试)
- [常见问题诊断](#常见问题诊断)
- [性能分析](#性能分析)
- [调试工具](#调试工具)

---

## ⚙️ **调试环境配置**

### **1. Visual Studio 配置**

**launch.json:**
```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": ".NET Core Launch (console)",
            "type": "coreclr",
            "request": "launch",
            "preLaunchTask": "build",
            "program": "${workspaceFolder}/../NetherGate/bin/Debug/net9.0/NetherGate.Host.dll",
            "args": [],
            "cwd": "${workspaceFolder}/../NetherGate/bin/Debug/net9.0",
            "console": "internalConsole",
            "stopAtEntry": false
        },
        {
            "name": ".NET Core Attach",
            "type": "coreclr",
            "request": "attach",
            "processId": "${command:pickProcess}"
        }
    ]
}
```

**tasks.json:**
```json
{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "build",
            "command": "dotnet",
            "type": "process",
            "args": [
                "build",
                "${workspaceFolder}/MyPlugin.csproj",
                "/property:GenerateFullPaths=true",
                "/consoleloggerparameters:NoSummary"
            ],
            "problemMatcher": "$msCompile"
        },
        {
            "label": "build-and-copy",
            "dependsOn": ["build"],
            "type": "shell",
            "command": "xcopy",
            "args": [
                "/Y",
                "/E",
                "${workspaceFolder}\\bin\\Debug\\net9.0\\*",
                "${workspaceFolder}\\..\\NetherGate\\bin\\Debug\\plugins\\MyPlugin\\"
            ],
            "problemMatcher": []
        }
    ]
}
```

### **2. Rider 配置**

1. **创建运行配置**
   - Run → Edit Configurations
   - 添加 .NET Project
   - 选择 NetherGate.Host 项目
   - 设置工作目录为 NetherGate bin 目录

2. **配置插件自动复制**
   - Build Events → Post-build event
   - 添加复制命令

### **3. VS Code 配置**

安装扩展：
- C# Dev Kit
- C# 
- .NET Runtime Install Tool

配置同 Visual Studio。

---

## 📝 **日志调试**

### **1. 使用不同日志级别**

```csharp
using NetherGate.API.Plugins;

public class MyPlugin : PluginBase
{
    public override async Task OnEnableAsync()
    {
        // Debug：详细的调试信息（仅在开发环境使用）
        Logger.Debug("插件初始化开始");
        Logger.Debug($"数据目录: {DataDirectory}");
        
        // Info：一般信息（正常运行日志）
        Logger.Info("MyPlugin 已启用");
        Logger.Info($"插件版本: {Metadata.Version}");
        
        // Warning：警告（不影响功能但需要注意）
        Logger.Warning("配置文件使用默认值");
        
        // Error：错误（影响功能，需要处理）
        Logger.Error("数据库连接失败");
    }
}
```

### **2. 结构化日志**

```csharp
// ❌ 不推荐：单行长文本
Logger.Info($"Player {playerName} joined at {position} with {health} health");

// ✅ 推荐：结构化输出
Logger.Info("=== 玩家加入事件 ===");
Logger.Info($"  玩家名称: {playerName}");
Logger.Info($"  UUID: {playerUuid}");
Logger.Info($"  位置: X={position.X:F2}, Y={position.Y:F2}, Z={position.Z:F2}");
Logger.Info($"  维度: {position.Dimension}");
Logger.Info($"  生命值: {health}/20");
Logger.Info("=====================");
```

### **3. 条件日志**

```csharp
// 使用 PluginBase
public class MyPlugin : IPlugin
{
    private bool _debugMode = false;

    public void OnEnable(IPluginContext context)
    {
        // 从配置读取
        _debugMode = config.DebugMode;
        
        if (_debugMode)
        {
            _context.Logger.Info("调试模式已启用");
        }
    }

    private void DebugLog(string message)
    {
        if (_debugMode)
        {
            _context.Logger.Debug($"[DEBUG] {message}");
        }
    }

    private void OnPlayerJoined(PlayerJoinedEvent e)
    {
        DebugLog($"处理玩家加入: {e.Player.Name}");
        
        // 业务逻辑...
        
        DebugLog("玩家加入处理完成");
    }
}
```

### **4. 日志文件分析**

```csharp
public class LogAnalyzer
{
    public void AnalyzeLog(string logPath)
    {
        var lines = File.ReadAllLines(logPath);
        
        var errors = lines.Where(l => l.Contains("[ERROR]")).ToList();
        var warnings = lines.Where(l => l.Contains("[WARNING]")).ToList();
        
        Console.WriteLine($"错误数量: {errors.Count}");
        Console.WriteLine($"警告数量: {warnings.Count}");
        
        // 分析最常见的错误
        var errorGroups = errors
            .GroupBy(e => ExtractErrorMessage(e))
            .OrderByDescending(g => g.Count())
            .Take(10);
        
        Console.WriteLine("\n最常见的错误:");
        foreach (var group in errorGroups)
        {
            Console.WriteLine($"{group.Count()}x: {group.Key}");
        }
    }

    private string ExtractErrorMessage(string logLine)
    {
        // 提取错误消息
        var match = Regex.Match(logLine, @"\[ERROR\]:\s*(.+)");
        return match.Success ? match.Groups[1].Value : logLine;
    }
}
```

---

## 🐛 **断点调试**

### **1. 设置断点**

```csharp
public async void OnPlayerJoined(PlayerJoinedEvent e)
{
    // 在这里设置断点 👇
    var playerName = e.Player.Name;
    
    // 检查玩家数据
    var playerData = await _service.GetPlayerDataAsync(playerName);
    
    // 发送欢迎消息 👇 设置条件断点
    if (playerData.IsNewPlayer)
    {
        await SendWelcomeMessage(playerName);
    }
}
```

### **2. 条件断点**

在 IDE 中右键断点 → 添加条件：

```csharp
// 只在特定玩家时中断
playerName == "Steve"

// 只在满足条件时中断
playerData.Level > 100

// 只在异常时中断
ex != null
```

### **3. 查看变量**

在断点处，查看：
- **局部变量**
- **this (当前对象)**
- **调用堆栈**

### **4. 即时窗口（Immediate Window）**

在调试时执行代码：

```csharp
// 查看变量
? playerName
"Steve"

// 调用方法
? _service.GetBalance(playerName)
100

// 修改变量
playerData.Level = 999
```

---

## 🔍 **常见问题诊断**

### **1. 插件未加载**

**检查清单：**

```csharp
// 1. plugin.json 是否存在？
// 2. entry_point 是否正确？
{
  "entry_point": "MyPlugin.MyPlugin"  // 命名空间.类名
}

// 3. 类是否实现 IPlugin？
public class MyPlugin : IPlugin  // ✅

// 4. 是否有无参构造函数？
public class MyPlugin : IPlugin
{
    // ✅ 默认构造函数
    
    // ❌ 不要只有有参构造函数
    public MyPlugin(string arg) { }
}

// 5. 检查日志
// logs/latest.log 中搜索插件名
```

### **2. 事件未触发**

```csharp
// 问题诊断
public void OnEnable(IPluginContext context)
{
    _context = context;
    
    // ✅ 正确：订阅事件
    _context.EventBus.Subscribe<PlayerJoinedEvent>(OnPlayerJoined);
    _context.Logger.Info("已订阅 PlayerJoinedEvent");
    
    // ❌ 常见错误：忘记订阅
    // 没有 Subscribe 调用
}

private void OnPlayerJoined(PlayerJoinedEvent e)
{
    // 添加日志确认事件触发
    _context.Logger.Info($"[EVENT] PlayerJoinedEvent 触发: {e.Player.Name}");
    
    // 业务逻辑...
}

// 测试方法
public void TestEvent()
{
    // 手动触发测试
    var testEvent = new PlayerJoinedEvent(
        new PlayerInfo { Name = "TestPlayer" },
        "TestPlayer joined"
    );
    
    OnPlayerJoined(testEvent);
}
```

### **3. 命令无响应**

```csharp
public class TestCommand : ICommand
{
    public string Name => "test";
    public string Description => "测试命令";

    public async Task<CommandResult> ExecuteAsync(string[] args, ICommandSender? sender = null)
    {
        // 添加日志
        _context.Logger.Info($"命令执行: sender={sender?.Name ?? "Console"}, args={string.Join(",", args)}");
        
        try
        {
            // 业务逻辑
            return CommandResult.Success("命令执行成功");
        }
        catch (Exception ex)
        {
            _context.Logger.Error($"命令执行失败: {ex.Message}");
            _context.Logger.Error($"堆栈: {ex.StackTrace}");
            return CommandResult.Fail($"错误: {ex.Message}");
        }
    }
}

// 注册检查
public void OnEnable(IPluginContext context)
{
    _context.CommandManager.RegisterCommand(new TestCommand());
    _context.Logger.Info("TestCommand 已注册");
    
    // 验证注册
    var commands = _context.CommandManager.GetRegisteredCommands();
    _context.Logger.Info($"已注册命令: {string.Join(", ", commands)}");
}
```

### **4. 配置加载失败**

```csharp
public async void OnEnable(IPluginContext context)
{
    try
    {
        _context.Logger.Info("开始加载配置");
        
        // 检查配置文件是否存在
        var configPath = Path.Combine(_context.DataDirectory, "config.yaml");
        _context.Logger.Info($"配置文件路径: {configPath}");
        _context.Logger.Info($"文件是否存在: {File.Exists(configPath)}");
        
        // 加载配置
        _config = await _context.ConfigManager.LoadConfigAsync<MyConfig>("config");
        _context.Logger.Info($"配置加载成功: {JsonSerializer.Serialize(_config)}");
    }
    catch (Exception ex)
    {
        _context.Logger.Error($"配置加载失败: {ex.Message}");
        _context.Logger.Error($"异常类型: {ex.GetType().Name}");
        _context.Logger.Error($"堆栈: {ex.StackTrace}");
        
        // 使用默认配置
        _config = new MyConfig();
        _context.Logger.Info("使用默认配置");
    }
}
```

---

## 📊 **性能分析**

### **1. 计时器**

```csharp
public class PerformanceTimer : IDisposable
{
    private readonly string _operationName;
    private readonly ILogger _logger;
    private readonly Stopwatch _stopwatch;
    private readonly int _warningThresholdMs;

    public PerformanceTimer(string operationName, ILogger logger, int warningThresholdMs = 100)
    {
        _operationName = operationName;
        _logger = logger;
        _warningThresholdMs = warningThresholdMs;
        _stopwatch = Stopwatch.StartNew();
        
        _logger.Debug($"[性能] {_operationName} 开始");
    }

    public void Dispose()
    {
        _stopwatch.Stop();
        var elapsed = _stopwatch.ElapsedMilliseconds;
        
        if (elapsed > _warningThresholdMs)
        {
            _logger.Warning($"[性能] {_operationName} 耗时 {elapsed}ms (超过阈值 {_warningThresholdMs}ms)");
        }
        else
        {
            _logger.Debug($"[性能] {_operationName} 耗时 {elapsed}ms");
        }
    }
}

// 使用
public async Task ProcessDataAsync()
{
    using (new PerformanceTimer("处理数据", _context.Logger, 500))
    {
        // 业务逻辑
        await LoadDataAsync();
        await ProcessAsync();
        await SaveAsync();
    }
}
```

### **2. 内存分析**

```csharp
public class MemoryAnalyzer
{
    public void LogMemoryUsage(ILogger logger)
    {
        var before = GC.GetTotalMemory(false);
        
        GC.Collect();
        GC.WaitForPendingFinalizers();
        GC.Collect();
        
        var after = GC.GetTotalMemory(false);
        
        logger.Info($"=== 内存使用 ===");
        logger.Info($"回收前: {before / 1024 / 1024} MB");
        logger.Info($"回收后: {after / 1024 / 1024} MB");
        logger.Info($"回收量: {(before - after) / 1024 / 1024} MB");
        
        // 分代统计
        logger.Info($"Gen 0 回收次数: {GC.CollectionCount(0)}");
        logger.Info($"Gen 1 回收次数: {GC.CollectionCount(1)}");
        logger.Info($"Gen 2 回收次数: {GC.CollectionCount(2)}");
    }
}

// 定期监控
private Timer? _memoryMonitor;

public void OnEnable(IPluginContext context)
{
    _memoryMonitor = new Timer(_ =>
    {
        new MemoryAnalyzer().LogMemoryUsage(_context.Logger);
    }, null, TimeSpan.FromMinutes(5), TimeSpan.FromMinutes(5));
}
```

---

## 🛠️ **调试工具**

### **1. 诊断命令**

```csharp
public class DiagnoseCommand : ICommand
{
    private readonly IPluginContext _context;

    public string Name => "diagnose";
    public string Description => "诊断插件状态";
    public string? Permission => "myplugin.admin";

    public async Task<CommandResult> ExecuteAsync(string[] args, ICommandSender? sender = null)
    {
        var report = new StringBuilder();
        report.AppendLine("=== 插件诊断报告 ===");
        report.AppendLine($"插件版本: {_context.Metadata.Version}");
        report.AppendLine($"启动时间: {_startTime}");
        report.AppendLine($"运行时长: {DateTime.UtcNow - _startTime}");
        
        // 内存
        var memory = GC.GetTotalMemory(false) / 1024 / 1024;
        report.AppendLine($"内存使用: {memory} MB");
        
        // 缓存
        report.AppendLine($"缓存条目: {_cache.Count}");
        
        // 事件订阅
        report.AppendLine($"事件订阅数: {_eventSubscriptions.Count}");
        
        // 性能统计
        report.AppendLine($"总请求数: {_totalRequests}");
        report.AppendLine($"平均响应时间: {_avgResponseTime:F2}ms");
        
        return CommandResult.Success(report.ToString());
    }
}
```

### **2. 单元测试**

```csharp
using Xunit;
using Moq;

public class MyPluginTests
{
    [Fact]
    public async Task TestPlayerJoinedEvent()
    {
        // Arrange
        var mockContext = new Mock<IPluginContext>();
        var mockLogger = new Mock<ILogger>();
        mockContext.Setup(c => c.Logger).Returns(mockLogger.Object);
        
        var plugin = new MyPlugin();
        plugin.OnEnable(mockContext.Object);
        
        // Act
        var testEvent = new PlayerJoinedEvent(
            new PlayerInfo { Name = "TestPlayer" },
            "TestPlayer joined"
        );
        
        // 触发事件处理
        // ...
        
        // Assert
        mockLogger.Verify(l => l.Info(It.IsAny<string>()), Times.AtLeastOnce());
    }
}
```

### **3. 集成测试**

```csharp
public class IntegrationTests
{
    [Fact]
    public async Task TestFullWorkflow()
    {
        // 启动测试环境
        var testEnv = new TestEnvironment();
        await testEnv.StartAsync();
        
        try
        {
            // 加载插件
            await testEnv.LoadPluginAsync("MyPlugin");
            
            // 模拟玩家加入
            await testEnv.SimulatePlayerJoinAsync("TestPlayer");
            
            // 验证结果
            var logs = testEnv.GetLogs();
            Assert.Contains("TestPlayer 加入了服务器", logs);
            
            // 执行命令
            var result = await testEnv.ExecuteCommandAsync("test", "TestPlayer");
            Assert.True(result.Success);
        }
        finally
        {
            await testEnv.StopAsync();
        }
    }
}
```

---

## 💡 **调试技巧总结**

### **快速定位问题**

1. **检查日志** - 90% 的问题都能通过日志找到
2. **添加断点** - 查看运行时状态
3. **逐步执行** - 跟踪代码流程
4. **验证假设** - 使用断言和日志验证

### **提高调试效率**

1. **结构化代码** - 易于调试和测试
2. **添加日志** - 关键路径都要有日志
3. **单元测试** - 及早发现问题
4. **代码审查** - 避免常见错误

### **避免的做法**

- ❌ 删除所有日志（上生产后无法排查）
- ❌ 使用 `try-catch` 吞掉所有异常
- ❌ 不记录异常堆栈
- ❌ 在循环中打印大量日志

---

## 📚 **相关文档**

- [性能优化](../07-示例和最佳实践/性能优化.md)
- [插件开发指南](./插件开发指南.md)
- [FAQ](../08-参考/FAQ.md)

---

**文档维护者：** NetherGate 开发团队  
**最后更新：** 2025-10-05
