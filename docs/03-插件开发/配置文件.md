# 插件配置文件管理

NetherGate 提供了强大的配置文件管理系统，支持 JSON 和 YAML 两种格式，并提供自动序列化、热重载等功能。

---

## 📋 **目录**

- [快速开始](#快速开始)
- [支持的格式](#支持的格式)
- [配置文件操作](#配置文件操作)
- [配置类定义](#配置类定义)
- [高级功能](#高级功能)
- [最佳实践](#最佳实践)

---

## 🚀 **快速开始**

### **1. 定义配置类**

```csharp
public class MyPluginConfig
{
    public string WelcomeMessage { get; set; } = "欢迎加入服务器！";
    public int MaxPlayers { get; set; } = 100;
    public bool EnableFeature { get; set; } = true;
    public List<string> AllowedWorlds { get; set; } = new() { "world", "world_nether" };
}
```

### **2. 加载配置**

```csharp
using NetherGate.API.Plugins;

public class MyPlugin : PluginBase
{
    private MyPluginConfig _config = null!;

    public override async Task OnEnableAsync()
    {
        // 加载配置（使用 Config 属性，自动创建默认配置）
        _config = await Config.LoadAsync<MyPluginConfig>("config");
        
        Logger.Info($"配置已加载: {_config.WelcomeMessage}");
        Logger.Info($"最大玩家数: {_config.MaxPlayers}");
    }

    public override async Task OnDisableAsync()
    {
        // 插件禁用时保存配置
        await Config.SaveAsync("config", _config);
        Logger.Info("配置已保存");
    }
}
```

### **3. 自动生成配置文件**

首次运行后会自动生成 `config/MyPlugin/config.yaml`：

```yaml
welcome_message: "欢迎加入服务器！"
max_players: 100
enable_feature: true
allowed_worlds:
  - "world"
  - "world_nether"
```

---

## 📄 **支持的格式**

### **YAML（推荐）**

**优点：**
- ✅ 可读性强
- ✅ 支持注释
- ✅ 层级结构清晰

**示例：**
```yaml
# 这是注释
server:
  name: "我的服务器"
  port: 25565
  
features:
  pvp: true
  mobspawn: false
```

### **JSON**

**优点：**
- ✅ 广泛支持
- ✅ 严格的语法

**示例：**
```json
{
  "server": {
    "name": "我的服务器",
    "port": 25565
  },
  "features": {
    "pvp": true,
    "mobspawn": false
  }
}
```

### **格式选择**

NetherGate 根据文件扩展名自动识别格式：

```csharp
// 使用 PluginBase 的 Config 属性

// YAML（推荐）
var config = await Config.LoadAsync<MyConfig>("config.yaml");

// JSON
var config = await Config.LoadAsync<MyConfig>("config.json");

// 自动选择（优先 YAML）
var config = await Config.LoadAsync<MyConfig>("config");
// 会自动查找 config.yaml，如果不存在则查找 config.json
```

---

## 🔧 **配置文件操作**

### **IConfigManager 接口**

```csharp
namespace NetherGate.API.Plugins
{
    /// <summary>
    /// 配置管理器接口
    /// </summary>
    public interface IConfigManager
    {
        /// <summary>
        /// 加载配置文件
        /// 如果文件不存在，创建默认配置
        /// </summary>
        Task<T> LoadAsync<T>(string fileName) where T : class, new();
        
        /// <summary>
        /// 保存配置文件
        /// </summary>
        Task SaveAsync<T>(string fileName, T config) where T : class;
        
        /// <summary>
        /// 重新加载配置文件
    /// </summary>
    Task<T> ReloadConfigAsync<T>(string fileName) where T : class, new();
    
    /// <summary>
    /// 检查配置文件是否存在
    /// </summary>
    bool ConfigExists(string fileName);
    
    /// <summary>
    /// 删除配置文件
    /// </summary>
    Task DeleteConfigAsync(string fileName);
}
```

### **基本操作**

#### **加载配置**

```csharp
// 使用 PluginBase 的 Config 属性

// 加载配置（不存在则创建）
var config = await Config.LoadAsync<MyConfig>("config");
Logger.Info("配置加载完成");

// 加载特定格式
var yamlConfig = await Config.LoadAsync<MyConfig>("config.yaml");
var jsonConfig = await Config.LoadAsync<MyConfig>("settings.json");
```

#### **保存配置**

```csharp
// 修改配置
_config.MaxPlayers = 200;
_config.WelcomeMessage = "新的欢迎消息";

// 保存配置
await Config.SaveAsync("config", _config);
Logger.Info("配置已保存");
```

#### **重新加载配置**

```csharp
// 从文件重新加载（丢弃内存中的修改）
_config = await Config.ReloadAsync<MyConfig>("config");
Logger.Info("配置已重新加载");
```

#### **检查和删除**

```csharp
// 检查文件是否存在
if (Config.Exists("config"))
{
    Logger.Info("配置文件存在");
}
else
{
    Logger.Warning("配置文件不存在，将创建默认配置");
}

// 删除配置文件（谨慎使用）
await Config.DeleteAsync("old_config");
Logger.Info("已删除旧配置文件");
```

---

## 📝 **配置类定义**

### **基本类型**

```csharp
public class BasicConfig
{
    // 基本类型
    public string Name { get; set; } = "Default";
    public int Number { get; set; } = 100;
    public double Decimal { get; set; } = 1.5;
    public bool Flag { get; set; } = true;
    
    // 集合类型
    public List<string> Items { get; set; } = new();
    public Dictionary<string, int> Scores { get; set; } = new();
    
    // 枚举
    public GameMode Mode { get; set; } = GameMode.Survival;
}

public enum GameMode
{
    Survival,
    Creative,
    Adventure,
    Spectator
}
```

### **嵌套配置**

```csharp
public class ServerConfig
{
    public string Name { get; set; } = "My Server";
    public NetworkSettings Network { get; set; } = new();
    public List<WorldSettings> Worlds { get; set; } = new();
}

public class NetworkSettings
{
    public string Host { get; set; } = "0.0.0.0";
    public int Port { get; set; } = 25565;
    public int MaxConnections { get; set; } = 100;
}

public class WorldSettings
{
    public string Name { get; set; } = string.Empty;
    public string Seed { get; set; } = string.Empty;
    public Difficulty Difficulty { get; set; } = Difficulty.Normal;
}
```

生成的 YAML：

```yaml
name: "My Server"
network:
  host: "0.0.0.0"
  port: 25565
  max_connections: 100
worlds:
  - name: "world"
    seed: "12345"
    difficulty: Normal
  - name: "world_nether"
    seed: "67890"
    difficulty: Hard
```

### **可选字段**

```csharp
public class OptionalConfig
{
    // 可为 null 的字段
    public string? OptionalName { get; set; }
    public int? OptionalNumber { get; set; }
    
    // 使用默认值
    public string RequiredName { get; set; } = "Default";
}
```

---

## 🚀 **高级功能**

### **1. 配置验证**

```csharp
public class ValidatedConfig
{
    private int _maxPlayers = 100;
    
    public int MaxPlayers
    {
        get => _maxPlayers;
        set
        {
            if (value < 1 || value > 1000)
                throw new ArgumentException("MaxPlayers 必须在 1-1000 之间");
            _maxPlayers = value;
        }
    }
    
    public void Validate()
    {
        if (string.IsNullOrEmpty(ServerName))
            throw new InvalidOperationException("ServerName 不能为空");
        
        if (Port < 1024 || Port > 65535)
            throw new InvalidOperationException("Port 必须在 1024-65535 之间");
    }
    
    public string ServerName { get; set; } = "Server";
    public int Port { get; set; } = 25565;
}

// 使用
var config = await _context.ConfigManager.LoadConfigAsync<ValidatedConfig>("config");
try
{
    config.Validate();
}
catch (Exception ex)
{
    _context.Logger.Error($"配置验证失败: {ex.Message}");
}
```

### **2. 配置迁移**

```csharp
public class ConfigMigration
{
    public static MyConfigV2 MigrateFrom(MyConfigV1 oldConfig)
    {
        return new MyConfigV2
        {
            // 保留旧字段
            Name = oldConfig.Name,
            
            // 转换字段
            MaxConnections = oldConfig.MaxPlayers,
            
            // 添加新字段（使用默认值）
            EnableNewFeature = true
        };
    }
}

// 使用
if (_context.ConfigManager.ConfigExists("config_v1"))
{
    var oldConfig = await _context.ConfigManager.LoadConfigAsync<MyConfigV1>("config_v1");
    var newConfig = ConfigMigration.MigrateFrom(oldConfig);
    await _context.ConfigManager.SaveConfigAsync("config", newConfig);
    await _context.ConfigManager.DeleteConfigAsync("config_v1");
}
```

### **3. 多配置文件**

```csharp
using NetherGate.API.Plugins;

public class MyPlugin : PluginBase
{
    private MainConfig _mainConfig = null!;
    private DatabaseConfig _dbConfig = null!;
    private FeatureConfig _featureConfig = null!;

    public override async Task OnEnableAsync()
    {
        // 加载多个配置文件
        _mainConfig = await Config.LoadAsync<MainConfig>("config");
        _dbConfig = await Config.LoadAsync<DatabaseConfig>("database");
        _featureConfig = await Config.LoadAsync<FeatureConfig>("features");
        
        Logger.Info("所有配置文件已加载");
    }
}
```

目录结构：
```
config/MyPlugin/
├── config.yaml
├── database.yaml
└── features.yaml
```

### **4. 配置热重载**

```csharp
public class MyPlugin : IPlugin
{
    private MyConfig _config;
    private FileSystemWatcher _watcher;

    public async void OnEnable(IPluginContext context)
    {
        _config = await context.ConfigManager.LoadConfigAsync<MyConfig>("config");
        
        // 监听配置文件变化
        var configPath = Path.Combine(context.DataDirectory, "config.yaml");
        _watcher = new FileSystemWatcher(Path.GetDirectoryName(configPath))
        {
            Filter = Path.GetFileName(configPath),
            NotifyFilter = NotifyFilters.LastWrite
        };
        
        _watcher.Changed += async (s, e) =>
        {
            await Task.Delay(100); // 等待文件写入完成
            _config = await context.ConfigManager.ReloadConfigAsync<MyConfig>("config");
            context.Logger.Info("配置已重新加载");
            OnConfigReloaded();
        };
        
        _watcher.EnableRaisingEvents = true;
    }

    private void OnConfigReloaded()
    {
        // 应用新配置
        _context.Logger.Info($"新的最大玩家数: {_config.MaxPlayers}");
    }

    public void OnDisable()
    {
        _watcher?.Dispose();
    }
}
```

### **5. 加密敏感配置**

```csharp
public class SecureConfig
{
    public string DatabasePassword { get; set; } = "";
    public string ApiKey { get; set; } = "";
}

// 保存前加密
public async Task SaveSecureConfigAsync(SecureConfig config)
{
    var encrypted = new SecureConfig
    {
        DatabasePassword = Encrypt(config.DatabasePassword),
        ApiKey = Encrypt(config.ApiKey)
    };
    
    await _context.ConfigManager.SaveConfigAsync("secure", encrypted);
}

// 加载后解密
public async Task<SecureConfig> LoadSecureConfigAsync()
{
    var encrypted = await _context.ConfigManager.LoadConfigAsync<SecureConfig>("secure");
    
    return new SecureConfig
    {
        DatabasePassword = Decrypt(encrypted.DatabasePassword),
        ApiKey = Decrypt(encrypted.ApiKey)
    };
}

private string Encrypt(string text)
{
    // 使用 AES 或其他加密算法
    // 详细实现略
    return Convert.ToBase64String(/* encrypted bytes */);
}

private string Decrypt(string encrypted)
{
    // 解密
    return /* decrypted text */;
}
```

---

## 💡 **最佳实践**

### **1. 使用有意义的默认值**

✅ **推荐：**
```csharp
public class Config
{
    public string ServerName { get; set; } = "My Minecraft Server";
    public int MaxPlayers { get; set; } = 20;
    public bool EnablePvP { get; set; } = true;
}
```

❌ **不推荐：**
```csharp
public class Config
{
    public string ServerName { get; set; } = "";  // 空值不友好
    public int MaxPlayers { get; set; } = 0;      // 无意义的默认值
}
```

### **2. 分组相关配置**

✅ **推荐：**
```csharp
public class Config
{
    public ServerSettings Server { get; set; } = new();
    public FeatureToggles Features { get; set; } = new();
    public MessagesConfig Messages { get; set; } = new();
}
```

❌ **不推荐：**
```csharp
public class Config
{
    public string ServerName { get; set; }
    public bool FeatureA { get; set; }
    public string MessageA { get; set; }
    public int ServerPort { get; set; }
    public bool FeatureB { get; set; }
    // 杂乱无章
}
```

### **3. 添加注释（YAML）**

```csharp
// 在保存时手动添加注释
var yaml = @"# 服务器配置
# 修改后需要重启

server_name: ""My Server""  # 服务器名称
max_players: 20             # 最大玩家数（1-100）
";
```

### **4. 版本化配置**

```csharp
public class Config
{
    public int ConfigVersion { get; set; } = 2;  // 配置版本号
    
    // 其他配置...
}

// 加载时检查版本
var config = await _context.ConfigManager.LoadConfigAsync<Config>("config");
if (config.ConfigVersion < 2)
{
    // 执行迁移
    config = MigrateToV2(config);
    config.ConfigVersion = 2;
    await _context.ConfigManager.SaveConfigAsync("config", config);
}
```

### **5. 配置备份**

```csharp
// 在保存前备份
public async Task SaveConfigWithBackupAsync(MyConfig config)
{
    var configPath = Path.Combine(_context.DataDirectory, "config.yaml");
    
    if (File.Exists(configPath))
    {
        var backupPath = Path.Combine(
            _context.DataDirectory, 
            $"config.yaml.backup.{DateTime.Now:yyyyMMdd_HHmmss}"
        );
        File.Copy(configPath, backupPath);
    }
    
    await _context.ConfigManager.SaveConfigAsync("config", config);
}
```

---

## 🐛 **常见问题**

### **Q: 配置文件在哪里？**

**A:** 配置文件位于 `config/<PluginName>/` 目录。

例如：
```
config/
├── MyPlugin/
│   ├── config.yaml
│   └── database.yaml
└── AnotherPlugin/
    └── config.yaml
```

### **Q: 如何处理配置错误？**

**A:** 使用 try-catch 处理：

```csharp
try
{
    _config = await _context.ConfigManager.LoadConfigAsync<MyConfig>("config");
    _config.Validate();
}
catch (Exception ex)
{
    _context.Logger.Error($"配置加载失败: {ex.Message}");
    _config = new MyConfig(); // 使用默认配置
}
```

### **Q: YAML 和 JSON 可以混用吗？**

**A:** 可以，但不推荐。建议统一使用 YAML。

```csharp
var config1 = await _context.ConfigManager.LoadConfigAsync<Config>("config.yaml");
var config2 = await _context.ConfigManager.LoadConfigAsync<Config>("other.json");
```

---

## 📚 **相关文档**

- [插件开发指南](./插件开发指南.md)
- [API 参考](./API参考.md)
- [配置文件详解](../05-配置和部署/配置文件详解.md)

---

**文档维护者：** NetherGate 开发团队  
**最后更新：** 2025-10-05
