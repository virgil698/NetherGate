# NetherGate è‡ªå®šä¹‰æœåŠ¡ç«¯å¤„ç†å™¨æŒ‡å—

æœ¬æŒ‡å—ä»‹ç»å¦‚ä½•åœ¨ NetherGate æ’ä»¶ä¸­åˆ›å»ºå’Œä½¿ç”¨è‡ªå®šä¹‰æœåŠ¡ç«¯å¤„ç†å™¨ï¼Œç”¨äºå¤„ç† Minecraft æœåŠ¡å™¨çš„è¾“å‡ºå’Œæ¶ˆæ¯ã€‚

---

## ğŸ“‹ ç›®å½•

- [æ¦‚è¿°](#æ¦‚è¿°)
- [å¤„ç†å™¨ç±»å‹](#å¤„ç†å™¨ç±»å‹)
- [IServerOutputHandler - è¾“å‡ºå¤„ç†å™¨](#iserveroutputhandler---è¾“å‡ºå¤„ç†å™¨)
- [IServerMessageProcessor - æ¶ˆæ¯å¤„ç†å™¨](#iserveroutputhandler---æ¶ˆæ¯å¤„ç†å™¨)
- [æ³¨å†Œå’Œç®¡ç†](#æ³¨å†Œå’Œç®¡ç†)
- [å®Œæ•´ç¤ºä¾‹](#å®Œæ•´ç¤ºä¾‹)
- [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
- [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)

---

## æ¦‚è¿°

NetherGate æä¾›äº†å¼ºå¤§çš„æœåŠ¡ç«¯å¤„ç†å™¨ç³»ç»Ÿï¼Œå…è®¸æ’ä»¶è‡ªå®šä¹‰å¤„ç†æœåŠ¡å™¨çš„å„ç§è¾“å‡ºå’Œæ¶ˆæ¯ã€‚

### å¤„ç†å™¨æ¶æ„

```
Minecraft Server
   â†“ (stdout/stderr)
ServerProcessManager
   â†“
LogParser (è§£ææ—¥å¿—æ ¼å¼)
   â†“ â†“ â†“
   â”œâ”€â†’ IServerOutputHandler (åŸå§‹è¾“å‡ºå¤„ç†)
   â”‚     â”œâ”€ CrashDetectionHandler
   â”‚     â”œâ”€ PerformanceMonitorHandler
   â”‚     â””â”€ CustomPluginHandler
   â”‚
   â”œâ”€â†’ ILogMatcher (æ—¥å¿—åŒ¹é… â†’ äº‹ä»¶)
   â”‚     â”œâ”€ PlayerJoinMatcher
   â”‚     â”œâ”€ ServerReadyMatcher
   â”‚     â””â”€ CustomEventMatcher
   â”‚
   â””â”€â†’ IServerMessageProcessor (æ¶ˆæ¯å¤„ç†)
         â”œâ”€ StatisticsProcessor
         â”œâ”€ AlertProcessor
         â””â”€ CustomProcessor
```

### åº”ç”¨åœºæ™¯

- **å®æ—¶ç›‘æ§**: æœåŠ¡å™¨å´©æºƒæ£€æµ‹ã€æ€§èƒ½è­¦å‘Š
- **æ•°æ®æ”¶é›†**: ç»Ÿè®¡æ•°æ®ã€ç©å®¶è¡Œä¸ºåˆ†æ
- **è‡ªåŠ¨åŒ–**: è‡ªåŠ¨å¤‡ä»½ã€è‡ªåŠ¨é‡å¯ã€è‡ªåŠ¨é€šçŸ¥
- **è°ƒè¯•**: æ—¥å¿—è¿‡æ»¤ã€é”™è¯¯è¿½è¸ª
- **é›†æˆ**: Webhook é€šçŸ¥ã€Discord Botã€ç›‘æ§é¢æ¿

---

## å¤„ç†å™¨ç±»å‹

NetherGate æä¾›ä¸¤ç§ä¸»è¦çš„å¤„ç†å™¨æ¥å£ï¼š

| å¤„ç†å™¨ç±»å‹ | ç”¨é€” | æ‰§è¡Œæ—¶æœº | é€‚ç”¨åœºæ™¯ |
|-----------|------|---------|---------|
| **IServerOutputHandler** | å¤„ç†æœåŠ¡å™¨åŸå§‹è¾“å‡º | å®æ—¶ï¼ˆæ¯è¡Œè¾“å‡ºï¼‰ | å®æ—¶ç›‘æ§ã€å´©æºƒæ£€æµ‹ã€æ€§èƒ½åˆ†æ |
| **IServerMessageProcessor** | å¤„ç†ç»“æ„åŒ–æ¶ˆæ¯ | å¼‚æ­¥ï¼ˆæ‰¹é‡/å•æ¡ï¼‰ | æ•°æ®åˆ†æã€ç»Ÿè®¡æ”¶é›†ã€é€šçŸ¥æ¨é€ |

---

## IServerOutputHandler - è¾“å‡ºå¤„ç†å™¨

### æ¥å£å®šä¹‰

```csharp
public interface IServerOutputHandler
{
    /// <summary>å¤„ç†å™¨åç§°</summary>
    string Name { get; }
    
    /// <summary>ä¼˜å…ˆçº§ï¼ˆæ•°å€¼è¶Šå¤§è¶Šå…ˆæ‰§è¡Œï¼‰</summary>
    int Priority { get; }
    
    /// <summary>å¤„ç†æœåŠ¡å™¨è¾“å‡º</summary>
    Task<HandlerResult> HandleAsync(ServerOutputContext context);
    
    /// <summary>å¿«é€Ÿè¿‡æ»¤ï¼ˆå¯é€‰ï¼‰</summary>
    bool ShouldHandle(string line) => true;
}
```

### ä¼˜å…ˆçº§å»ºè®®

```csharp
// ä¼˜å…ˆçº§èŒƒå›´
100+    // ç´§æ€¥å¤„ç†ï¼ˆæœåŠ¡å™¨å´©æºƒã€ä¸¥é‡é”™è¯¯ï¼‰
50-99   // é«˜ä¼˜å…ˆçº§ï¼ˆç©å®¶äº‹ä»¶ã€é‡è¦æ—¥å¿—ï¼‰
10-49   // æ™®é€šä¼˜å…ˆçº§ï¼ˆç»Ÿè®¡æ”¶é›†ã€ä¸€èˆ¬ç›‘æ§ï¼‰
0-9     // ä½ä¼˜å…ˆçº§ï¼ˆè°ƒè¯•ä¿¡æ¯ã€è¯¦ç»†æ—¥å¿—ï¼‰
```

### åŸºç¡€ç¤ºä¾‹

```csharp
using NetherGate.API.Plugins;
using System.Text.RegularExpressions;

/// <summary>
/// æœåŠ¡å™¨å´©æºƒæ£€æµ‹å¤„ç†å™¨
/// </summary>
public class CrashDetectionHandler : ServerOutputHandlerBase
{
    private readonly ILogger _logger;
    private static readonly Regex CrashPattern = new(
        @"(exception|error|crash|fatal|OutOfMemoryError)",
        RegexOptions.IgnoreCase | RegexOptions.Compiled);

    public override string Name => "CrashDetector";
    public override int Priority => 100; // æœ€é«˜ä¼˜å…ˆçº§

    public CrashDetectionHandler(ILogger logger)
    {
        _logger = logger;
    }

    public override bool ShouldHandle(string line)
    {
        // å¿«é€Ÿè¿‡æ»¤ï¼šåªå¤„ç†åŒ…å«å…³é”®è¯çš„è¡Œ
        return CrashPattern.IsMatch(line);
    }

    public override async Task<HandlerResult> HandleAsync(ServerOutputContext context)
    {
        if (context.Level == "ERROR" || context.Level == "FATAL")
        {
            _logger.Error($"æ£€æµ‹åˆ°æœåŠ¡å™¨é”™è¯¯: {context.Message}");

            // æ£€æŸ¥æ˜¯å¦ä¸ºå†…å­˜æº¢å‡º
            if (context.Message.Contains("OutOfMemoryError", StringComparison.OrdinalIgnoreCase))
            {
                _logger.Fatal("æœåŠ¡å™¨å†…å­˜æº¢å‡ºï¼å‡†å¤‡æ‰§è¡Œç´§æ€¥å¤‡ä»½...");
                await PerformEmergencyBackup();
                
                // åœæ­¢åç»­å¤„ç†ï¼ˆæ‹¦æˆªæ¨¡å¼ï¼‰
                return HandlerResult.OkAndStop("å·²æ‹¦æˆªå¹¶å¤„ç†å†…å­˜æº¢å‡ºé”™è¯¯");
            }

            // æ ‡è®°ä¸ºå·²å¤„ç†ï¼Œä½†ç»§ç»­æ‰§è¡Œåç»­å¤„ç†å™¨
            context.IsHandled = true;
            return HandlerResult.Ok("é”™è¯¯å·²è®°å½•");
        }

        return HandlerResult.Skip();
    }

    private async Task PerformEmergencyBackup()
    {
        // ç´§æ€¥å¤‡ä»½é€»è¾‘
        _logger.Info("æ‰§è¡Œç´§æ€¥å¤‡ä»½...");
        await Task.Delay(100); // å®é™…å¤‡ä»½æ“ä½œ
    }
}
```

### é«˜çº§ç¤ºä¾‹ï¼šæ€§èƒ½ç›‘æ§

```csharp
/// <summary>
/// æœåŠ¡å™¨æ€§èƒ½ç›‘æ§å¤„ç†å™¨
/// </summary>
public class PerformanceMonitorHandler : ServerOutputHandlerBase
{
    private readonly ILogger _logger;
    private readonly Queue<PerformanceData> _performanceHistory = new();
    private static readonly Regex TpsPattern = new(
        @"TPS from last 1m, 5m, 15m: ([\d.]+), ([\d.]+), ([\d.]+)",
        RegexOptions.Compiled);

    public override string Name => "PerformanceMonitor";
    public override int Priority => 60;

    public PerformanceMonitorHandler(ILogger logger)
    {
        _logger = logger;
    }

    public override bool ShouldHandle(string line)
    {
        return line.Contains("TPS", StringComparison.OrdinalIgnoreCase)
            || line.Contains("lag", StringComparison.OrdinalIgnoreCase)
            || line.Contains("Can't keep up", StringComparison.OrdinalIgnoreCase);
    }

    public override async Task<HandlerResult> HandleAsync(ServerOutputContext context)
    {
        // æ£€æµ‹ TPS ä¿¡æ¯
        var match = TpsPattern.Match(context.Message);
        if (match.Success)
        {
            var tps1m = double.Parse(match.Groups[1].Value);
            var tps5m = double.Parse(match.Groups[2].Value);
            var tps15m = double.Parse(match.Groups[3].Value);

            var data = new PerformanceData
            {
                Timestamp = DateTime.UtcNow,
                Tps1Min = tps1m,
                Tps5Min = tps5m,
                Tps15Min = tps15m
            };

            _performanceHistory.Enqueue(data);
            if (_performanceHistory.Count > 60) // ä¿ç•™æœ€è¿‘ 60 æ¡
                _performanceHistory.Dequeue();

            // æ£€æµ‹æ€§èƒ½é—®é¢˜
            if (tps1m < 15.0)
            {
                _logger.Warning($"æœåŠ¡å™¨ TPS è¿‡ä½: {tps1m:F1} (1åˆ†é’Ÿå¹³å‡)");
                await SendPerformanceAlert(data);
            }

            // å­˜å‚¨åˆ°å…±äº«æ•°æ®ï¼Œä¾›å…¶ä»–å¤„ç†å™¨ä½¿ç”¨
            context.SharedData["LatestTPS"] = data;

            return HandlerResult.Ok("æ€§èƒ½æ•°æ®å·²è®°å½•");
        }

        // æ£€æµ‹ "Can't keep up" è­¦å‘Š
        if (context.Message.Contains("Can't keep up", StringComparison.OrdinalIgnoreCase))
        {
            _logger.Warning("æœåŠ¡å™¨å‡ºç°å¡é¡¿: " + context.Message);
            context.IsHandled = true;
            return HandlerResult.Ok("å¡é¡¿è­¦å‘Šå·²è®°å½•");
        }

        return HandlerResult.Skip();
    }

    private async Task SendPerformanceAlert(PerformanceData data)
    {
        // å‘é€æ€§èƒ½è­¦å‘Šï¼ˆDiscordã€WebSocket ç­‰ï¼‰
        _logger.Info($"å‘é€æ€§èƒ½è­¦å‘Š: TPS={data.Tps1Min:F1}");
        await Task.CompletedTask;
    }

    private class PerformanceData
    {
        public DateTime Timestamp { get; init; }
        public double Tps1Min { get; init; }
        public double Tps5Min { get; init; }
        public double Tps15Min { get; init; }
    }
}
```

---

## IServerMessageProcessor - æ¶ˆæ¯å¤„ç†å™¨

æ¶ˆæ¯å¤„ç†å™¨æä¾›æ›´é«˜çº§çš„åŠŸèƒ½ï¼ŒåŒ…æ‹¬å¼‚æ­¥å¤„ç†ã€æ‰¹é‡å¤„ç†å’Œç”Ÿå‘½å‘¨æœŸç®¡ç†ã€‚

### æ¥å£å®šä¹‰

```csharp
public interface IServerMessageProcessor
{
    string Name { get; }
    int Priority { get; }
    
    Task InitializeAsync();
    Task ProcessMessageAsync(ServerMessage message);
    Task ProcessBatchAsync(IReadOnlyList<ServerMessage> messages);
    Task ShutdownAsync();
    bool ShouldProcess(ServerMessage message);
}
```

### åŸºç¡€ç¤ºä¾‹ï¼šç»Ÿè®¡æ”¶é›†å™¨

```csharp
/// <summary>
/// ç©å®¶æ´»åŠ¨ç»Ÿè®¡å¤„ç†å™¨
/// </summary>
public class PlayerActivityProcessor : ServerMessageProcessorBase
{
    private readonly ILogger _logger;
    private readonly Dictionary<string, PlayerStats> _playerStats = new();
    private readonly Timer _saveTimer;

    public override string Name => "PlayerActivityCollector";
    public override int Priority => 30;

    public PlayerActivityProcessor(ILogger logger)
    {
        _logger = logger;
        _saveTimer = new Timer(SaveStatistics, null, Timeout.Infinite, Timeout.Infinite);
    }

    public override Task InitializeAsync()
    {
        _logger.Info("åˆå§‹åŒ–ç©å®¶æ´»åŠ¨ç»Ÿè®¡å¤„ç†å™¨...");
        LoadStatistics();
        
        // æ¯ 5 åˆ†é’Ÿä¿å­˜ä¸€æ¬¡ç»Ÿè®¡
        _saveTimer.Change(TimeSpan.FromMinutes(5), TimeSpan.FromMinutes(5));
        
        return Task.CompletedTask;
    }

    public override bool ShouldProcess(ServerMessage message)
    {
        return message.Type == ServerMessageType.PlayerJoin
            || message.Type == ServerMessageType.PlayerLeave
            || message.Type == ServerMessageType.PlayerChat
            || message.Type == ServerMessageType.PlayerCommand;
    }

    public override async Task ProcessMessageAsync(ServerMessage message)
    {
        switch (message.Type)
        {
            case ServerMessageType.PlayerJoin:
                if (message.Metadata.TryGetValue("PlayerName", out var joinName))
                {
                    RecordPlayerJoin((string)joinName);
                }
                break;

            case ServerMessageType.PlayerLeave:
                if (message.Metadata.TryGetValue("PlayerName", out var leaveName))
                {
                    RecordPlayerLeave((string)leaveName);
                }
                break;

            case ServerMessageType.PlayerChat:
                if (message.Metadata.TryGetValue("PlayerName", out var chatName))
                {
                    RecordPlayerActivity((string)chatName, PlayerActivity.Chat);
                }
                break;

            case ServerMessageType.PlayerCommand:
                if (message.Metadata.TryGetValue("PlayerName", out var cmdName))
                {
                    RecordPlayerActivity((string)cmdName, PlayerActivity.Command);
                }
                break;
        }

        await Task.CompletedTask;
    }

    public override Task ShutdownAsync()
    {
        _logger.Info("å…³é—­ç©å®¶æ´»åŠ¨ç»Ÿè®¡å¤„ç†å™¨...");
        _saveTimer.Dispose();
        SaveStatistics(null);
        return Task.CompletedTask;
    }

    private void RecordPlayerJoin(string playerName)
    {
        if (!_playerStats.ContainsKey(playerName))
        {
            _playerStats[playerName] = new PlayerStats { PlayerName = playerName };
        }

        _playerStats[playerName].TotalJoins++;
        _playerStats[playerName].LastSeen = DateTime.UtcNow;
        _logger.Debug($"è®°å½•ç©å®¶åŠ å…¥: {playerName}");
    }

    private void RecordPlayerLeave(string playerName)
    {
        if (_playerStats.ContainsKey(playerName))
        {
            _playerStats[playerName].LastSeen = DateTime.UtcNow;
        }
    }

    private void RecordPlayerActivity(string playerName, PlayerActivity activity)
    {
        if (!_playerStats.ContainsKey(playerName))
        {
            _playerStats[playerName] = new PlayerStats { PlayerName = playerName };
        }

        switch (activity)
        {
            case PlayerActivity.Chat:
                _playerStats[playerName].TotalChats++;
                break;
            case PlayerActivity.Command:
                _playerStats[playerName].TotalCommands++;
                break;
        }

        _playerStats[playerName].LastSeen = DateTime.UtcNow;
    }

    private void LoadStatistics()
    {
        // ä»æ–‡ä»¶åŠ è½½ç»Ÿè®¡æ•°æ®
        _logger.Debug("åŠ è½½ç»Ÿè®¡æ•°æ®...");
    }

    private void SaveStatistics(object? state)
    {
        // ä¿å­˜ç»Ÿè®¡æ•°æ®åˆ°æ–‡ä»¶
        _logger.Info($"ä¿å­˜ç»Ÿè®¡æ•°æ®: {_playerStats.Count} ä¸ªç©å®¶");
    }

    private class PlayerStats
    {
        public string PlayerName { get; init; } = string.Empty;
        public int TotalJoins { get; set; }
        public int TotalChats { get; set; }
        public int TotalCommands { get; set; }
        public DateTime LastSeen { get; set; }
    }

    private enum PlayerActivity
    {
        Chat,
        Command
    }
}
```

### é«˜çº§ç¤ºä¾‹ï¼šæ‰¹é‡å¤„ç†

```csharp
/// <summary>
/// æ‰¹é‡æ—¥å¿—åˆ†æå¤„ç†å™¨
/// </summary>
public class BatchLogAnalyzer : ServerMessageProcessorBase
{
    private readonly ILogger _logger;
    private readonly ConcurrentQueue<ServerMessage> _messageQueue = new();
    private readonly Timer _batchTimer;
    private const int BatchSize = 50;

    public override string Name => "BatchLogAnalyzer";
    public override int Priority => 20;

    public BatchLogAnalyzer(ILogger logger)
    {
        _logger = logger;
        _batchTimer = new Timer(ProcessBatchQueue, null, Timeout.Infinite, Timeout.Infinite);
    }

    public override Task InitializeAsync()
    {
        _logger.Info("åˆå§‹åŒ–æ‰¹é‡æ—¥å¿—åˆ†æå™¨...");
        
        // æ¯ 10 ç§’å¤„ç†ä¸€æ¬¡æ‰¹é‡æ¶ˆæ¯
        _batchTimer.Change(TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(10));
        
        return Task.CompletedTask;
    }

    public override bool ShouldProcess(ServerMessage message)
    {
        // å¤„ç†æ‰€æœ‰æ¶ˆæ¯
        return true;
    }

    public override async Task ProcessMessageAsync(ServerMessage message)
    {
        // å°†æ¶ˆæ¯åŠ å…¥é˜Ÿåˆ—ï¼Œç­‰å¾…æ‰¹é‡å¤„ç†
        _messageQueue.Enqueue(message);

        // å¦‚æœé˜Ÿåˆ—è¾¾åˆ°æ‰¹é‡å¤§å°ï¼Œç«‹å³å¤„ç†
        if (_messageQueue.Count >= BatchSize)
        {
            await ProcessBatchQueue(null);
        }
    }

    public override async Task ProcessBatchAsync(IReadOnlyList<ServerMessage> messages)
    {
        if (messages.Count == 0)
            return;

        _logger.Debug($"æ‰¹é‡å¤„ç† {messages.Count} æ¡æ¶ˆæ¯");

        // æŒ‰æ¶ˆæ¯ç±»å‹åˆ†ç»„
        var grouped = messages.GroupBy(m => m.Type);

        foreach (var group in grouped)
        {
            var count = group.Count();
            _logger.Info($"æ¶ˆæ¯ç±»å‹ {group.Key}: {count} æ¡");

            // æ ¹æ®æ¶ˆæ¯ç±»å‹æ‰§è¡Œä¸åŒçš„åˆ†æ
            await AnalyzeMessageGroup(group.Key, group.ToList());
        }
    }

    public override Task ShutdownAsync()
    {
        _logger.Info("å…³é—­æ‰¹é‡æ—¥å¿—åˆ†æå™¨...");
        _batchTimer.Dispose();
        
        // å¤„ç†å‰©ä½™æ¶ˆæ¯
        if (_messageQueue.Count > 0)
        {
            _ = ProcessBatchQueue(null);
        }
        
        return Task.CompletedTask;
    }

    private async Task ProcessBatchQueue(object? state)
    {
        var batch = new List<ServerMessage>();

        // å–å‡ºé˜Ÿåˆ—ä¸­çš„æ¶ˆæ¯
        while (_messageQueue.TryDequeue(out var message) && batch.Count < BatchSize)
        {
            batch.Add(message);
        }

        if (batch.Count > 0)
        {
            await ProcessBatchAsync(batch);
        }
    }

    private async Task AnalyzeMessageGroup(ServerMessageType type, List<ServerMessage> messages)
    {
        // é’ˆå¯¹ä¸åŒæ¶ˆæ¯ç±»å‹çš„åˆ†æé€»è¾‘
        switch (type)
        {
            case ServerMessageType.PlayerChat:
                await AnalyzeChatMessages(messages);
                break;

            case ServerMessageType.Error:
                await AnalyzeErrors(messages);
                break;

            default:
                _logger.Trace($"è·³è¿‡æ¶ˆæ¯ç±»å‹: {type}");
                break;
        }
    }

    private async Task AnalyzeChatMessages(List<ServerMessage> messages)
    {
        // èŠå¤©æ¶ˆæ¯åˆ†æï¼ˆæ•æ„Ÿè¯æ£€æµ‹ã€åƒåœ¾ä¿¡æ¯è¿‡æ»¤ç­‰ï¼‰
        _logger.Debug($"åˆ†æ {messages.Count} æ¡èŠå¤©æ¶ˆæ¯");
        await Task.CompletedTask;
    }

    private async Task AnalyzeErrors(List<ServerMessage> messages)
    {
        // é”™è¯¯æ¶ˆæ¯åˆ†æï¼ˆé”™è¯¯èšåˆã€æ¨¡å¼è¯†åˆ«ç­‰ï¼‰
        _logger.Warning($"å‘ç° {messages.Count} ä¸ªé”™è¯¯");
        await Task.CompletedTask;
    }
}
```

---

## æ³¨å†Œå’Œç®¡ç†

### åœ¨æ’ä»¶ä¸­æ³¨å†Œå¤„ç†å™¨

å¤„ç†å™¨é€šè¿‡ `IPluginContext.ServerHandlerRegistry` è¿›è¡Œæ³¨å†Œã€‚

```csharp
using NetherGate.API.Plugins;

public class MyPlugin : PluginBase
{
    private CrashDetectionHandler? _crashHandler;
    private PerformanceMonitorHandler? _perfHandler;
    private PlayerActivityProcessor? _activityProcessor;

    public override async Task OnEnableAsync()
    {
        Logger.Info("æ³¨å†ŒæœåŠ¡ç«¯å¤„ç†å™¨...");

        // 1. æ³¨å†Œè¾“å‡ºå¤„ç†å™¨
        _crashHandler = new CrashDetectionHandler(Logger);
        Context.ServerHandlerRegistry.RegisterOutputHandler(_crashHandler, Metadata.Id);

        _perfHandler = new PerformanceMonitorHandler(Logger);
        Context.ServerHandlerRegistry.RegisterOutputHandler(_perfHandler, Metadata.Id);

        // 2. æ³¨å†Œæ¶ˆæ¯å¤„ç†å™¨
        _activityProcessor = new PlayerActivityProcessor(Logger);
        await Context.ServerHandlerRegistry.RegisterMessageProcessorAsync(_activityProcessor, Metadata.Id);

        Logger.Info("æœåŠ¡ç«¯å¤„ç†å™¨æ³¨å†Œå®Œæˆ");
    }

    public override async Task OnDisableAsync()
    {
        Logger.Info("æ³¨é”€æœåŠ¡ç«¯å¤„ç†å™¨...");

        // æ–¹å¼1: é€ä¸ªæ³¨é”€
        if (_crashHandler != null)
        {
            Context.ServerHandlerRegistry.UnregisterOutputHandler(_crashHandler.Name, Metadata.Id);
        }

        if (_activityProcessor != null)
        {
            await Context.ServerHandlerRegistry.UnregisterMessageProcessorAsync(_activityProcessor.Name, Metadata.Id);
        }

        // æ–¹å¼2: ä¸€æ¬¡æ€§æ³¨é”€æ‰€æœ‰ï¼ˆæ¨èï¼‰
        await Context.ServerHandlerRegistry.UnregisterAllHandlersAsync(Metadata.Id);

        Logger.Info("æœåŠ¡ç«¯å¤„ç†å™¨æ³¨é”€å®Œæˆ");
    }
}
```

### æŸ¥è¯¢å·²æ³¨å†Œçš„å¤„ç†å™¨

```csharp
public class MyPlugin : PluginBase
{
    public async Task ShowHandlerInfo()
    {
        // è·å–å½“å‰æ’ä»¶çš„å¤„ç†å™¨æ‘˜è¦
        var summary = Context.ServerHandlerRegistry.GetPluginHandlers(Metadata.Id);
        
        Logger.Info($"å½“å‰æ’ä»¶å·²æ³¨å†Œ:");
        Logger.Info($"  è¾“å‡ºå¤„ç†å™¨: {summary.OutputHandlerCount} ä¸ª");
        foreach (var name in summary.OutputHandlerNames)
        {
            Logger.Info($"    - {name}");
        }
        
        Logger.Info($"  æ¶ˆæ¯å¤„ç†å™¨: {summary.MessageProcessorCount} ä¸ª");
        foreach (var name in summary.MessageProcessorNames)
        {
            Logger.Info($"    - {name}");
        }

        // è·å–æ‰€æœ‰è¾“å‡ºå¤„ç†å™¨
        var allOutputHandlers = Context.ServerHandlerRegistry.GetOutputHandlers();
        Logger.Info($"å…¨å±€è¾“å‡ºå¤„ç†å™¨æ€»æ•°: {allOutputHandlers.Count}");
    }
}
```

---

## å®Œæ•´ç¤ºä¾‹ï¼šDiscord é€šçŸ¥æ’ä»¶

è¿™æ˜¯ä¸€ä¸ªå®Œæ•´çš„ç¤ºä¾‹ï¼Œå±•ç¤ºå¦‚ä½•åˆ›å»ºä¸€ä¸ªå°†æœåŠ¡å™¨äº‹ä»¶æ¨é€åˆ° Discord çš„æ’ä»¶ã€‚

```csharp
using NetherGate.API.Plugins;
using System.Net.Http;
using System.Text.Json;

/// <summary>
/// Discord é€šçŸ¥æ’ä»¶
/// å°†é‡è¦çš„æœåŠ¡å™¨äº‹ä»¶æ¨é€åˆ° Discord Webhook
/// </summary>
public class DiscordNotifierPlugin : PluginBase
{
    private DiscordNotificationHandler? _notificationHandler;

    public override async Task OnEnableAsync()
    {
        // åŠ è½½é…ç½®
        var config = await Config.LoadConfigAsync<DiscordConfig>("config");

        if (string.IsNullOrEmpty(config.WebhookUrl))
        {
            Logger.Error("Discord Webhook URL æœªé…ç½®");
            return;
        }

        // æ³¨å†Œé€šçŸ¥å¤„ç†å™¨
        _notificationHandler = new DiscordNotificationHandler(Logger, config);
        Context.ServerHandlerRegistry.RegisterOutputHandler(_notificationHandler, Metadata.Id);

        Logger.Info("Discord é€šçŸ¥æ’ä»¶å·²å¯ç”¨");
    }

    public override async Task OnDisableAsync()
    {
        await Context.ServerHandlerRegistry.UnregisterAllHandlersAsync(Metadata.Id);
        _notificationHandler?.Dispose();
        Logger.Info("Discord é€šçŸ¥æ’ä»¶å·²ç¦ç”¨");
    }
}

/// <summary>
/// Discord é€šçŸ¥å¤„ç†å™¨
/// </summary>
public class DiscordNotificationHandler : ServerOutputHandlerBase, IDisposable
{
    private readonly ILogger _logger;
    private readonly DiscordConfig _config;
    private readonly HttpClient _httpClient;
    private readonly Queue<string> _messageQueue = new();
    private readonly Timer _batchTimer;

    public override string Name => "DiscordNotifier";
    public override int Priority => 70;

    public DiscordNotificationHandler(ILogger logger, DiscordConfig config)
    {
        _logger = logger;
        _config = config;
        _httpClient = new HttpClient();
        _batchTimer = new Timer(SendBatchNotifications, null, 
            TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(10));
    }

    public override bool ShouldHandle(string line)
    {
        // åªå¤„ç†åŒ…å«å…³é”®äº‹ä»¶çš„æ—¥å¿—
        return line.Contains("logged in", StringComparison.OrdinalIgnoreCase)
            || line.Contains("lost connection", StringComparison.OrdinalIgnoreCase)
            || line.Contains("Done (", StringComparison.OrdinalIgnoreCase)
            || line.Contains("Stopping server", StringComparison.OrdinalIgnoreCase)
            || line.Contains("ERROR", StringComparison.OrdinalIgnoreCase);
    }

    public override async Task<HandlerResult> HandleAsync(ServerOutputContext context)
    {
        string? message = null;
        string? color = null;

        // æœåŠ¡å™¨å¯åŠ¨
        if (context.Message.Contains("Done ("))
        {
            message = "âœ… æœåŠ¡å™¨å¯åŠ¨å®Œæˆ";
            color = "3066993"; // ç»¿è‰²
        }
        // æœåŠ¡å™¨å…³é—­
        else if (context.Message.Contains("Stopping server"))
        {
            message = "ğŸ›‘ æœåŠ¡å™¨æ­£åœ¨å…³é—­";
            color = "15158332"; // çº¢è‰²
        }
        // ç©å®¶åŠ å…¥
        else if (context.Message.Contains("logged in"))
        {
            var match = System.Text.RegularExpressions.Regex.Match(
                context.Message, @"^([^\[]+)\[");
            if (match.Success)
            {
                var playerName = match.Groups[1].Value.Trim();
                message = $"ğŸ‘‹ ç©å®¶ **{playerName}** åŠ å…¥äº†æœåŠ¡å™¨";
                color = "3447003"; // è“è‰²
            }
        }
        // ç©å®¶ç¦»å¼€
        else if (context.Message.Contains("lost connection"))
        {
            var match = System.Text.RegularExpressions.Regex.Match(
                context.Message, @"^([^\s]+) lost connection");
            if (match.Success)
            {
                var playerName = match.Groups[1].Value;
                message = $"ğŸ‘‹ ç©å®¶ **{playerName}** ç¦»å¼€äº†æœåŠ¡å™¨";
                color = "10070709"; // ç°è‰²
            }
        }
        // é”™è¯¯
        else if (context.Level == "ERROR")
        {
            message = $"âš ï¸ æœåŠ¡å™¨é”™è¯¯: {context.Message}";
            color = "15158332"; // çº¢è‰²
        }

        if (message != null)
        {
            if (_config.EnableBatchMode)
            {
                // æ‰¹é‡æ¨¡å¼ï¼šåŠ å…¥é˜Ÿåˆ—
                lock (_messageQueue)
                {
                    _messageQueue.Enqueue(message);
                }
            }
            else
            {
                // å³æ—¶æ¨¡å¼ï¼šç«‹å³å‘é€
                await SendDiscordNotification(message, color);
            }

            return HandlerResult.Ok("å·²å‘é€ Discord é€šçŸ¥");
        }

        return HandlerResult.Skip();
    }

    private async void SendBatchNotifications(object? state)
    {
        List<string> messages;
        lock (_messageQueue)
        {
            if (_messageQueue.Count == 0)
                return;

            messages = _messageQueue.ToList();
            _messageQueue.Clear();
        }

        if (messages.Count > 0)
        {
            var batchMessage = string.Join("\n", messages);
            await SendDiscordNotification(batchMessage, "3447003");
        }
    }

    private async Task SendDiscordNotification(string message, string? color = null)
    {
        try
        {
            var payload = new
            {
                embeds = new[]
                {
                    new
                    {
                        description = message,
                        color = color != null ? int.Parse(color) : 3447003,
                        timestamp = DateTime.UtcNow.ToString("o")
                    }
                }
            };

            var json = JsonSerializer.Serialize(payload);
            var content = new StringContent(json, System.Text.Encoding.UTF8, "application/json");

            var response = await _httpClient.PostAsync(_config.WebhookUrl, content);
            
            if (!response.IsSuccessStatusCode)
            {
                _logger.Warning($"Discord é€šçŸ¥å‘é€å¤±è´¥: {response.StatusCode}");
            }
        }
        catch (Exception ex)
        {
            _logger.Error("å‘é€ Discord é€šçŸ¥å¤±è´¥", ex);
        }
    }

    public void Dispose()
    {
        _batchTimer?.Dispose();
        _httpClient?.Dispose();
    }
}

/// <summary>
/// Discord é…ç½®
/// </summary>
public class DiscordConfig
{
    public string WebhookUrl { get; set; } = string.Empty;
    public bool EnableBatchMode { get; set; } = true;
}
```

---

## æœ€ä½³å®è·µ

### 1. ä¼˜å…ˆçº§è®¾ç½®

```csharp
// âœ… æ¨èï¼šæ ¹æ®é‡è¦æ€§è®¾ç½®ä¼˜å…ˆçº§
public class CrashHandler : ServerOutputHandlerBase
{
    public override int Priority => 100;  // å´©æºƒæ£€æµ‹ï¼šæœ€é«˜ä¼˜å…ˆçº§
}

public class PerformanceMonitor : ServerOutputHandlerBase
{
    public override int Priority => 60;   // æ€§èƒ½ç›‘æ§ï¼šé«˜ä¼˜å…ˆçº§
}

public class StatisticsCollector : ServerOutputHandlerBase
{
    public override int Priority => 30;   // ç»Ÿè®¡æ”¶é›†ï¼šæ™®é€šä¼˜å…ˆçº§
}

// âŒ ä¸æ¨èï¼šæ‰€æœ‰å¤„ç†å™¨ä½¿ç”¨ç›¸åŒä¼˜å…ˆçº§
public override int Priority => 50;      // å¯èƒ½å¯¼è‡´æ‰§è¡Œé¡ºåºä¸ç¡®å®š
```

### 2. å¿«é€Ÿè¿‡æ»¤

```csharp
// âœ… æ¨èï¼šä½¿ç”¨ ShouldHandle å¿«é€Ÿè¿‡æ»¤
public override bool ShouldHandle(string line)
{
    return line.Contains("ERROR") || line.Contains("WARN");
}

public override async Task<HandlerResult> HandleAsync(ServerOutputContext context)
{
    // åªå¤„ç†é€šè¿‡å¿«é€Ÿè¿‡æ»¤çš„æ¶ˆæ¯
    // ...
}

// âŒ ä¸æ¨èï¼šåœ¨ HandleAsync ä¸­è¿›è¡Œæ‰€æœ‰åˆ¤æ–­
public override bool ShouldHandle(string line) => true;  // å¤„ç†æ‰€æœ‰æ¶ˆæ¯

public override async Task<HandlerResult> HandleAsync(ServerOutputContext context)
{
    if (!context.RawLine.Contains("ERROR") && !context.RawLine.Contains("WARN"))
        return HandlerResult.Skip();  // æµªè´¹æ€§èƒ½
    // ...
}
```

### 3. å¼‚å¸¸å¤„ç†

```csharp
// âœ… æ¨èï¼šå¤„ç†å¼‚å¸¸å¹¶è¿”å›å¤±è´¥ç»“æœ
public override async Task<HandlerResult> HandleAsync(ServerOutputContext context)
{
    try
    {
        await ProcessMessage(context);
        return HandlerResult.Ok();
    }
    catch (Exception ex)
    {
        _logger.Error($"å¤„ç†æ¶ˆæ¯å¤±è´¥: {ex.Message}", ex);
        return HandlerResult.Fail(ex.Message);
    }
}

// âŒ ä¸æ¨èï¼šä¸å¤„ç†å¼‚å¸¸ï¼ˆå¯èƒ½å¯¼è‡´å¤„ç†å™¨é“¾ä¸­æ–­ï¼‰
public override async Task<HandlerResult> HandleAsync(ServerOutputContext context)
{
    await ProcessMessage(context);  // å¯èƒ½æŠ›å‡ºå¼‚å¸¸
    return HandlerResult.Ok();
}
```

### 4. èµ„æºæ¸…ç†

```csharp
// âœ… æ¨èï¼šåœ¨ ShutdownAsync ä¸­æ¸…ç†èµ„æº
public class MyProcessor : ServerMessageProcessorBase, IDisposable
{
    private readonly Timer _timer;
    private readonly HttpClient _httpClient;

    public override Task ShutdownAsync()
    {
        _timer?.Dispose();
        _httpClient?.Dispose();
        return Task.CompletedTask;
    }

    public void Dispose()
    {
        _timer?.Dispose();
        _httpClient?.Dispose();
    }
}

// âŒ ä¸æ¨èï¼šä¸æ¸…ç†èµ„æºï¼ˆå¯èƒ½å¯¼è‡´å†…å­˜æ³„æ¼ï¼‰
```

### 5. å…±äº«æ•°æ®

```csharp
// âœ… æ¨èï¼šä½¿ç”¨ SharedData åœ¨å¤„ç†å™¨ä¹‹é—´ä¼ é€’æ•°æ®
public class TpsMonitor : ServerOutputHandlerBase
{
    public override async Task<HandlerResult> HandleAsync(ServerOutputContext context)
    {
        if (TryParseTps(context.Message, out var tps))
        {
            // å­˜å‚¨ TPS æ•°æ®ä¾›å…¶ä»–å¤„ç†å™¨ä½¿ç”¨
            context.SharedData["CurrentTPS"] = tps;
        }
        return HandlerResult.Ok();
    }
}

public class AlertHandler : ServerOutputHandlerBase
{
    public override async Task<HandlerResult> HandleAsync(ServerOutputContext context)
    {
        // è¯»å–å…¶ä»–å¤„ç†å™¨å­˜å‚¨çš„ TPS æ•°æ®
        if (context.SharedData.TryGetValue("CurrentTPS", out var tpsObj))
        {
            var tps = (double)tpsObj;
            if (tps < 15.0)
            {
                await SendAlert($"TPS è¿‡ä½: {tps}");
            }
        }
        return HandlerResult.Ok();
    }
}
```

---

## æ€§èƒ½ä¼˜åŒ–

### 1. ä½¿ç”¨ç¼–è¯‘çš„æ­£åˆ™è¡¨è¾¾å¼

```csharp
// âœ… æ¨è
private static readonly Regex Pattern = new(
    @"pattern",
    RegexOptions.Compiled | RegexOptions.IgnoreCase);

// âŒ ä¸æ¨èï¼šæ¯æ¬¡éƒ½åˆ›å»ºæ–°å®ä¾‹
public override bool ShouldHandle(string line)
{
    return Regex.IsMatch(line, @"pattern");  // æ€§èƒ½å·®
}
```

### 2. æ‰¹é‡å¤„ç†

```csharp
// âœ… æ¨èï¼šæ‰¹é‡å¤„ç†æ¶ˆæ¯
public override async Task ProcessBatchAsync(IReadOnlyList<ServerMessage> messages)
{
    // ä¸€æ¬¡æ€§å¤„ç†å¤šæ¡æ¶ˆæ¯ï¼ˆå¦‚æ‰¹é‡æ’å…¥æ•°æ®åº“ï¼‰
    await _database.BulkInsertAsync(messages);
}

// âŒ ä¸æ¨èï¼šé€æ¡å¤„ç†
public override async Task ProcessBatchAsync(IReadOnlyList<ServerMessage> messages)
{
    foreach (var message in messages)
    {
        await _database.InsertAsync(message);  // å¤šæ¬¡æ•°æ®åº“æ“ä½œ
    }
}
```

### 3. é¿å…é˜»å¡

```csharp
// âœ… æ¨èï¼šå¼‚æ­¥æ“ä½œ
public override async Task<HandlerResult> HandleAsync(ServerOutputContext context)
{
    await _httpClient.PostAsync(_webhookUrl, content);
    return HandlerResult.Ok();
}

// âŒ ä¸æ¨èï¼šé˜»å¡æ“ä½œ
public override async Task<HandlerResult> HandleAsync(ServerOutputContext context)
{
    _httpClient.PostAsync(_webhookUrl, content).Wait();  // é˜»å¡ä¸»çº¿ç¨‹
    return HandlerResult.Ok();
}
```

### 4. é™æµ

```csharp
// âœ… æ¨èï¼šå®ç°é™æµé¿å…è¿‡åº¦å¤„ç†
public class RateLimitedHandler : ServerOutputHandlerBase
{
    private DateTime _lastProcessTime = DateTime.MinValue;
    private readonly TimeSpan _minInterval = TimeSpan.FromSeconds(1);

    public override async Task<HandlerResult> HandleAsync(ServerOutputContext context)
    {
        var now = DateTime.UtcNow;
        if (now - _lastProcessTime < _minInterval)
        {
            return HandlerResult.Skip();  // è·³è¿‡ï¼Œé¿å…è¿‡åº¦å¤„ç†
        }

        _lastProcessTime = now;
        await ProcessMessage(context);
        return HandlerResult.Ok();
    }
}
```

---

## ç›¸å…³æ–‡æ¡£

- [æ’ä»¶å¼€å‘æŒ‡å—](./æ’ä»¶å¼€å‘æŒ‡å—.md)
- [äº‹ä»¶ç³»ç»Ÿ](../02-æ ¸å¿ƒåŠŸèƒ½/äº‹ä»¶ç³»ç»Ÿ.md)
- [å‘½ä»¤æ‹¦æˆªå™¨](./å‘½ä»¤æ‹¦æˆªå™¨æŒ‡å—.md)
- [æ’ä»¶é—´é€šä¿¡](../04-é«˜çº§åŠŸèƒ½/æ’ä»¶é—´é€šä¿¡.md)

---

**æ–‡æ¡£ç»´æŠ¤è€…ï¼š** NetherGate å¼€å‘å›¢é˜Ÿ  
**æœ€åæ›´æ–°ï¼š** 2025-10-12

