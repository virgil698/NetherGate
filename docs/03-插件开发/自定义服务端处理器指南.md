# NetherGate 自定义服务端处理器指南

本指南介绍如何在 NetherGate 插件中创建和使用自定义服务端处理器，用于处理 Minecraft 服务器的输出和消息。

---

## 📋 目录

- [概述](#概述)
- [处理器类型](#处理器类型)
- [IServerOutputHandler - 输出处理器](#iserveroutputhandler---输出处理器)
- [IServerMessageProcessor - 消息处理器](#iserveroutputhandler---消息处理器)
- [注册和管理](#注册和管理)
- [完整示例](#完整示例)
- [最佳实践](#最佳实践)
- [性能优化](#性能优化)

---

## 概述

NetherGate 提供了强大的服务端处理器系统，允许插件自定义处理服务器的各种输出和消息。

### 处理器架构

```
Minecraft Server
   ↓ (stdout/stderr)
ServerProcessManager
   ↓
LogParser (解析日志格式)
   ↓ ↓ ↓
   ├─→ IServerOutputHandler (原始输出处理)
   │     ├─ CrashDetectionHandler
   │     ├─ PerformanceMonitorHandler
   │     └─ CustomPluginHandler
   │
   ├─→ ILogMatcher (日志匹配 → 事件)
   │     ├─ PlayerJoinMatcher
   │     ├─ ServerReadyMatcher
   │     └─ CustomEventMatcher
   │
   └─→ IServerMessageProcessor (消息处理)
         ├─ StatisticsProcessor
         ├─ AlertProcessor
         └─ CustomProcessor
```

### 应用场景

- **实时监控**: 服务器崩溃检测、性能警告
- **数据收集**: 统计数据、玩家行为分析
- **自动化**: 自动备份、自动重启、自动通知
- **调试**: 日志过滤、错误追踪
- **集成**: Webhook 通知、Discord Bot、监控面板

---

## 处理器类型

NetherGate 提供两种主要的处理器接口：

| 处理器类型 | 用途 | 执行时机 | 适用场景 |
|-----------|------|---------|---------|
| **IServerOutputHandler** | 处理服务器原始输出 | 实时（每行输出） | 实时监控、崩溃检测、性能分析 |
| **IServerMessageProcessor** | 处理结构化消息 | 异步（批量/单条） | 数据分析、统计收集、通知推送 |

---

## IServerOutputHandler - 输出处理器

### 接口定义

```csharp
public interface IServerOutputHandler
{
    /// <summary>处理器名称</summary>
    string Name { get; }
    
    /// <summary>优先级（数值越大越先执行）</summary>
    int Priority { get; }
    
    /// <summary>处理服务器输出</summary>
    Task<HandlerResult> HandleAsync(ServerOutputContext context);
    
    /// <summary>快速过滤（可选）</summary>
    bool ShouldHandle(string line) => true;
}
```

### 优先级建议

```csharp
// 优先级范围
100+    // 紧急处理（服务器崩溃、严重错误）
50-99   // 高优先级（玩家事件、重要日志）
10-49   // 普通优先级（统计收集、一般监控）
0-9     // 低优先级（调试信息、详细日志）
```

### 基础示例

```csharp
using NetherGate.API.Plugins;
using System.Text.RegularExpressions;

/// <summary>
/// 服务器崩溃检测处理器
/// </summary>
public class CrashDetectionHandler : ServerOutputHandlerBase
{
    private readonly ILogger _logger;
    private static readonly Regex CrashPattern = new(
        @"(exception|error|crash|fatal|OutOfMemoryError)",
        RegexOptions.IgnoreCase | RegexOptions.Compiled);

    public override string Name => "CrashDetector";
    public override int Priority => 100; // 最高优先级

    public CrashDetectionHandler(ILogger logger)
    {
        _logger = logger;
    }

    public override bool ShouldHandle(string line)
    {
        // 快速过滤：只处理包含关键词的行
        return CrashPattern.IsMatch(line);
    }

    public override async Task<HandlerResult> HandleAsync(ServerOutputContext context)
    {
        if (context.Level == "ERROR" || context.Level == "FATAL")
        {
            _logger.Error($"检测到服务器错误: {context.Message}");

            // 检查是否为内存溢出
            if (context.Message.Contains("OutOfMemoryError", StringComparison.OrdinalIgnoreCase))
            {
                _logger.Fatal("服务器内存溢出！准备执行紧急备份...");
                await PerformEmergencyBackup();
                
                // 停止后续处理（拦截模式）
                return HandlerResult.OkAndStop("已拦截并处理内存溢出错误");
            }

            // 标记为已处理，但继续执行后续处理器
            context.IsHandled = true;
            return HandlerResult.Ok("错误已记录");
        }

        return HandlerResult.Skip();
    }

    private async Task PerformEmergencyBackup()
    {
        // 紧急备份逻辑
        _logger.Info("执行紧急备份...");
        await Task.Delay(100); // 实际备份操作
    }
}
```

### 高级示例：性能监控

```csharp
/// <summary>
/// 服务器性能监控处理器
/// </summary>
public class PerformanceMonitorHandler : ServerOutputHandlerBase
{
    private readonly ILogger _logger;
    private readonly Queue<PerformanceData> _performanceHistory = new();
    private static readonly Regex TpsPattern = new(
        @"TPS from last 1m, 5m, 15m: ([\d.]+), ([\d.]+), ([\d.]+)",
        RegexOptions.Compiled);

    public override string Name => "PerformanceMonitor";
    public override int Priority => 60;

    public PerformanceMonitorHandler(ILogger logger)
    {
        _logger = logger;
    }

    public override bool ShouldHandle(string line)
    {
        return line.Contains("TPS", StringComparison.OrdinalIgnoreCase)
            || line.Contains("lag", StringComparison.OrdinalIgnoreCase)
            || line.Contains("Can't keep up", StringComparison.OrdinalIgnoreCase);
    }

    public override async Task<HandlerResult> HandleAsync(ServerOutputContext context)
    {
        // 检测 TPS 信息
        var match = TpsPattern.Match(context.Message);
        if (match.Success)
        {
            var tps1m = double.Parse(match.Groups[1].Value);
            var tps5m = double.Parse(match.Groups[2].Value);
            var tps15m = double.Parse(match.Groups[3].Value);

            var data = new PerformanceData
            {
                Timestamp = DateTime.UtcNow,
                Tps1Min = tps1m,
                Tps5Min = tps5m,
                Tps15Min = tps15m
            };

            _performanceHistory.Enqueue(data);
            if (_performanceHistory.Count > 60) // 保留最近 60 条
                _performanceHistory.Dequeue();

            // 检测性能问题
            if (tps1m < 15.0)
            {
                _logger.Warning($"服务器 TPS 过低: {tps1m:F1} (1分钟平均)");
                await SendPerformanceAlert(data);
            }

            // 存储到共享数据，供其他处理器使用
            context.SharedData["LatestTPS"] = data;

            return HandlerResult.Ok("性能数据已记录");
        }

        // 检测 "Can't keep up" 警告
        if (context.Message.Contains("Can't keep up", StringComparison.OrdinalIgnoreCase))
        {
            _logger.Warning("服务器出现卡顿: " + context.Message);
            context.IsHandled = true;
            return HandlerResult.Ok("卡顿警告已记录");
        }

        return HandlerResult.Skip();
    }

    private async Task SendPerformanceAlert(PerformanceData data)
    {
        // 发送性能警告（Discord、WebSocket 等）
        _logger.Info($"发送性能警告: TPS={data.Tps1Min:F1}");
        await Task.CompletedTask;
    }

    private class PerformanceData
    {
        public DateTime Timestamp { get; init; }
        public double Tps1Min { get; init; }
        public double Tps5Min { get; init; }
        public double Tps15Min { get; init; }
    }
}
```

---

## IServerMessageProcessor - 消息处理器

消息处理器提供更高级的功能，包括异步处理、批量处理和生命周期管理。

### 接口定义

```csharp
public interface IServerMessageProcessor
{
    string Name { get; }
    int Priority { get; }
    
    Task InitializeAsync();
    Task ProcessMessageAsync(ServerMessage message);
    Task ProcessBatchAsync(IReadOnlyList<ServerMessage> messages);
    Task ShutdownAsync();
    bool ShouldProcess(ServerMessage message);
}
```

### 基础示例：统计收集器

```csharp
/// <summary>
/// 玩家活动统计处理器
/// </summary>
public class PlayerActivityProcessor : ServerMessageProcessorBase
{
    private readonly ILogger _logger;
    private readonly Dictionary<string, PlayerStats> _playerStats = new();
    private readonly Timer _saveTimer;

    public override string Name => "PlayerActivityCollector";
    public override int Priority => 30;

    public PlayerActivityProcessor(ILogger logger)
    {
        _logger = logger;
        _saveTimer = new Timer(SaveStatistics, null, Timeout.Infinite, Timeout.Infinite);
    }

    public override Task InitializeAsync()
    {
        _logger.Info("初始化玩家活动统计处理器...");
        LoadStatistics();
        
        // 每 5 分钟保存一次统计
        _saveTimer.Change(TimeSpan.FromMinutes(5), TimeSpan.FromMinutes(5));
        
        return Task.CompletedTask;
    }

    public override bool ShouldProcess(ServerMessage message)
    {
        return message.Type == ServerMessageType.PlayerJoin
            || message.Type == ServerMessageType.PlayerLeave
            || message.Type == ServerMessageType.PlayerChat
            || message.Type == ServerMessageType.PlayerCommand;
    }

    public override async Task ProcessMessageAsync(ServerMessage message)
    {
        switch (message.Type)
        {
            case ServerMessageType.PlayerJoin:
                if (message.Metadata.TryGetValue("PlayerName", out var joinName))
                {
                    RecordPlayerJoin((string)joinName);
                }
                break;

            case ServerMessageType.PlayerLeave:
                if (message.Metadata.TryGetValue("PlayerName", out var leaveName))
                {
                    RecordPlayerLeave((string)leaveName);
                }
                break;

            case ServerMessageType.PlayerChat:
                if (message.Metadata.TryGetValue("PlayerName", out var chatName))
                {
                    RecordPlayerActivity((string)chatName, PlayerActivity.Chat);
                }
                break;

            case ServerMessageType.PlayerCommand:
                if (message.Metadata.TryGetValue("PlayerName", out var cmdName))
                {
                    RecordPlayerActivity((string)cmdName, PlayerActivity.Command);
                }
                break;
        }

        await Task.CompletedTask;
    }

    public override Task ShutdownAsync()
    {
        _logger.Info("关闭玩家活动统计处理器...");
        _saveTimer.Dispose();
        SaveStatistics(null);
        return Task.CompletedTask;
    }

    private void RecordPlayerJoin(string playerName)
    {
        if (!_playerStats.ContainsKey(playerName))
        {
            _playerStats[playerName] = new PlayerStats { PlayerName = playerName };
        }

        _playerStats[playerName].TotalJoins++;
        _playerStats[playerName].LastSeen = DateTime.UtcNow;
        _logger.Debug($"记录玩家加入: {playerName}");
    }

    private void RecordPlayerLeave(string playerName)
    {
        if (_playerStats.ContainsKey(playerName))
        {
            _playerStats[playerName].LastSeen = DateTime.UtcNow;
        }
    }

    private void RecordPlayerActivity(string playerName, PlayerActivity activity)
    {
        if (!_playerStats.ContainsKey(playerName))
        {
            _playerStats[playerName] = new PlayerStats { PlayerName = playerName };
        }

        switch (activity)
        {
            case PlayerActivity.Chat:
                _playerStats[playerName].TotalChats++;
                break;
            case PlayerActivity.Command:
                _playerStats[playerName].TotalCommands++;
                break;
        }

        _playerStats[playerName].LastSeen = DateTime.UtcNow;
    }

    private void LoadStatistics()
    {
        // 从文件加载统计数据
        _logger.Debug("加载统计数据...");
    }

    private void SaveStatistics(object? state)
    {
        // 保存统计数据到文件
        _logger.Info($"保存统计数据: {_playerStats.Count} 个玩家");
    }

    private class PlayerStats
    {
        public string PlayerName { get; init; } = string.Empty;
        public int TotalJoins { get; set; }
        public int TotalChats { get; set; }
        public int TotalCommands { get; set; }
        public DateTime LastSeen { get; set; }
    }

    private enum PlayerActivity
    {
        Chat,
        Command
    }
}
```

### 高级示例：批量处理

```csharp
/// <summary>
/// 批量日志分析处理器
/// </summary>
public class BatchLogAnalyzer : ServerMessageProcessorBase
{
    private readonly ILogger _logger;
    private readonly ConcurrentQueue<ServerMessage> _messageQueue = new();
    private readonly Timer _batchTimer;
    private const int BatchSize = 50;

    public override string Name => "BatchLogAnalyzer";
    public override int Priority => 20;

    public BatchLogAnalyzer(ILogger logger)
    {
        _logger = logger;
        _batchTimer = new Timer(ProcessBatchQueue, null, Timeout.Infinite, Timeout.Infinite);
    }

    public override Task InitializeAsync()
    {
        _logger.Info("初始化批量日志分析器...");
        
        // 每 10 秒处理一次批量消息
        _batchTimer.Change(TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(10));
        
        return Task.CompletedTask;
    }

    public override bool ShouldProcess(ServerMessage message)
    {
        // 处理所有消息
        return true;
    }

    public override async Task ProcessMessageAsync(ServerMessage message)
    {
        // 将消息加入队列，等待批量处理
        _messageQueue.Enqueue(message);

        // 如果队列达到批量大小，立即处理
        if (_messageQueue.Count >= BatchSize)
        {
            await ProcessBatchQueue(null);
        }
    }

    public override async Task ProcessBatchAsync(IReadOnlyList<ServerMessage> messages)
    {
        if (messages.Count == 0)
            return;

        _logger.Debug($"批量处理 {messages.Count} 条消息");

        // 按消息类型分组
        var grouped = messages.GroupBy(m => m.Type);

        foreach (var group in grouped)
        {
            var count = group.Count();
            _logger.Info($"消息类型 {group.Key}: {count} 条");

            // 根据消息类型执行不同的分析
            await AnalyzeMessageGroup(group.Key, group.ToList());
        }
    }

    public override Task ShutdownAsync()
    {
        _logger.Info("关闭批量日志分析器...");
        _batchTimer.Dispose();
        
        // 处理剩余消息
        if (_messageQueue.Count > 0)
        {
            _ = ProcessBatchQueue(null);
        }
        
        return Task.CompletedTask;
    }

    private async Task ProcessBatchQueue(object? state)
    {
        var batch = new List<ServerMessage>();

        // 取出队列中的消息
        while (_messageQueue.TryDequeue(out var message) && batch.Count < BatchSize)
        {
            batch.Add(message);
        }

        if (batch.Count > 0)
        {
            await ProcessBatchAsync(batch);
        }
    }

    private async Task AnalyzeMessageGroup(ServerMessageType type, List<ServerMessage> messages)
    {
        // 针对不同消息类型的分析逻辑
        switch (type)
        {
            case ServerMessageType.PlayerChat:
                await AnalyzeChatMessages(messages);
                break;

            case ServerMessageType.Error:
                await AnalyzeErrors(messages);
                break;

            default:
                _logger.Trace($"跳过消息类型: {type}");
                break;
        }
    }

    private async Task AnalyzeChatMessages(List<ServerMessage> messages)
    {
        // 聊天消息分析（敏感词检测、垃圾信息过滤等）
        _logger.Debug($"分析 {messages.Count} 条聊天消息");
        await Task.CompletedTask;
    }

    private async Task AnalyzeErrors(List<ServerMessage> messages)
    {
        // 错误消息分析（错误聚合、模式识别等）
        _logger.Warning($"发现 {messages.Count} 个错误");
        await Task.CompletedTask;
    }
}
```

---

## 注册和管理

### 在插件中注册处理器

处理器通过 `IPluginContext.ServerHandlerRegistry` 进行注册。

```csharp
using NetherGate.API.Plugins;

public class MyPlugin : PluginBase
{
    private CrashDetectionHandler? _crashHandler;
    private PerformanceMonitorHandler? _perfHandler;
    private PlayerActivityProcessor? _activityProcessor;

    public override async Task OnEnableAsync()
    {
        Logger.Info("注册服务端处理器...");

        // 1. 注册输出处理器
        _crashHandler = new CrashDetectionHandler(Logger);
        Context.ServerHandlerRegistry.RegisterOutputHandler(_crashHandler, Metadata.Id);

        _perfHandler = new PerformanceMonitorHandler(Logger);
        Context.ServerHandlerRegistry.RegisterOutputHandler(_perfHandler, Metadata.Id);

        // 2. 注册消息处理器
        _activityProcessor = new PlayerActivityProcessor(Logger);
        await Context.ServerHandlerRegistry.RegisterMessageProcessorAsync(_activityProcessor, Metadata.Id);

        Logger.Info("服务端处理器注册完成");
    }

    public override async Task OnDisableAsync()
    {
        Logger.Info("注销服务端处理器...");

        // 方式1: 逐个注销
        if (_crashHandler != null)
        {
            Context.ServerHandlerRegistry.UnregisterOutputHandler(_crashHandler.Name, Metadata.Id);
        }

        if (_activityProcessor != null)
        {
            await Context.ServerHandlerRegistry.UnregisterMessageProcessorAsync(_activityProcessor.Name, Metadata.Id);
        }

        // 方式2: 一次性注销所有（推荐）
        await Context.ServerHandlerRegistry.UnregisterAllHandlersAsync(Metadata.Id);

        Logger.Info("服务端处理器注销完成");
    }
}
```

### 查询已注册的处理器

```csharp
public class MyPlugin : PluginBase
{
    public async Task ShowHandlerInfo()
    {
        // 获取当前插件的处理器摘要
        var summary = Context.ServerHandlerRegistry.GetPluginHandlers(Metadata.Id);
        
        Logger.Info($"当前插件已注册:");
        Logger.Info($"  输出处理器: {summary.OutputHandlerCount} 个");
        foreach (var name in summary.OutputHandlerNames)
        {
            Logger.Info($"    - {name}");
        }
        
        Logger.Info($"  消息处理器: {summary.MessageProcessorCount} 个");
        foreach (var name in summary.MessageProcessorNames)
        {
            Logger.Info($"    - {name}");
        }

        // 获取所有输出处理器
        var allOutputHandlers = Context.ServerHandlerRegistry.GetOutputHandlers();
        Logger.Info($"全局输出处理器总数: {allOutputHandlers.Count}");
    }
}
```

---

## 完整示例：Discord 通知插件

这是一个完整的示例，展示如何创建一个将服务器事件推送到 Discord 的插件。

```csharp
using NetherGate.API.Plugins;
using System.Net.Http;
using System.Text.Json;

/// <summary>
/// Discord 通知插件
/// 将重要的服务器事件推送到 Discord Webhook
/// </summary>
public class DiscordNotifierPlugin : PluginBase
{
    private DiscordNotificationHandler? _notificationHandler;

    public override async Task OnEnableAsync()
    {
        // 加载配置
        var config = await Config.LoadConfigAsync<DiscordConfig>("config");

        if (string.IsNullOrEmpty(config.WebhookUrl))
        {
            Logger.Error("Discord Webhook URL 未配置");
            return;
        }

        // 注册通知处理器
        _notificationHandler = new DiscordNotificationHandler(Logger, config);
        Context.ServerHandlerRegistry.RegisterOutputHandler(_notificationHandler, Metadata.Id);

        Logger.Info("Discord 通知插件已启用");
    }

    public override async Task OnDisableAsync()
    {
        await Context.ServerHandlerRegistry.UnregisterAllHandlersAsync(Metadata.Id);
        _notificationHandler?.Dispose();
        Logger.Info("Discord 通知插件已禁用");
    }
}

/// <summary>
/// Discord 通知处理器
/// </summary>
public class DiscordNotificationHandler : ServerOutputHandlerBase, IDisposable
{
    private readonly ILogger _logger;
    private readonly DiscordConfig _config;
    private readonly HttpClient _httpClient;
    private readonly Queue<string> _messageQueue = new();
    private readonly Timer _batchTimer;

    public override string Name => "DiscordNotifier";
    public override int Priority => 70;

    public DiscordNotificationHandler(ILogger logger, DiscordConfig config)
    {
        _logger = logger;
        _config = config;
        _httpClient = new HttpClient();
        _batchTimer = new Timer(SendBatchNotifications, null, 
            TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(10));
    }

    public override bool ShouldHandle(string line)
    {
        // 只处理包含关键事件的日志
        return line.Contains("logged in", StringComparison.OrdinalIgnoreCase)
            || line.Contains("lost connection", StringComparison.OrdinalIgnoreCase)
            || line.Contains("Done (", StringComparison.OrdinalIgnoreCase)
            || line.Contains("Stopping server", StringComparison.OrdinalIgnoreCase)
            || line.Contains("ERROR", StringComparison.OrdinalIgnoreCase);
    }

    public override async Task<HandlerResult> HandleAsync(ServerOutputContext context)
    {
        string? message = null;
        string? color = null;

        // 服务器启动
        if (context.Message.Contains("Done ("))
        {
            message = "✅ 服务器启动完成";
            color = "3066993"; // 绿色
        }
        // 服务器关闭
        else if (context.Message.Contains("Stopping server"))
        {
            message = "🛑 服务器正在关闭";
            color = "15158332"; // 红色
        }
        // 玩家加入
        else if (context.Message.Contains("logged in"))
        {
            var match = System.Text.RegularExpressions.Regex.Match(
                context.Message, @"^([^\[]+)\[");
            if (match.Success)
            {
                var playerName = match.Groups[1].Value.Trim();
                message = $"👋 玩家 **{playerName}** 加入了服务器";
                color = "3447003"; // 蓝色
            }
        }
        // 玩家离开
        else if (context.Message.Contains("lost connection"))
        {
            var match = System.Text.RegularExpressions.Regex.Match(
                context.Message, @"^([^\s]+) lost connection");
            if (match.Success)
            {
                var playerName = match.Groups[1].Value;
                message = $"👋 玩家 **{playerName}** 离开了服务器";
                color = "10070709"; // 灰色
            }
        }
        // 错误
        else if (context.Level == "ERROR")
        {
            message = $"⚠️ 服务器错误: {context.Message}";
            color = "15158332"; // 红色
        }

        if (message != null)
        {
            if (_config.EnableBatchMode)
            {
                // 批量模式：加入队列
                lock (_messageQueue)
                {
                    _messageQueue.Enqueue(message);
                }
            }
            else
            {
                // 即时模式：立即发送
                await SendDiscordNotification(message, color);
            }

            return HandlerResult.Ok("已发送 Discord 通知");
        }

        return HandlerResult.Skip();
    }

    private async void SendBatchNotifications(object? state)
    {
        List<string> messages;
        lock (_messageQueue)
        {
            if (_messageQueue.Count == 0)
                return;

            messages = _messageQueue.ToList();
            _messageQueue.Clear();
        }

        if (messages.Count > 0)
        {
            var batchMessage = string.Join("\n", messages);
            await SendDiscordNotification(batchMessage, "3447003");
        }
    }

    private async Task SendDiscordNotification(string message, string? color = null)
    {
        try
        {
            var payload = new
            {
                embeds = new[]
                {
                    new
                    {
                        description = message,
                        color = color != null ? int.Parse(color) : 3447003,
                        timestamp = DateTime.UtcNow.ToString("o")
                    }
                }
            };

            var json = JsonSerializer.Serialize(payload);
            var content = new StringContent(json, System.Text.Encoding.UTF8, "application/json");

            var response = await _httpClient.PostAsync(_config.WebhookUrl, content);
            
            if (!response.IsSuccessStatusCode)
            {
                _logger.Warning($"Discord 通知发送失败: {response.StatusCode}");
            }
        }
        catch (Exception ex)
        {
            _logger.Error("发送 Discord 通知失败", ex);
        }
    }

    public void Dispose()
    {
        _batchTimer?.Dispose();
        _httpClient?.Dispose();
    }
}

/// <summary>
/// Discord 配置
/// </summary>
public class DiscordConfig
{
    public string WebhookUrl { get; set; } = string.Empty;
    public bool EnableBatchMode { get; set; } = true;
}
```

---

## 最佳实践

### 1. 优先级设置

```csharp
// ✅ 推荐：根据重要性设置优先级
public class CrashHandler : ServerOutputHandlerBase
{
    public override int Priority => 100;  // 崩溃检测：最高优先级
}

public class PerformanceMonitor : ServerOutputHandlerBase
{
    public override int Priority => 60;   // 性能监控：高优先级
}

public class StatisticsCollector : ServerOutputHandlerBase
{
    public override int Priority => 30;   // 统计收集：普通优先级
}

// ❌ 不推荐：所有处理器使用相同优先级
public override int Priority => 50;      // 可能导致执行顺序不确定
```

### 2. 快速过滤

```csharp
// ✅ 推荐：使用 ShouldHandle 快速过滤
public override bool ShouldHandle(string line)
{
    return line.Contains("ERROR") || line.Contains("WARN");
}

public override async Task<HandlerResult> HandleAsync(ServerOutputContext context)
{
    // 只处理通过快速过滤的消息
    // ...
}

// ❌ 不推荐：在 HandleAsync 中进行所有判断
public override bool ShouldHandle(string line) => true;  // 处理所有消息

public override async Task<HandlerResult> HandleAsync(ServerOutputContext context)
{
    if (!context.RawLine.Contains("ERROR") && !context.RawLine.Contains("WARN"))
        return HandlerResult.Skip();  // 浪费性能
    // ...
}
```

### 3. 异常处理

```csharp
// ✅ 推荐：处理异常并返回失败结果
public override async Task<HandlerResult> HandleAsync(ServerOutputContext context)
{
    try
    {
        await ProcessMessage(context);
        return HandlerResult.Ok();
    }
    catch (Exception ex)
    {
        _logger.Error($"处理消息失败: {ex.Message}", ex);
        return HandlerResult.Fail(ex.Message);
    }
}

// ❌ 不推荐：不处理异常（可能导致处理器链中断）
public override async Task<HandlerResult> HandleAsync(ServerOutputContext context)
{
    await ProcessMessage(context);  // 可能抛出异常
    return HandlerResult.Ok();
}
```

### 4. 资源清理

```csharp
// ✅ 推荐：在 ShutdownAsync 中清理资源
public class MyProcessor : ServerMessageProcessorBase, IDisposable
{
    private readonly Timer _timer;
    private readonly HttpClient _httpClient;

    public override Task ShutdownAsync()
    {
        _timer?.Dispose();
        _httpClient?.Dispose();
        return Task.CompletedTask;
    }

    public void Dispose()
    {
        _timer?.Dispose();
        _httpClient?.Dispose();
    }
}

// ❌ 不推荐：不清理资源（可能导致内存泄漏）
```

### 5. 共享数据

```csharp
// ✅ 推荐：使用 SharedData 在处理器之间传递数据
public class TpsMonitor : ServerOutputHandlerBase
{
    public override async Task<HandlerResult> HandleAsync(ServerOutputContext context)
    {
        if (TryParseTps(context.Message, out var tps))
        {
            // 存储 TPS 数据供其他处理器使用
            context.SharedData["CurrentTPS"] = tps;
        }
        return HandlerResult.Ok();
    }
}

public class AlertHandler : ServerOutputHandlerBase
{
    public override async Task<HandlerResult> HandleAsync(ServerOutputContext context)
    {
        // 读取其他处理器存储的 TPS 数据
        if (context.SharedData.TryGetValue("CurrentTPS", out var tpsObj))
        {
            var tps = (double)tpsObj;
            if (tps < 15.0)
            {
                await SendAlert($"TPS 过低: {tps}");
            }
        }
        return HandlerResult.Ok();
    }
}
```

---

## 性能优化

### 1. 使用编译的正则表达式

```csharp
// ✅ 推荐
private static readonly Regex Pattern = new(
    @"pattern",
    RegexOptions.Compiled | RegexOptions.IgnoreCase);

// ❌ 不推荐：每次都创建新实例
public override bool ShouldHandle(string line)
{
    return Regex.IsMatch(line, @"pattern");  // 性能差
}
```

### 2. 批量处理

```csharp
// ✅ 推荐：批量处理消息
public override async Task ProcessBatchAsync(IReadOnlyList<ServerMessage> messages)
{
    // 一次性处理多条消息（如批量插入数据库）
    await _database.BulkInsertAsync(messages);
}

// ❌ 不推荐：逐条处理
public override async Task ProcessBatchAsync(IReadOnlyList<ServerMessage> messages)
{
    foreach (var message in messages)
    {
        await _database.InsertAsync(message);  // 多次数据库操作
    }
}
```

### 3. 避免阻塞

```csharp
// ✅ 推荐：异步操作
public override async Task<HandlerResult> HandleAsync(ServerOutputContext context)
{
    await _httpClient.PostAsync(_webhookUrl, content);
    return HandlerResult.Ok();
}

// ❌ 不推荐：阻塞操作
public override async Task<HandlerResult> HandleAsync(ServerOutputContext context)
{
    _httpClient.PostAsync(_webhookUrl, content).Wait();  // 阻塞主线程
    return HandlerResult.Ok();
}
```

### 4. 限流

```csharp
// ✅ 推荐：实现限流避免过度处理
public class RateLimitedHandler : ServerOutputHandlerBase
{
    private DateTime _lastProcessTime = DateTime.MinValue;
    private readonly TimeSpan _minInterval = TimeSpan.FromSeconds(1);

    public override async Task<HandlerResult> HandleAsync(ServerOutputContext context)
    {
        var now = DateTime.UtcNow;
        if (now - _lastProcessTime < _minInterval)
        {
            return HandlerResult.Skip();  // 跳过，避免过度处理
        }

        _lastProcessTime = now;
        await ProcessMessage(context);
        return HandlerResult.Ok();
    }
}
```

---

## 相关文档

- [插件开发指南](./插件开发指南.md)
- [事件系统](../02-核心功能/事件系统.md)
- [命令拦截器](./命令拦截器指南.md)
- [插件间通信](../04-高级功能/插件间通信.md)

---

**文档维护者：** NetherGate 开发团队  
**最后更新：** 2025-10-12

