# NetherGate 插件开发指南

本指南将带你从零开始创建第一个 NetherGate 插件，并介绍插件开发的核心概念和最佳实践。

---

## 📋 **目录**

- [环境准备](#环境准备)
- [创建第一个插件](#创建第一个插件)
- [插件结构](#插件结构)
- [plugin.json 配置](#pluginjson-配置)
- [插件生命周期](#插件生命周期)
- [IPluginContext 接口](#iplugincontext-接口)
- [完整示例](#完整示例)
- [调试插件](#调试插件)
- [发布插件](#发布插件)

---

## 🔧 **环境准备**

### **1. 安装工具**

- **.NET 9.0 SDK** 或更高版本
  - 下载：https://dotnet.microsoft.com/download
  - 验证：`dotnet --version`

- **IDE**（选择一个）
  - Visual Studio 2022
  - JetBrains Rider
  - Visual Studio Code + C# Dev Kit

### **2. 获取 NetherGate.API**

#### **方式 1：从源码引用**

```bash
git clone https://github.com/your-org/NetherGate.git
# 然后在插件项目中引用 NetherGate.API.csproj
```

#### **方式 2：从 NuGet 安装**（如果已发布）

```bash
dotnet add package NetherGate.API
```

---

## 🚀 **创建第一个插件**

### **1. 创建项目**

```bash
# 创建新的类库项目
dotnet new classlib -n HelloWorldPlugin
cd HelloWorldPlugin

# 添加 NetherGate.API 引用
dotnet add reference ../NetherGate/src/NetherGate.API/NetherGate.API.csproj
```

### **2. 配置项目文件**

编辑 `HelloWorldPlugin.csproj`：

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <!-- 目标框架 -->
    <TargetFramework>net9.0</TargetFramework>
    
    <!-- 启用动态加载（必须） -->
    <EnableDynamicLoading>true</EnableDynamicLoading>
    
    <!-- 可为 null 的引用类型 -->
    <Nullable>enable</Nullable>
    
    <!-- 插件版本 -->
    <Version>1.0.0</Version>
  </PropertyGroup>

  <ItemGroup>
    <!-- NetherGate API 引用 -->
    <PackageReference Include="NetherGate.API" Version="1.0.0" PrivateAssets="all" />
  </ItemGroup>

  <!-- 构建后自动复制到 plugins 目录 -->
  <Target Name="CopyToPlugins" AfterTargets="Build">
    <ItemGroup>
      <PluginFiles Include="$(OutputPath)**\*.*" />
    </ItemGroup>
    <Copy 
      SourceFiles="@(PluginFiles)" 
      DestinationFolder="$(SolutionDir)..\NetherGate\bin\$(Configuration)\plugins\$(ProjectName)\%(RecursiveDir)" 
      SkipUnchangedFiles="true" />
  </Target>
</Project>
```

### **3. 创建插件主类**

删除 `Class1.cs`，创建 `HelloWorldPlugin.cs`：

```csharp
using NetherGate.API.Plugins;
using NetherGate.API.Events;

namespace HelloWorldPlugin;

public class HelloWorldPlugin : PluginBase
{
    public override Task OnLoadAsync()
    {
        // 插件加载时调用
        Console.WriteLine("[HelloWorld] 插件正在加载...");
        return Task.CompletedTask;
    }

    public override Task OnEnableAsync()
    {
        // 插件启用时调用
        Logger.Info("Hello World 插件已启用！");
        
        // 订阅玩家加入事件（带优先级）
        Events.Subscribe<PlayerJoinedEvent>(OnPlayerJoined, EventPriority.Normal);
        
        // 注册命令
        Commands.RegisterCommand(new HelloCommand(this));
        
        return Task.CompletedTask;
    }

    public override Task OnDisableAsync()
    {
        // 插件禁用时调用
        Logger.Info("Hello World 插件已禁用");
        return Task.CompletedTask;
    }

    private async Task OnPlayerJoined(PlayerJoinedEvent e)
    {
        Logger.Info($"玩家 {e.Player.Name} 加入了服务器");
        
        // 发送欢迎消息
        await GameDisplay.SendChatMessage(
            e.Player.Name, 
            "§a欢迎来到服务器！这是来自 HelloWorld 插件的问候。"
        );
    }
}
```

### **4. 创建命令**

创建 `HelloCommand.cs`：

```csharp
using NetherGate.API.Commands;
using NetherGate.API.Plugins;

namespace HelloWorldPlugin;

public class HelloCommand : ICommand
{
    private readonly HelloWorldPlugin _plugin;

    public string Name => "hello";
    public string Description => "向玩家打招呼";
    public string Usage => "/hello [name]";
    public string[] Aliases => new[] { "hi" };
    public string Permission => "helloworld.use";
    public string PluginId => _plugin.Metadata.Id;

    public HelloCommand(HelloWorldPlugin plugin)
    {
        _plugin = plugin;
    }

    public async Task<CommandResult> ExecuteAsync(ICommandSender sender, string[] args)
    {
        if (sender.IsConsole)
        {
            // 控制台执行
            _plugin.Logger.Info("Hello from console!");
            return CommandResult.Ok("Hello from console!");
        }
        
        // 游戏内执行
        string playerName = sender.Name;
        string greeting = args.Length > 0 
            ? $"§aHello, {args[0]}! From {playerName}." 
            : $"§aHello, {playerName}!";
        
        await _plugin.GameDisplay.SendChatMessage(playerName, greeting);
        
        return CommandResult.Ok("Greeting sent!");
    }
    
    public async Task<List<string>> TabCompleteAsync(ICommandSender sender, string[] args)
    {
        // 提供在线玩家列表作为Tab补全
        if (args.Length == 1)
        {
            var players = await _plugin.Server.GetOnlinePlayersAsync();
            return players
                .Select(p => p.Name)
                .Where(name => name.StartsWith(args[0], StringComparison.OrdinalIgnoreCase))
                .ToList();
        }
        return new List<string>();
    }
}
```

### **5. 创建 plugin.json**

在项目根目录创建 `plugin.json`：

```json
{
  "name": "HelloWorldPlugin",
  "version": "1.0.0",
  "author": "Your Name",
  "description": "My first NetherGate plugin",
  "entry_point": "HelloWorldPlugin.HelloWorldPlugin",
  "dependencies": {},
  "nethergate_api_version": "1.0.0"
}
```

**设置为始终复制：**

编辑 `.csproj`，添加：

```xml
<ItemGroup>
  <None Update="plugin.json">
    <CopyToOutputDirectory>Always</CopyToOutputDirectory>
  </None>
</ItemGroup>
```

### **6. 构建和运行**

```bash
# 构建插件
dotnet build

# 输出位置：bin/Debug/net9.0/

# 复制到 NetherGate plugins 目录
# （如果配置了 CopyToPlugins，会自动复制）

# 运行 NetherGate
cd ../NetherGate/bin/Debug
dotnet NetherGate.Host.dll
```

### **7. 测试插件**

```bash
# 在 NetherGate 控制台
plugin list          # 查看插件列表
hello                # 执行命令（控制台）

# 在 Minecraft 游戏内
#hello                # 执行命令（游戏内）
#hi                   # 使用别名
```

---

## 📁 **插件结构**

### **最小插件结构**

```
HelloWorldPlugin/
├── src/
│   └── HelloWorldPlugin.cs        # 主类
├── resources/
│   └── plugin.json                # 元数据（必需）
└── HelloWorldPlugin.csproj        # 项目文件
```

### **标准插件结构**

```
MyPlugin/
├── MyPlugin.csproj                # 项目文件
├── README.md                      # 插件说明
│
├── src/                           # 源代码目录
│   ├── MyPlugin.cs                # 主类
│   ├── Commands/                  # 命令处理
│   │   ├── AdminCommand.cs
│   │   └── UserCommand.cs
│   ├── Events/                    # 事件监听器
│   │   ├── PlayerEventHandler.cs
│   │   └── ServerEventHandler.cs
│   ├── Services/                  # 业务逻辑
│   │   └── DatabaseService.cs
│   └── Models/                    # 数据模型
│       ├── PlayerData.cs
│       └── Config.cs
│
└── resources/                     # 资源文件目录
    ├── plugin.json                # 插件元数据（必需）
    ├── config.json                # 默认配置模板（JSON 或 YAML）
    ├── config.yaml                # YAML 格式配置（可选）
    └── lang/                      # 多语言文件（可选）
        ├── en_US.json
        └── zh_CN.json
```

### **编译输出结构**

编译后的输出目录（`bin/Release/net9.0/`）：

```
MyPlugin/
├── MyPlugin.dll                   # 插件主 DLL
├── MyPlugin.pdb                   # 调试符号（可选）
├── plugin.json                    # 插件元数据
└── Newtonsoft.Json.dll            # 依赖 DLL（如果有）
```

**部署到 NetherGate：**

将整个输出目录复制到 `NetherGate/plugins/my-plugin/` 即可。

**运行时结构：**

```
NetherGate/
├── lib/                           # 全局共享依赖
│   └── Newtonsoft.Json.dll        # （可选）放在这里被所有插件共享
│
├── plugins/
│   └── my-plugin/
│       ├── MyPlugin.dll
│       ├── plugin.json
│       ├── config.json            # 默认配置模板
│       └── Newtonsoft.Json.dll    # 或放在插件目录（插件私有）
│
└── config/                        # 配置目录
    └── my-plugin/
        └── config.yaml            # 用户配置（自动生成）
```

---

## 📝 **plugin.json 配置**

### **完整 plugin.json 示例**

```json
{
  "id": "com.example.myplugin",
  "name": "MyPlugin",
  "version": "1.0.0",
  "description": "A powerful Minecraft plugin",
  "author": "Your Name",
  "website": "https://example.com",
  "license": "MIT",
  
  "main": "MyPlugin.MyPluginMain",
  
  "dependencies": [],
  "soft_dependencies": [],
  
  "library_dependencies": [
    {
      "name": "Newtonsoft.Json",
      "version": "13.0.3",
      "location": "lib",
      "optional": false
    },
    {
      "name": "MySql.Data",
      "version": ">=8.0.0",
      "location": "auto",
      "optional": true
    }
  ],
  
  "load_order": 100,
  "nethergate_version": ">=1.0.0",
  "minecraft_version": ">=1.21.0",
  "target_framework": "net9.0",
  
  "tags": ["economy", "teleport"],
  
  "properties": {
    "custom_property": "custom_value"
  }
}
```

**关键字段说明：**

| 字段 | 必需 | 说明 |
|------|------|------|
| `id` | ✅ | 插件唯一标识符（建议使用反向域名，如 `com.example.myplugin`） |
| `name` | ✅ | 插件显示名称 |
| `version` | ✅ | 插件版本（遵循[语义化版本](https://semver.org/)） |
| `main` | ✅ | 插件主类完整名称（`命名空间.类名`，如 `MyPlugin.MyPluginMain`） |
| `description` | ❌ | 插件描述 |
| `author` | ❌ | 作者名称 |
| `website` | ❌ | 插件网站 |
| `dependencies` | ❌ | 插件依赖（其他 NetherGate 插件的 ID 列表） |
| `soft_dependencies` | ❌ | 软依赖（可选依赖，不存在不影响加载） |
| `library_dependencies` | ❌ | 库依赖（DLL 文件依赖） |
| `nethergate_version` | ❌ | 所需 NetherGate 版本（如 `>=1.0.0`） |
| `minecraft_version` | ❌ | 所需 Minecraft 版本（如 `>=1.21.0`） |
| `target_framework` | ❌ | 目标 .NET 框架（如 `net9.0`） |
| `load_order` | ❌ | 加载顺序（数字越小越先加载，默认 100） |
| `tags` | ❌ | 标签列表（用于分类和搜索） |

---

## 🛠️ **项目文件配置**

### **MyPlugin.csproj 配置**

```xml
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    
    <!-- 复制所有依赖到输出目录 -->
    <CopyLocalLockFileAssemblies>true</CopyLocalLockFileAssemblies>
  </PropertyGroup>

  <!-- NetherGate API 依赖 -->
  <ItemGroup>
    <PackageReference Include="NetherGate.API" Version="1.0.0">
      <PrivateAssets>all</PrivateAssets>
      <ExcludeAssets>runtime</ExcludeAssets>
    </PackageReference>
  </ItemGroup>

  <!-- 外部依赖（示例） -->
  <ItemGroup>
    <PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
  </ItemGroup>

  <!-- 资源文件处理 -->
  <ItemGroup>
    <!-- plugin.json 必须复制到输出目录根 -->
    <None Include="resources\plugin.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
      <Link>plugin.json</Link>
    </None>
    
    <!-- 默认配置模板（可选） -->
    <None Include="resources\config.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
      <Link>config.json</Link>
    </None>
    
    <!-- 多语言文件：复制到 lang/ 子目录 -->
    <None Include="resources\lang\**\*.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
      <Link>lang\%(RecursiveDir)%(Filename)%(Extension)</Link>
    </None>
  </ItemGroup>

  <!-- 源代码组织 -->
  <ItemGroup>
    <Compile Include="src\**\*.cs" />
  </ItemGroup>

</Project>
```

### **配置要点**

1. **`CopyLocalLockFileAssemblies`**: 确保依赖 DLL 被复制到输出目录
2. **`PrivateAssets` / `ExcludeAssets`**: NetherGate API 不复制（框架已提供）
3. **资源文件映射**: 使用 `<Link>` 标签将 `resources/` 下的文件复制到输出目录的正确位置

---

## 📝 **最佳实践**

### **目录组织**

✅ **推荐**：
```
src/
├── Commands/           # 按功能分类
├── Events/
├── Services/
└── Models/
```

❌ **不推荐**：
```
src/
├── File1.cs           # 所有文件堆在一起
├── File2.cs
└── File3.cs
```
| `nethergate_api_version` | ❌ | 要求的 NetherGate API 版本 |
| `minecraft_version` | ❌ | 支持的 Minecraft 版本 |
| `permissions` | ❌ | 权限定义 |

### **版本约束**


### **IPlugin 接口**

所有插件必须实现 `IPlugin` 接口：

```csharp
namespace NetherGate.API.Plugins
{
    /// <summary>
    /// 插件接口，所有插件必须实现此接口
    /// </summary>
    public interface IPlugin
    {
        /// <summary>
        /// 插件元数据
        /// </summary>
        PluginMetadata Metadata { get; }
        
        /// <summary>
        /// 当前状态
        /// </summary>
        PluginState State { get; }
        
        /// <summary>
        /// 插件加载时调用（仅一次）
        /// 此时尚未注入依赖，仅用于初始化静态资源
        /// </summary>
        Task OnLoadAsync();
        
        /// <summary>
        /// 插件启用时调用
        /// 可以访问 IPluginContext，注册命令、订阅事件等
        /// </summary>
        Task OnEnableAsync();
        
        /// <summary>
        /// 插件禁用时调用
        /// 应清理资源、取消订阅事件、保存数据
        /// </summary>
        Task OnDisableAsync();
        
        /// <summary>
        /// 插件卸载时调用（仅一次）
        /// 最终清理，释放所有资源
        /// </summary>
        Task OnUnloadAsync();
    }
    
    /// <summary>
    /// 插件状态枚举
    /// </summary>
    public enum PluginState
    {
        Unloaded,   // 未加载
        Loaded,     // 已加载
        Enabled,    // 已启用
        Disabled,   // 已禁用
        Failed      // 失败
    }
}
```

### **PluginBase 抽象类**（推荐）

NetherGate 提供了 `PluginBase` 抽象类，简化插件开发：

```csharp
namespace NetherGate.API.Plugins
{
    /// <summary>
    /// 插件基类，提供常用功能的便捷访问
    /// </summary>
    public abstract class PluginBase : IPlugin
    {
        // 自动注入的属性
        public PluginMetadata Metadata { get; internal set; } = null!;
        public PluginState State { get; internal set; }
        
        /// <summary>日志记录器</summary>
        protected ILogger Logger { get; private set; } = null!;
        
        /// <summary>配置管理</summary>
        protected IConfigManager Config { get; private set; } = null!;
        
        /// <summary>SMP API（服务端管理协议）</summary>
        protected ISmpApi Server { get; private set; } = null!;
        
        /// <summary>RCON 客户端</summary>
        protected IRconClient? Rcon { get; private set; }
        
        /// <summary>事件总线</summary>
        protected IEventBus Events { get; private set; } = null!;
        
        /// <summary>命令管理器</summary>
        protected ICommandManager Commands { get; private set; } = null!;
        
        /// <summary>游戏显示 API</summary>
        protected IGameDisplayApi GameDisplay { get; private set; } = null!;
        
        /// <summary>插件间通信</summary>
        protected IPluginMessenger Messenger { get; private set; } = null!;
        
        /// <summary>插件数据目录</summary>
        protected string DataDirectory { get; private set; } = null!;
        
        // 生命周期方法（子类可重写）
        public virtual Task OnLoadAsync() => Task.CompletedTask;
        public virtual Task OnEnableAsync() => Task.CompletedTask;
        public virtual Task OnDisableAsync() => Task.CompletedTask;
        public virtual Task OnUnloadAsync() => Task.CompletedTask;
    }
}
```

**使用 PluginBase 的优势：**
- ✅ 自动注入常用服务，无需手动保存 `IPluginContext`
- ✅ 提供 `protected` 属性，代码更简洁
- ✅ 默认实现生命周期方法，只需重写需要的方法
```

### **生命周期顺序**

```
1. 加载阶段（Load）
   ├─ 加载程序集
   ├─ 读取 plugin.json
   ├─ 检查依赖
   ├─ 创建插件实例
   └─ 调用 OnLoadAsync()  ← 初始化静态资源

2. 启用阶段（Enable）
   ├─ 创建 IPluginContext
   ├─ 注入依赖
   └─ 调用 OnEnableAsync()
      ├─ 加载配置
      ├─ 订阅事件（带优先级）
      ├─ 注册命令
      ├─ 初始化服务
      └─ 启动定时任务

3. 运行阶段（Running）
   ├─ 响应事件
   ├─ 处理命令
   ├─ 执行任务
   └─ 插件间通信

4. 禁用阶段（Disable）
   ├─ 调用 OnDisableAsync()
   │  ├─ 停止定时任务
   │  ├─ 保存数据
   │  ├─ 取消事件订阅（自动）
   │  ├─ 注销命令（自动）
   │  └─ 释放资源
   └─ 清理 IPluginContext

5. 卸载阶段（Unload）
   ├─ 调用 OnUnloadAsync()  ← 最终清理
   └─ 卸载程序集
```

### **实现示例 1：使用 IPlugin**

```csharp
using NetherGate.API.Plugins;
using NetherGate.API.Events;

public class MyPlugin : IPlugin
{
    public PluginMetadata Metadata { get; set; } = null!;
    public PluginState State { get; set; }
    
    private IPluginContext _context = null!;
    private Timer? _heartbeatTimer;
    private DatabaseConnection? _database;

    public Task OnLoadAsync()
    {
        // 尽早初始化，不依赖外部资源
        Console.WriteLine("[MyPlugin] Loading...");
        return Task.CompletedTask;
    }

    public async Task OnEnableAsync()
    {
        _context.Logger.Info("MyPlugin is enabling...");
        
        // 1. 加载配置
        var config = await _context.ConfigManager.LoadConfigAsync<MyConfig>("config");
        
        // 2. 连接数据库
        _database = new DatabaseConnection(config.DatabaseUrl);
        await _database.ConnectAsync();
        
        // 3. 订阅事件（带优先级）
        _context.EventBus.Subscribe<PlayerJoinedEvent>(OnPlayerJoined, EventPriority.Normal);
        _context.EventBus.Subscribe<PlayerLeftEvent>(OnPlayerLeft, EventPriority.Normal);
        
        // 4. 注册命令
        _context.CommandManager.RegisterCommand(new MyCommand(_context));
        
        // 5. 启动定时任务
        _heartbeatTimer = new Timer(OnHeartbeat, null, 
            TimeSpan.Zero, TimeSpan.FromMinutes(1));
        
        _context.Logger.Info("MyPlugin enabled successfully");
    }

    public async Task OnDisableAsync()
    {
        _context.Logger.Info("MyPlugin is disabling...");
        
        // 1. 停止定时任务
        _heartbeatTimer?.Dispose();
        
        // 2. 保存数据
        await SaveAllPlayerDataAsync();
        
        // 3. 断开数据库
        await _database?.DisconnectAsync();
        
        // 4. 框架会自动取消事件订阅和命令注册
        
        _context.Logger.Info("MyPlugin disabled");
    }
    
    public Task OnUnloadAsync()
    {
        // 最终清理
        _database = null;
        return Task.CompletedTask;
    }

    private void OnHeartbeat(object? state)
    {
        _context.Logger.Debug("Heartbeat");
    }
}
```

### **实现示例 2：使用 PluginBase**（推荐）

```csharp
using NetherGate.API.Plugins;
using NetherGate.API.Events;

public class MyPlugin : PluginBase
{
    private Timer? _heartbeatTimer;
    private DatabaseConnection? _database;

    public override Task OnLoadAsync()
    {
        // 静态初始化
        Console.WriteLine("[MyPlugin] Loading...");
        return Task.CompletedTask;
    }

    public override async Task OnEnableAsync()
    {
        Logger.Info("MyPlugin is enabling...");
        
        // 1. 加载配置（使用 protected 属性）
        var config = await Config.LoadConfigAsync<MyConfig>("config");
        
        // 2. 连接数据库
        _database = new DatabaseConnection(config.DatabaseUrl);
        await _database.ConnectAsync();
        
        // 3. 订阅事件（使用 protected Events 属性）
        Events.Subscribe<PlayerJoinedEvent>(OnPlayerJoined, EventPriority.Normal);
        Events.Subscribe<ServerStartedEvent>(OnServerStarted, EventPriority.High);
        
        // 4. 注册命令（使用 protected Commands 属性）
        Commands.RegisterCommand(new MyCommand(this));
        
        // 5. 启动定时任务
        _heartbeatTimer = new Timer(OnHeartbeat, null, 
            TimeSpan.Zero, TimeSpan.FromMinutes(1));
        
        Logger.Info("MyPlugin enabled successfully");
    }

    public override async Task OnDisableAsync()
    {
        Logger.Info("MyPlugin is disabling...");
        
        _heartbeatTimer?.Dispose();
        await SaveAllPlayerDataAsync();
        await _database?.DisconnectAsync();
        
        Logger.Info("MyPlugin disabled");
    }
    
    public override Task OnUnloadAsync()
    {
        _database = null;
        return Task.CompletedTask;
    }
    
    private async Task OnPlayerJoined(PlayerJoinedEvent e)
    {
        Logger.Info($"{e.Player.Name} joined");
        
        var playerData = await _database!.LoadPlayerAsync(e.Player.Uuid);
        
        // 使用 protected GameDisplay 属性
        await GameDisplay.SendChatMessage(
            e.Player.Name, 
            $"§aWelcome back! You have {playerData.Points} points."
        );
    }
}
```

---

## 🔌 **IPluginContext 接口**

### **完整接口**

```csharp
public interface IPluginContext
{
    // ========== 核心服务 ==========
    
    /// <summary>
    /// 日志记录器
    /// </summary>
    ILogger Logger { get; }
    
    /// <summary>
    /// 事件总线
    /// </summary>
    IEventBus EventBus { get; }
    
    /// <summary>
    /// 命令管理器
    /// </summary>
    ICommandManager CommandManager { get; }
    
    /// <summary>
    /// 配置管理器
    /// </summary>
    IConfigManager ConfigManager { get; }
    
    /// <summary>
    /// 权限管理器
    /// </summary>
    IPermissionManager PermissionManager { get; }
    
    // ========== 插件管理 ==========
    
    /// <summary>
    /// 插件管理器
    /// </summary>
    IPluginManager PluginManager { get; }
    
    /// <summary>
    /// 插件元数据
    /// </summary>
    PluginMetadata Metadata { get; }
    
    /// <summary>
    /// 插件数据目录
    /// </summary>
    string DataDirectory { get; }
    
    // ========== 服务器交互 ==========
    
    /// <summary>
    /// 游戏显示 API
    /// </summary>
    IGameDisplayApi GameDisplayApi { get; }
    
    /// <summary>
    /// RCON 客户端
    /// </summary>
    IRconClient RconClient { get; }
    
    /// <summary>
    /// SMP 客户端
    /// </summary>
    ISmpApi SmpApi { get; }
    
    // ========== 数据读取 ==========
    
    /// <summary>
    /// 玩家数据读取器
    /// </summary>
    IPlayerDataReader PlayerDataReader { get; }
    
    /// <summary>
    /// 世界数据读取器
    /// </summary>
    IWorldDataReader WorldDataReader { get; }
    
    /// <summary>
    /// NBT 数据写入器
    /// </summary>
    INbtDataWriter NbtDataWriter { get; }
    
    // ========== 高级功能 ==========
    
    /// <summary>
    /// 文件监视器
    /// </summary>
    IFileWatcher FileWatcher { get; }
    
    /// <summary>
    /// 备份管理器
    /// </summary>
    IBackupManager BackupManager { get; }
    
    /// <summary>
    /// 性能监视器
    /// </summary>
    IPerformanceMonitor PerformanceMonitor { get; }
    
    /// <summary>
    /// 网络事件监听器
    /// </summary>
    INetworkEventListener NetworkEventListener { get; }
    
    /// <summary>
    /// 插件间通信
    /// </summary>
    IPluginMessenger Messenger { get; }
}
```

### **使用示例**

```csharp
public async Task OnEnableAsync(IPluginContext context)
{
    // 日志
    context.Logger.Info("插件启动");
    context.Logger.Warning("这是警告");
    context.Logger.Error("这是错误");
    context.Logger.Debug("调试信息");
    
    // 事件（带优先级）
    context.EventBus.Subscribe<PlayerJoinedEvent>(OnPlayerJoined, EventPriority.Normal);
    context.EventBus.Subscribe<ServerStartedEvent>(OnServerStarted, EventPriority.High);
    await context.EventBus.PublishAsync(new CustomEvent());
    
    // 命令
    context.CommandManager.RegisterCommand(new MyCommand(context));
    
    // 配置
    var config = await context.ConfigManager.LoadConfigAsync<MyConfig>("config");
    await context.ConfigManager.SaveConfigAsync("config", config);
    
    // 权限
    bool hasPermission = await context.PermissionManager
        .HasPermissionAsync("Steve", "myplugin.use");
    
    // 游戏显示
    await context.GameDisplayApi.SendChatMessage("Steve", "Hello!");
    await context.GameDisplayApi.ShowTitle("Steve", "Welcome", "Enjoy the server!", 10, 70, 20);
    
    // RCON 命令
    var result = await context.RconClient.SendCommandAsync("list");
    
    // SMP API
    var players = await context.SmpApi.GetOnlinePlayersAsync();
    
    // 数据读取
    var playerData = await context.PlayerDataReader.ReadPlayerDataAsync("Steve");
    var worldData = await context.WorldDataReader.ReadWorldDataAsync("world");
    
    // 插件间通信
    await context.Messenger.SendMessageAsync("OtherPlugin", "Hello", data);
}
```

---

## 📚 **相关文档**

- [配置文件管理](./配置文件.md)
- [命令系统](../02-核心功能/命令系统.md)
- [事件系统](../02-核心功能/事件系统.md)
- [权限系统](../02-核心功能/权限系统.md)
- [游戏显示 API](../04-高级功能/游戏显示API.md)

---

**文档维护者：** NetherGate 开发团队  
**最后更新：** 2025-10-05
