# 性能监控详解

NetherGate 提供了完善的性能监控 API，帮助开发者和服务器管理员实时了解服务器性能状况。

---

## 1. 性能监控概述

### 1.1 监控能力

NetherGate 的性能监控系统提供以下指标：

**服务器指标：**
- CPU 使用率（总体和服务器进程）
- 内存使用（已用/总量/百分比）
- TPS (Ticks Per Second)
- MSPT (Milliseconds Per Tick)

**网络指标：**
- 玩家数量（当前/峰值）
- 网络流量（上行/下行）

**世界指标：**
- 加载的区块数量
- 实体数量
- 方块实体（TileEntity）数量

### 1.2 监控架构

```
┌─────────────────────────────────────────┐
│        Performance Monitor              │
│  ┌───────────┐  ┌──────────────────┐   │
│  │  Metrics  │  │  Data Collection │   │
│  │ Collector │──│    & Storage     │   │
│  └───────────┘  └──────────────────┘   │
│         │              │                │
│         ▼              ▼                │
│  ┌───────────┐  ┌──────────────────┐   │
│  │  Real-time│  │    Historical    │   │
│  │   Query   │  │  Data (Optional) │   │
│  └───────────┘  └──────────────────┘   │
└─────────────────────────────────────────┘
          │                  │
          ▼                  ▼
   ┌──────────┐      ┌──────────────┐
   │ Plugins  │      │ External APIs│
   └──────────┘      └──────────────┘
```

---

## 2. 使用性能监控 API

### 2.1 基础使用

```csharp
using NetherGate.API.Plugins;
using NetherGate.API.Monitoring;

public class PerformancePlugin : IPlugin
{
    private IPerformanceMonitor _perfMonitor;

    public void OnEnable()
    {
        _perfMonitor = Context.PerformanceMonitor;
        
        // 获取当前性能快照
        var snapshot = _perfMonitor.GetSnapshot();
        
        Logger.Info($"TPS: {snapshot.Tps:F2}");
        Logger.Info($"内存使用: {snapshot.Memory.UsedMB} MB / {snapshot.Memory.TotalMB} MB ({snapshot.Memory.UsagePercent:F1}%)");
        Logger.Info($"CPU 使用率: {snapshot.CpuUsage:F1}%");
        Logger.Info($"磁盘使用: {snapshot.Disk.UsedGB} GB / {snapshot.Disk.TotalGB} GB ({snapshot.Disk.UsagePercent:F1}%)");
    }
}
```

### 2.2 性能快照详解

`PerformanceSnapshot` 包含以下字段：

```csharp
public class PerformanceSnapshot
{
    // 时间戳
    public DateTime Timestamp { get; init; }
    
    // CPU 使用率 (0-100%)
    public double CpuUsage { get; init; }
    
    // 内存使用情况
    public MemoryUsage Memory { get; init; }
    
    // 磁盘使用情况
    public DiskUsage Disk { get; init; }
    
    // 服务器进程信息
    public ProcessInfo? ServerProcess { get; init; }
    
    // TPS (每秒滴答数，Minecraft 特有)
    public double? Tps { get; init; }
}

public class MemoryUsage
{
    public long UsedMB { get; init; }           // 已使用内存 (MB)
    public long TotalMB { get; init; }          // 总内存 (MB)
    public double UsagePercent { get; }         // 内存使用率 (0-100%)
    public long AvailableMB { get; }            // 可用内存 (MB)
}

public class DiskUsage
{
    public long UsedGB { get; init; }           // 已使用磁盘空间 (GB)
    public long TotalGB { get; init; }          // 总磁盘空间 (GB)
    public double UsagePercent { get; }         // 使用率 (0-100%)
    public long AvailableGB { get; }            // 可用磁盘空间 (GB)
}

public class ProcessInfo
{
    public int ProcessId { get; init; }         // 进程 ID
    public string ProcessName { get; init; }    // 进程名称
    public int ThreadCount { get; init; }       // 线程数
    public TimeSpan Uptime { get; init; }       // 已运行时间
    public long MemoryMB { get; init; }         // 进程内存使用 (MB)
}
```

### 2.3 实时监控

#### 定时采集

```csharp
using System.Timers;

public class MonitorPlugin : IPlugin
{
    private Timer _monitorTimer;
    private IPerformanceMonitor _perfMonitor;

    public void OnEnable()
    {
        _perfMonitor = Context.PerformanceMonitor;
        
        // 每 5 秒采集一次
        _monitorTimer = new Timer(5000);
        _monitorTimer.Elapsed += OnMonitorTick;
        _monitorTimer.Start();
    }

    private void OnMonitorTick(object sender, ElapsedEventArgs e)
    {
        var snapshot = _perfMonitor.GetSnapshot();
        
        // 检查性能异常
        if (snapshot.Tps.HasValue && snapshot.Tps.Value < 18.0)
        {
            Logger.Warning($"TPS 过低: {snapshot.Tps.Value:F2}");
        }
        
        if (snapshot.CpuUsage > 80)
        {
            Logger.Warning($"CPU 使用率过高: {snapshot.CpuUsage:F1}%");
        }
        
        if (snapshot.Memory.UsagePercent > 90)
        {
            Logger.Warning($"内存使用率过高: {snapshot.Memory.UsagePercent:F1}%");
        }
        
        if (snapshot.Disk.UsagePercent > 90)
        {
            Logger.Warning($"磁盘空间不足: {snapshot.Disk.UsagePercent:F1}%");
        }
    }

    public void OnDisable()
    {
        _monitorTimer?.Stop();
        _monitorTimer?.Dispose();
    }
}
```

#### 性能预警系统

```csharp
public class PerformanceAlertSystem
{
    private readonly ILogger _logger;
    private readonly IPerformanceMonitor _monitor;
    
    // 阈值配置
    public double TpsWarningThreshold { get; set; } = 18.0;
    public double TpsCriticalThreshold { get; set; } = 15.0;
    public double CpuWarningThreshold { get; set; } = 80.0;
    public double CpuCriticalThreshold { get; set; } = 95.0;
    public double MemoryWarningThreshold { get; set; } = 80.0;
    public double MemoryCriticalThreshold { get; set; } = 90.0;
    public double DiskWarningThreshold { get; set; } = 80.0;
    public double DiskCriticalThreshold { get; set; } = 90.0;
    
    public void CheckPerformance()
    {
        var snapshot = _monitor.GetSnapshot();
        
        // TPS 检查
        if (snapshot.Tps.HasValue)
        {
            if (snapshot.Tps.Value < TpsCriticalThreshold)
            {
                _logger.Error($"[严重] TPS 过低: {snapshot.Tps.Value:F2} (阈值: {TpsCriticalThreshold})");
                // 触发紧急措施
            }
            else if (snapshot.Tps.Value < TpsWarningThreshold)
            {
                _logger.Warning($"[警告] TPS 偏低: {snapshot.Tps.Value:F2} (阈值: {TpsWarningThreshold})");
            }
        }
        
        // CPU 检查
        if (snapshot.CpuUsage > CpuCriticalThreshold)
        {
            _logger.Error($"[严重] CPU 使用率过高: {snapshot.CpuUsage:F1}% (阈值: {CpuCriticalThreshold}%)");
        }
        else if (snapshot.CpuUsage > CpuWarningThreshold)
        {
            _logger.Warning($"[警告] CPU 使用率偏高: {snapshot.CpuUsage:F1}% (阈值: {CpuWarningThreshold}%)");
        }
        
        // 内存检查
        if (snapshot.Memory.UsagePercent > MemoryCriticalThreshold)
        {
            _logger.Error($"[严重] 内存使用率过高: {snapshot.Memory.UsagePercent:F1}% (阈值: {MemoryCriticalThreshold}%)");
            // 建议执行 GC 或清理
        }
        else if (snapshot.Memory.UsagePercent > MemoryWarningThreshold)
        {
            _logger.Warning($"[警告] 内存使用率偏高: {snapshot.Memory.UsagePercent:F1}% (阈值: {MemoryWarningThreshold}%)");
        }
        
        // 磁盘检查
        if (snapshot.Disk.UsagePercent > DiskCriticalThreshold)
        {
            _logger.Error($"[严重] 磁盘空间不足: {snapshot.Disk.UsagePercent:F1}% (阈值: {DiskCriticalThreshold}%)");
        }
        else if (snapshot.Disk.UsagePercent > DiskWarningThreshold)
        {
            _logger.Warning($"[警告] 磁盘空间偏低: {snapshot.Disk.UsagePercent:F1}% (阈值: {DiskWarningThreshold}%)");
        }
    }
}
```

### 2.4 历史数据记录

```csharp
using System.Collections.Generic;
using System.Linq;

public class PerformanceRecorder
{
    private readonly List<PerformanceSnapshot> _history = new();
    private readonly int _maxHistorySize = 720; // 1 小时数据（每 5 秒一次）

    public void RecordSnapshot(PerformanceSnapshot snapshot)
    {
        _history.Add(snapshot);
        
        // 限制历史记录大小
        if (_history.Count > _maxHistorySize)
        {
            _history.RemoveAt(0);
        }
    }

    // 获取平均值
    public PerformanceStatistics GetStatistics(TimeSpan duration)
    {
        var cutoff = DateTime.Now - duration;
        var recent = _history.Where(s => s.Timestamp > cutoff).ToList();
        
        if (recent.Count == 0)
            return null;
        
        return new PerformanceStatistics
        {
            AvgTps = recent.Where(s => s.Tps.HasValue).Average(s => s.Tps!.Value),
            MinTps = recent.Where(s => s.Tps.HasValue).Min(s => s.Tps!.Value),
            MaxTps = recent.Where(s => s.Tps.HasValue).Max(s => s.Tps!.Value),
            
            AvgCpuUsage = recent.Average(s => s.CpuUsage),
            MaxCpuUsage = recent.Max(s => s.CpuUsage),
            
            AvgMemoryUsage = recent.Average(s => s.Memory.UsagePercent),
            MaxMemoryUsage = recent.Max(s => s.Memory.UsagePercent),
            
            AvgDiskUsage = recent.Average(s => s.Disk.UsagePercent),
            MaxDiskUsage = recent.Max(s => s.Disk.UsagePercent),
            
            SampleCount = recent.Count,
            Duration = duration
        };
    }

    // 导出到 CSV
    public void ExportToCsv(string filePath)
    {
        var csv = new StringBuilder();
        csv.AppendLine("Timestamp,TPS,CpuUsage,MemoryUsedMB,MemoryTotalMB,MemoryUsage%,DiskUsedGB,DiskTotalGB,DiskUsage%");
        
        foreach (var snapshot in _history)
        {
            csv.AppendLine($"{snapshot.Timestamp:yyyy-MM-dd HH:mm:ss}," +
                          $"{(snapshot.Tps.HasValue ? snapshot.Tps.Value.ToString("F2") : "N/A")}," +
                          $"{snapshot.CpuUsage:F2}," +
                          $"{snapshot.Memory.UsedMB}," +
                          $"{snapshot.Memory.TotalMB}," +
                          $"{snapshot.Memory.UsagePercent:F2}," +
                          $"{snapshot.Disk.UsedGB}," +
                          $"{snapshot.Disk.TotalGB}," +
                          $"{snapshot.Disk.UsagePercent:F2}");
        }
        
        File.WriteAllText(filePath, csv.ToString());
    }
}

public class PerformanceStatistics
{
    public double AvgTps { get; set; }
    public double MinTps { get; set; }
    public double MaxTps { get; set; }
    
    public double AvgCpuUsage { get; set; }
    public double MaxCpuUsage { get; set; }
    
    public double AvgMemoryUsage { get; set; }
    public double MaxMemoryUsage { get; set; }
    
    public double AvgDiskUsage { get; set; }
    public double MaxDiskUsage { get; set; }
    
    public int SampleCount { get; set; }
    public TimeSpan Duration { get; set; }
}
```

---

## 3. Spark 性能分析集成

NetherGate 集成了 [Spark](https://spark.lucko.me/) 性能分析工具。

### 3.1 启用 Spark

在 `nethergate-config.yaml` 中配置：

```yaml
spark:
  enabled: true
  port: 8010
  token: "your-secret-token"
```

### 3.2 使用 Spark API

> **注意:** Spark 是一个独立的性能分析工具，需要单独安装和配置。NetherGate 的 `IPerformanceMonitor` 主要提供基本的性能快照功能。

**Spark 的典型用法（命令行）：**

```bash
# 通过 RCON 或控制台使用 Spark 命令
spark profiler start
spark profiler stop
spark heapdump
```

**在插件中触发 Spark 分析（通过 RCON）：**

```csharp
using NetherGate.API.Protocol;

public class SparkIntegration : IPlugin
{
    private IRconClient _rcon;

    public void OnEnable()
    {
        _rcon = Context.RconClient;
        
        // 启动性能分析
        RegisterCommand("profile", async (args) =>
        {
            await _rcon.SendCommandAsync("spark profiler start");
            Logger.Info("性能分析已启动，运行中...");
            
            // 等待 30 秒
            await Task.Delay(30000);
            
            await _rcon.SendCommandAsync("spark profiler stop");
            Logger.Info("性能分析已停止，查看结果: https://spark.lucko.me/");
        });
        
        // 生成堆转储
        RegisterCommand("heapdump", async (args) =>
        {
            await _rcon.SendCommandAsync("spark heapdump");
            Logger.Info("堆转储已生成");
        });
    }
}
```

### 3.3 Spark 功能

**性能分析（Profiler）：**
- CPU 分析：找出占用 CPU 最多的代码
- 内存分配分析：检测内存泄漏
- Tick 分析：定位卡顿来源

**堆转储（Heap Dump）：**
- 生成 JVM 堆快照
- 分析内存使用情况
- 查找内存泄漏

**健康检查（Health Check）：**
- 自动检测常见性能问题
- 提供优化建议

---

## 4. 性能优化建议

### 4.1 识别性能瓶颈

#### 低 TPS 问题

```csharp
public void DiagnoseLowTps(PerformanceSnapshot snapshot)
{
    if (snapshot.Tps.HasValue && snapshot.Tps.Value < 18.0)
    {
        Logger.Warning($"TPS 过低: {snapshot.Tps.Value:F2}");
        
        // 可能原因诊断
        if (snapshot.CpuUsage > 90)
        {
            Logger.Info("原因: CPU 使用率过高");
            Logger.Info("建议: 检查插件性能或升级硬件");
        }
        
        if (snapshot.Memory.UsagePercent > 85)
        {
            Logger.Info("原因: 内存使用率高，可能导致频繁GC");
            Logger.Info("建议: 增加Java堆内存(-Xmx)或优化内存使用");
        }
        
        if (snapshot.Disk.UsagePercent > 90)
        {
            Logger.Info("原因: 磁盘空间不足可能影响性能");
            Logger.Info("建议: 清理磁盘空间");
        }
        
        Logger.Info("通用建议: 使用 Spark profiler 定位性能瓶颈");
    }
}
```

#### 高内存使用

```csharp
public void DiagnoseHighMemory(PerformanceSnapshot snapshot)
{
    if (snapshot.Memory.UsagePercent > 80)
    {
        Logger.Warning($"内存使用率高: {snapshot.Memory.UsagePercent:F1}% ({snapshot.Memory.UsedMB} MB / {snapshot.Memory.TotalMB} MB)");
        
        // 建议措施
        Logger.Info("建议:");
        Logger.Info("1. 减少视距和加载的区块");
        Logger.Info("2. 清理不必要的实体和掉落物");
        Logger.Info("3. 优化插件内存使用");
        Logger.Info("4. 考虑增加 Java 堆内存 (-Xmx)");
        
        // 触发垃圾回收（谨慎使用）
        if (snapshot.Memory.UsagePercent > 90)
        {
            Logger.Warning("内存危急，触发 GC");
            GC.Collect(GC.MaxGeneration, GCCollectionMode.Aggressive);
        }
    }
}
```

### 4.2 插件性能优化

#### 异步操作

```csharp
// ❌ 错误：在主线程执行耗时操作
public void OnPlayerJoin(PlayerJoinEvent e)
{
    var data = LoadPlayerDataFromDatabase(e.PlayerName); // 阻塞主线程！
    // ...
}

// ✅ 正确：使用异步操作
public async void OnPlayerJoin(PlayerJoinEvent e)
{
    var data = await LoadPlayerDataFromDatabaseAsync(e.PlayerName);
    // ...
}
```

#### 缓存机制

```csharp
public class CachedDataManager
{
    private readonly Dictionary<string, (DateTime, PlayerData)> _cache = new();
    private readonly TimeSpan _cacheExpiry = TimeSpan.FromMinutes(5);

    public async Task<PlayerData> GetPlayerDataAsync(string playerName)
    {
        // 检查缓存
        if (_cache.TryGetValue(playerName, out var cached))
        {
            if (DateTime.Now - cached.Item1 < _cacheExpiry)
            {
                return cached.Item2; // 返回缓存数据
            }
        }
        
        // 缓存未命中或过期，加载数据
        var data = await LoadFromDatabaseAsync(playerName);
        _cache[playerName] = (DateTime.Now, data);
        
        return data;
    }

    public void InvalidateCache(string playerName)
    {
        _cache.Remove(playerName);
    }
}
```

#### 批量操作

```csharp
// ❌ 错误：逐个处理
foreach (var player in players)
{
    await SavePlayerDataAsync(player); // 多次 I/O 操作
}

// ✅ 正确：批量处理
await SavePlayerDataBatchAsync(players); // 一次性保存
```

#### 定时器优化

```csharp
// ❌ 错误：高频定时器
var timer = new Timer(100); // 每 100ms 执行一次，性能消耗大

// ✅ 正确：合理的间隔
var timer = new Timer(5000); // 每 5 秒执行一次
```

### 4.3 服务器配置优化

#### JVM 参数优化

```bash
# 推荐的 Java 启动参数（4GB 内存）
java -Xms4G -Xmx4G \
     -XX:+UseG1GC \
     -XX:+ParallelRefProcEnabled \
     -XX:MaxGCPauseMillis=200 \
     -XX:+UnlockExperimentalVMOptions \
     -XX:+DisableExplicitGC \
     -XX:G1HeapRegionSize=16M \
     -XX:G1NewSizePercent=30 \
     -XX:G1MaxNewSizePercent=40 \
     -XX:G1HeapWastePercent=5 \
     -XX:G1MixedGCCountTarget=4 \
     -XX:InitiatingHeapOccupancyPercent=15 \
     -XX:G1MixedGCLiveThresholdPercent=90 \
     -XX:G1RSetUpdatingPauseTimePercent=5 \
     -jar server.jar nogui
```

#### server.properties 优化

```properties
# 视距（建议 6-10）
view-distance=8
simulation-distance=8

# 网络优化
network-compression-threshold=256
max-tick-time=60000

# 生成优化
spawn-npcs=true
spawn-animals=true
spawn-monsters=true
entity-broadcast-range-percentage=100
```

---

## 5. 性能监控面板

### 5.1 Web 面板

NetherGate 提供 WebSocket API，可以创建实时监控面板：

```csharp
using NetherGate.API.Network;

public class PerformanceWebSocketHandler
{
    private readonly IPerformanceMonitor _monitor;
    private Timer _updateTimer;

    public void StartBroadcast(IWebSocketServer ws)
    {
        _updateTimer = new Timer(1000); // 每秒更新
        _updateTimer.Elapsed += (s, e) =>
        {
            var snapshot = _monitor.GetSnapshot();
            var json = JsonSerializer.Serialize(new
            {
                type = "performance_update",
                data = snapshot
            });
            
            ws.BroadcastAsync(json);
        };
        _updateTimer.Start();
    }
}
```

**前端示例（HTML + JavaScript）：**

```html
<!DOCTYPE html>
<html>
<head>
    <title>NetherGate 性能监控</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <h1>服务器性能监控</h1>
    
    <div>
        <strong>TPS:</strong> <span id="tps">--</span>
        <strong>CPU:</strong> <span id="mspt">--</span>
        <strong>内存:</strong> <span id="memory">--</span>
        <strong>进程:</strong> <span id="players">--</span>
    </div>
    
    <canvas id="tpsChart" width="800" height="200"></canvas>

    <script>
        const ws = new WebSocket('ws://localhost:8080');
        const tpsData = [];
        const maxDataPoints = 60;

        const chart = new Chart(document.getElementById('tpsChart'), {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'TPS',
                    data: tpsData,
                    borderColor: 'rgb(75, 192, 192)',
                    tension: 0.1
                }]
            },
            options: {
                scales: {
                    y: {
                        beginAtZero: true,
                        max: 20
                    }
                }
            }
        });

        ws.onmessage = (event) => {
            const msg = JSON.parse(event.data);
            if (msg.type === 'performance_update') {
                const data = msg.data;
                
                // 更新文本
                document.getElementById('tps').textContent = data.tps ? data.tps.toFixed(2) : 'N/A';
                document.getElementById('mspt').textContent = data.cpuUsage.toFixed(1) + '%';
                document.getElementById('memory').textContent = 
                    `${data.memory.usedMB} MB / ${data.memory.totalMB} MB (${data.memory.usagePercent.toFixed(1)}%)`;
                document.getElementById('players').textContent = 
                    data.serverProcess ? `PID: ${data.serverProcess.processId}` : 'N/A';
                
                // 更新图表
                tpsData.push(data.tps);
                chart.data.labels.push(new Date().toLocaleTimeString());
                
                if (tpsData.length > maxDataPoints) {
                    tpsData.shift();
                    chart.data.labels.shift();
                }
                
                chart.update();
            }
        };
    </script>
</body>
</html>
```

### 5.2 游戏内面板

使用 BossBar 或 ActionBar 显示性能信息：

```csharp
using NetherGate.API.Protocol;

public class IngamePerformanceDisplay
{
    private readonly IGameDisplayApi _display;
    private readonly IPerformanceMonitor _monitor;

    public async Task ShowPerformanceBossBar(string playerName)
    {
        var snapshot = _monitor.GetSnapshot();
        
        if (snapshot.Tps.HasValue)
        {
            // TPS 进度条（0-20）
            var progress = (float)(snapshot.Tps.Value / 20.0);
            var color = snapshot.Tps.Value >= 19 ? BossBarColor.Green :
                        snapshot.Tps.Value >= 15 ? BossBarColor.Yellow : BossBarColor.Red;
            
            await _display.ShowBossBarAsync(
                playerName,
                "performance_bar",
                $"TPS: {snapshot.Tps.Value:F1} | CPU: {snapshot.CpuUsage:F1}% | 内存: {snapshot.Memory.UsagePercent:F0}%",
                progress,
                color,
                BossBarStyle.Progress
            );
        }
    }

    public async Task ShowPerformanceActionBar(string playerName)
    {
        var snapshot = _monitor.GetSnapshot();
        var message = $"TPS: {(snapshot.Tps.HasValue ? snapshot.Tps.Value.ToString("F1") : "N/A")} | " +
                     $"CPU: {snapshot.CpuUsage:F1}% | " +
                     $"内存: {snapshot.Memory.UsagePercent:F0}% | " +
                     $"磁盘: {snapshot.Disk.UsagePercent:F0}%";
        
        await _display.SendActionBarAsync(playerName, message);
    }
}
```

---

## 6. 性能测试

### 6.1 压力测试

```csharp
public class StressTest
{
    public async Task RunEntityStressTest(int entityCount)
    {
        Logger.Info($"开始实体压力测试：生成 {entityCount} 个实体");
        
        var before = _monitor.GetSnapshot();
        
        for (int i = 0; i < entityCount; i++)
        {
            await _gameDisplay.SummonEntityAsync(
                "minecraft:zombie",
                0, 100, 0,
                null
            );
        }
        
        await Task.Delay(10000); // 等待 10 秒
        
        var after = _monitor.GetSnapshot();
        
        Logger.Info($"测试结果:");
        Logger.Info($"  TPS: {(before.Tps.HasValue ? before.Tps.Value.ToString("F2") : "N/A")} -> {(after.Tps.HasValue ? after.Tps.Value.ToString("F2") : "N/A")}");
        Logger.Info($"  CPU: {before.CpuUsage:F2}% -> {after.CpuUsage:F2}%");
        Logger.Info($"  内存: {before.Memory.UsagePercent:F2}% -> {after.Memory.UsagePercent:F2}%");
    }
}
```

### 6.2 性能基准

```csharp
public class PerformanceBenchmark
{
    public void RunBenchmark()
    {
        // 测试命令执行速度
        var sw = Stopwatch.StartNew();
        for (int i = 0; i < 1000; i++)
        {
            Context.RconClient.SendCommandAsync("list");
        }
        sw.Stop();
        Logger.Info($"1000 次命令执行耗时: {sw.ElapsedMilliseconds} ms");
        
        // 测试配置读写速度
        sw.Restart();
        for (int i = 0; i < 1000; i++)
        {
            var config = Context.ConfigManager.LoadConfig<MyConfig>();
            Context.ConfigManager.SaveConfig(config);
        }
        sw.Stop();
        Logger.Info($"1000 次配置读写耗时: {sw.ElapsedMilliseconds} ms");
    }
}
```

---

## 7. 常见问题

### Q1: TPS 显示为 -1 或 0？

**A:** 这通常表示性能监控尚未初始化或服务器尚未完全启动。等待服务器完全加载后再查询。

### Q2: 如何持久化性能数据？

**A:** 使用 `PerformanceRecorder` 定期保存到文件或数据库：

```csharp
_recorder.ExportToCsv($"performance-{DateTime.Now:yyyyMMdd}.csv");
```

### Q3: Spark 无法访问？

**A:** 检查：
1. `spark.enabled = true`
2. 防火墙开放端口 8010
3. 服务器已完全启动

---

## 参考资源

- [Spark 官方文档](https://spark.lucko.me/docs)
- [Minecraft 服务器性能优化指南](https://www.spigotmc.org/wiki/server-optimization/)
- [JVM 参数优化](https://aikar.co/2018/07/02/tuning-the-jvm-g1gc-garbage-collector-flags-for-minecraft/)

