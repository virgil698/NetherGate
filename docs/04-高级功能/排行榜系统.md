# 排行榜系统

NetherGate 提供了灵活的排行榜系统，可以轻松创建和管理各种类型的排行榜。

## 功能特性

- ✅ **多种排行榜类型** - 支持最高分、最低分、累计分数
- ✅ **实时更新** - 分数和排名实时计算和更新
- ✅ **事件通知** - 分数更新和排名变化事件
- ✅ **持久化存储** - 自动保存和加载排行榜数据
- ✅ **灵活的数据结构** - 支持自定义元数据

## 排行榜类型

### HighestScore（最高分）
分数越高，排名越靠前。适合击杀数、经验值等。

### LowestScore（最低分）
分数越低，排名越靠前。适合速通时间、死亡次数等。

### Accumulative（累计分数）
累计所有分数，适合经验值、在线时长等。

## 基本用法

### 创建排行榜

```csharp
// 创建最高分排行榜
await context.LeaderboardSystem.CreateLeaderboardAsync(
    "kills",                    // 排行榜名称（唯一标识）
    LeaderboardType.HighestScore,  // 类型
    "击杀排行榜"                 // 显示名称（可选）
);

// 创建速通排行榜（时间越短越好）
await context.LeaderboardSystem.CreateLeaderboardAsync(
    "speedrun_dragon",
    LeaderboardType.LowestScore,
    "末影龙速通"
);
```

### 更新分数

```csharp
// 设置玩家分数
await context.LeaderboardSystem.UpdateScoreAsync(
    "kills",                    // 排行榜名称
    playerUuid,                 // 玩家 UUID
    100,                        // 分数
    "Player123"                 // 玩家名称（可选）
);

// 增加分数（适用于累计类型）
await context.LeaderboardSystem.IncrementScoreAsync(
    "kills",
    playerUuid,
    10,                         // 增加的分数
    "Player123"
);
```

### 查询排行榜

```csharp
// 获取前 10 名
var topPlayers = await context.LeaderboardSystem.GetTopPlayersAsync("kills", 10);

foreach (var entry in topPlayers)
{
    context.Logger.Info($"#{entry.Rank} {entry.PlayerName}: {entry.Score}");
}

// 获取玩家排名
var rank = await context.LeaderboardSystem.GetPlayerRankAsync("kills", playerUuid);
context.Logger.Info($"你的排名: #{rank}");

// 获取玩家分数
var score = await context.LeaderboardSystem.GetPlayerScoreAsync("kills", playerUuid);
context.Logger.Info($"你的分数: {score}");
```

### 重置排行榜

```csharp
// 重置排行榜（清空所有数据）
await context.LeaderboardSystem.ResetLeaderboardAsync("kills");
```

### 删除排行榜

```csharp
// 删除排行榜
await context.LeaderboardSystem.DeleteLeaderboardAsync("kills");
```

## 事件系统

### 监听分数更新

```csharp
public void OnEnable(IPluginContext context)
{
    context.LeaderboardSystem.ScoreUpdated += OnScoreUpdated;
}

private async void OnScoreUpdated(object? sender, ScoreUpdatedEventArgs e)
{
    context.Logger.Info($"{e.PlayerName} 的分数从 {e.OldScore} 更新到 {e.NewScore}");
    
    // 通知玩家
    await context.GameDisplay.SendActionBarAsync(
        e.PlayerName,
        $"§a分数: {e.NewScore} (+{e.NewScore - e.OldScore})"
    );
}
```

### 监听排名变化

```csharp
public void OnEnable(IPluginContext context)
{
    context.LeaderboardSystem.RankChanged += OnRankChanged;
}

private async void OnRankChanged(object? sender, RankChangedEventArgs e)
{
    if (e.NewRank < e.OldRank)
    {
        // 排名上升
        await context.GameDisplay.SendTitleAsync(
            e.PlayerName,
            "§6§l排名上升！",
            $"§e#{e.OldRank} → #{e.NewRank}"
        );
    }
}
```

## 实战示例

### 示例 1: 击杀排行榜

```csharp
public class KillLeaderboardPlugin : IPlugin
{
    private IPluginContext _context;

    public void OnEnable(IPluginContext context)
    {
        _context = context;
        
        // 创建击杀排行榜
        await context.LeaderboardSystem.CreateLeaderboardAsync(
            "kills",
            LeaderboardType.HighestScore,
            "击杀排行"
        );
        
        // 订阅玩家击杀事件
        context.EventBus.Subscribe<PlayerKilledMobEvent>(OnPlayerKilledMob);
        
        // 监听排名变化
        context.LeaderboardSystem.RankChanged += OnRankChanged;
    }

    private async void OnPlayerKilledMob(PlayerKilledMobEvent e)
    {
        // 增加击杀数
        await _context.LeaderboardSystem.IncrementScoreAsync(
            "kills",
            e.PlayerUuid,
            1,
            e.PlayerName
        );
    }

    private async void OnRankChanged(object? sender, RankChangedEventArgs e)
    {
        if (e.NewRank <= 3 && e.NewRank < e.OldRank)
        {
            // 进入前三名
            await _context.GameDisplay.SendChatMessageAsync(
                "@a",
                $"§6{e.PlayerName} 进入击杀榜前三名！ (#{e.NewRank})"
            );
        }
    }

    public void OnDisable()
    {
        // 清理
    }
}
```

### 示例 2: 速通排行榜

```csharp
public class SpeedrunLeaderboardPlugin : IPlugin
{
    private IPluginContext _context;
    private readonly Dictionary<string, DateTime> _runStarts = new();

    public void OnEnable(IPluginContext context)
    {
        _context = context;
        
        // 创建速通排行榜
        await context.LeaderboardSystem.CreateLeaderboardAsync(
            "speedrun_dragon",
            LeaderboardType.LowestScore,  // 时间越短越好
            "末影龙速通"
        );
        
        // 订阅成就事件
        context.AdvancementTracker.AdvancementCompleted += OnAdvancementCompleted;
    }

    private async void OnAdvancementCompleted(object? sender, AdvancementCompletedEventArgs e)
    {
        // 检查是否击败了末影龙
        if (e.AdvancementId == "minecraft:end/kill_dragon")
        {
            if (_runStarts.TryGetValue(e.PlayerUuid, out var startTime))
            {
                var duration = (DateTime.UtcNow - startTime).TotalSeconds;
                
                // 更新排行榜
                await _context.LeaderboardSystem.UpdateScoreAsync(
                    "speedrun_dragon",
                    e.PlayerUuid,
                    duration,
                    e.PlayerName
                );
                
                // 获取排名
                var rank = await _context.LeaderboardSystem.GetPlayerRankAsync(
                    "speedrun_dragon",
                    e.PlayerUuid
                );
                
                await _context.GameDisplay.SendTitleAsync(
                    e.PlayerName,
                    "§6§l速通完成！",
                    $"§e用时: {TimeSpan.FromSeconds(duration):hh\\:mm\\:ss} (#{rank})"
                );
            }
        }
    }
}
```

### 示例 3: 多维度排行榜

```csharp
public class ComprehensiveLeaderboardPlugin : IPlugin
{
    private IPluginContext _context;

    public void OnEnable(IPluginContext context)
    {
        _context = context;
        
        // 创建多个排行榜
        await CreateLeaderboards();
        
        // 订阅统计更新事件
        context.StatisticsTracker.StatisticsUpdated += OnStatisticsUpdated;
    }

    private async Task CreateLeaderboards()
    {
        var leaderboards = new[]
        {
            ("playtime", LeaderboardType.HighestScore, "在线时长"),
            ("mining", LeaderboardType.HighestScore, "挖矿排行"),
            ("deaths", LeaderboardType.LowestScore, "死亡次数"),
            ("travel", LeaderboardType.HighestScore, "旅行距离")
        };

        foreach (var (name, type, displayName) in leaderboards)
        {
            await _context.LeaderboardSystem.CreateLeaderboardAsync(name, type, displayName);
        }
    }

    private async void OnStatisticsUpdated(object? sender, StatisticsUpdatedEventArgs e)
    {
        var stats = await _context.StatisticsTracker.GetPlayerStatisticsAsync(e.PlayerUuid);
        
        if (stats != null)
        {
            // 更新在线时长排行榜
            await _context.LeaderboardSystem.UpdateScoreAsync(
                "playtime",
                e.PlayerUuid,
                stats.PlayTime,
                e.PlayerName
            );
            
            // 更新挖矿排行榜
            var totalMined = stats.MinedBlocks.Values.Sum();
            await _context.LeaderboardSystem.UpdateScoreAsync(
                "mining",
                e.PlayerUuid,
                totalMined,
                e.PlayerName
            );
            
            // 更新死亡排行榜
            await _context.LeaderboardSystem.UpdateScoreAsync(
                "deaths",
                e.PlayerUuid,
                stats.TotalDeaths,
                e.PlayerName
            );
            
            // 更新旅行距离排行榜
            var totalTravel = stats.TravelDistances.Values.Sum();
            await _context.LeaderboardSystem.UpdateScoreAsync(
                "travel",
                e.PlayerUuid,
                totalTravel,
                e.PlayerName
            );
        }
    }
}
```

### 示例 4: 排行榜显示面板

```csharp
public class LeaderboardDisplayPlugin : IPlugin
{
    private IPluginContext _context;

    public void OnEnable(IPluginContext context)
    {
        _context = context;
        
        // 注册命令
        context.CommandManager.RegisterCommand(new ShowLeaderboardCommand(context));
    }

    private class ShowLeaderboardCommand : ICommand
    {
        private readonly IPluginContext _context;

        public ShowLeaderboardCommand(IPluginContext context)
        {
            _context = context;
        }

        public string Name => "leaderboard";
        public string Description => "查看排行榜";
        public string Usage => "/leaderboard <名称>";
        public List<string> Aliases => new() { "lb", "top" };
        public string PluginId => "LeaderboardDisplay";
        public string? Permission => null;

        public async Task<CommandResult> ExecuteAsync(ICommandSender sender, string[] args)
        {
            if (args.Length == 0)
            {
                return CommandResult.Fail("用法: /leaderboard <名称>");
            }

            var leaderboardName = args[0];
            var topPlayers = await _context.LeaderboardSystem.GetTopPlayersAsync(
                leaderboardName, 
                10
            );

            if (topPlayers.Count == 0)
            {
                return CommandResult.Fail($"排行榜 '{leaderboardName}' 不存在或为空");
            }

            sender.SendMessage($"§6§l=== {leaderboardName} 排行榜 ===");
            foreach (var entry in topPlayers)
            {
                var medal = entry.Rank switch
                {
                    1 => "🥇",
                    2 => "🥈",
                    3 => "🥉",
                    _ => $"#{entry.Rank}"
                };
                
                sender.SendMessage($"{medal} §e{entry.PlayerName}§f: §a{entry.Score:F2}");
            }

            return CommandResult.Ok();
        }
    }
}
```

## WebSocket 实时推送

结合 WebSocket 数据广播器，可以实时推送排行榜到网页：

```csharp
public void OnEnable(IPluginContext context)
{
    // 订阅排名变化事件
    context.LeaderboardSystem.RankChanged += async (sender, e) =>
    {
        // 获取最新排行榜
        var topPlayers = await context.LeaderboardSystem.GetTopPlayersAsync(
            e.LeaderboardName, 
            10
        );
        
        // 通过 WebSocket 推送
        await context.DataBroadcaster.BroadcastAsync("leaderboard", new
        {
            leaderboard = e.LeaderboardName,
            players = topPlayers
        });
    };
}
```

## 数据持久化

排行榜数据自动保存到 `data/leaderboards/<name>.json`：

```json
{
  "Name": "kills",
  "DisplayName": "击杀排行",
  "Type": "HighestScore",
  "Entries": [
    {
      "Rank": 1,
      "PlayerUuid": "...",
      "PlayerName": "Player1",
      "Score": 1000,
      "LastUpdated": "2025-10-08T10:00:00Z"
    }
  ],
  "CreatedAt": "2025-10-01T00:00:00Z",
  "LastUpdated": "2025-10-08T10:00:00Z"
}
```

## 最佳实践

1. **合理命名** - 使用有意义的排行榜名称
2. **选择正确的类型** - 根据业务逻辑选择合适的排行榜类型
3. **及时更新** - 在相关事件发生时立即更新分数
4. **避免频繁重置** - 考虑使用周期性重置或归档
5. **使用事件** - 监听事件而不是轮询查询

## 相关 API

- [成就和统计追踪](成就和统计追踪.md)
- [WebSocket 数据推送](WebSocket数据推送.md)
- [事件系统](../02-核心功能/事件系统.md)

