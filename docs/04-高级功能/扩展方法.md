# 扩展方法

NetherGate 提供了丰富的扩展方法库，简化常见的游戏操作。这些扩展方法让代码更简洁、更易读。

---

## 📋 **目录**

- [ItemStack 扩展](#itemstack-扩展)
- [Position 扩展](#position-扩展)
- [实战示例](#实战示例)
- [最佳实践](#最佳实践)

---

## 🎒 **ItemStack 扩展**

### **过滤方法**

```csharp
using NetherGate.API.Extensions;

var items = await blockReader.GetChestItemsAsync(position);

// 过滤附魔物品
var enchantedItems = items.FilterEnchanted();

// 按 ID 过滤
var diamonds = items.FilterById("minecraft:diamond");

// 按标签过滤
var tools = items.FilterByTag("tools");

// 按数量过滤
var stackedItems = items.FilterByCount(count => count > 32);

// 自定义过滤
var valuable = items.Where(item => 
    item.Id.Contains("diamond") || 
    item.Id.Contains("netherite")
);
```

### **排序方法**

```csharp
// 按 ID 排序
var sortedById = items.SortById();

// 按数量排序
var sortedByCount = items.SortByCount(descending: true);

// 按稀有度排序
var sortedByRarity = items.SortByRarity();
// 优先级: 下界合金 > 钻石 > 金 > 铁 > 其他

// 自定义排序
var custom = items.OrderBy(i => i.Slot);
```

### **统计方法**

```csharp
// 获取统计信息
var stats = items.GetStatistics();

Console.WriteLine($"总物品数: {stats.TotalCount}");
Console.WriteLine($"种类数: {stats.UniqueItems}");
Console.WriteLine($"附魔物品: {stats.EnchantedCount}");
Console.WriteLine($"损坏物品: {stats.DamagedCount}");
Console.WriteLine($"总价值: {stats.TotalValue}");
```

### **转换方法**

```csharp
// 转换为字典（按ID分组）
var grouped = items.ToDictionary();
// Key: "minecraft:diamond", Value: List<ItemStack>

// 转换为摘要列表
var summary = items.ToSummary();
// "64x minecraft:stone, 32x minecraft:dirt, ..."

// 获取唯一物品 ID
var uniqueIds = items.GetUniqueIds();
// ["minecraft:diamond", "minecraft:iron_ingot", ...]
```

### **检查方法**

```csharp
// 检查是否包含物品
if (items.ContainsItem("minecraft:diamond"))
{
    // 包含钻石
}

// 检查是否有空槽位
if (items.HasEmptySlots())
{
    // 有空位
}

// 检查是否已满
if (items.IsFull(maxSlots: 27))
{
    // 箱子满了
}

// 检查特定物品数量
var diamondCount = items.CountItem("minecraft:diamond");
```

---

## 📍 **Position 扩展**

### **方向偏移**

```csharp
using NetherGate.API.Extensions;

var pos = new Position(100, 64, 200);

// 六个方向的便捷方法
var up = pos.Up(5);          // Y + 5
var down = pos.Down(3);      // Y - 3
var north = pos.North(10);   // Z - 10
var south = pos.South(10);   // Z + 10
var east = pos.East(5);      // X + 5
var west = pos.West(5);      // X - 5

// 自定义偏移
var offset = pos.Offset(x: 5, y: 10, z: -3);
```

### **距离计算**

```csharp
var pos1 = new Position(0, 0, 0);
var pos2 = new Position(10, 0, 10);

// 欧几里得距离
var distance = pos1.DistanceTo(pos2);  // 14.14

// 曼哈顿距离
var manhattan = pos1.ManhattanDistanceTo(pos2);  // 20

// 水平距离（忽略Y轴）
var horizontal = pos1.HorizontalDistanceTo(pos2);  // 14.14
```

### **区域生成**

```csharp
// 获取周围的位置（3D球体）
var surrounding = pos.GetSurroundingPositions(radius: 3);
// 返回半径 3 内的所有位置

// 获取立方体区域
var cube = pos.GetCube(size: 5);
// 返回 5x5x5 的立方体区域

// 获取平面区域
var plane = pos.GetPlane(radius: 10, includeCenter: false);
// 返回水平面上半径 10 的圆形区域

// 获取一条线上的所有位置
var line = pos.GetLineTo(targetPos);
// 返回从当前位置到目标位置的直线路径
```

### **位置关系**

```csharp
// 检查是否在区域内
var isInside = pos.IsInArea(
    corner1: new Position(0, 0, 0),
    corner2: new Position(100, 100, 100)
);

// 检查是否相邻
var isAdjacent = pos.IsAdjacentTo(otherPos);

// 获取最近的位置
var nearest = pos.GetNearest(positionList);
```

### **坐标转换**

```csharp
// 转换为区块坐标
var chunkPos = pos.ToChunkPosition();  // (ChunkX, ChunkZ)

// 转换为字符串
var str = pos.ToCommandString();  // "100 64 200"
var formatted = pos.ToFormattedString();  // "X:100, Y:64, Z:200"

// 解析字符串
var parsed = Position.Parse("100 64 200");
```

---

## 💼 **实战示例**

### **示例1：箱子整理系统**

```csharp
public class ChestOrganizerCommand : ICommand
{
    private readonly IBlockDataReader _blockReader;
    private readonly IBlockDataWriter _blockWriter;
    
    public async Task<CommandResult> ExecuteAsync(ICommandSender sender, string[] args)
    {
        var pos = ParsePosition(args);
        var items = await _blockReader.GetChestItemsAsync(pos);
        
        // 整理逻辑：附魔物品优先，然后按稀有度排序
        var organized = items
            .FilterEnchanted()           // 先拿出所有附魔物品
            .SortByRarity()              // 按稀有度排序
            .Concat(                      // 拼接上其他物品
                items.Where(i => !i.IsEnchanted())
                     .SortById()
            )
            .ToList();
        
        await _blockWriter.SetContainerItemsAsync(pos, organized);
        
        var stats = items.GetStatistics();
        return CommandResult.Ok(
            $"箱子已整理：{stats.TotalCount} 件物品，{stats.UniqueItems} 个种类，{stats.EnchantedCount} 件附魔"
        );
    }
}
```

### **示例2：区域扫描**

```csharp
public class FindDiamondCommand : ICommand
{
    public async Task<CommandResult> ExecuteAsync(ICommandSender sender, string[] args)
    {
        var centerPos = await GetPlayerPositionAsync(sender.Name);
        var radius = int.Parse(args[0]);
        
        // 扫描周围区域
        var positions = centerPos.GetSurroundingPositions(radius);
        var diamondOres = new List<Position>();
        
        foreach (var pos in positions)
        {
            var blockId = await GetBlockIdAsync(pos);
            if (blockId == "minecraft:diamond_ore" || 
                blockId == "minecraft:deepslate_diamond_ore")
            {
                diamondOres.Add(pos);
            }
        }
        
        if (diamondOres.Any())
        {
            var nearest = centerPos.GetNearest(diamondOres);
            var distance = centerPos.DistanceTo(nearest);
            
            return CommandResult.Ok(
                $"找到 {diamondOres.Count} 处钻石矿！\n" +
                $"最近的在: {nearest.ToFormattedString()} (距离 {distance:F1})"
            );
        }
        
        return CommandResult.Ok("附近没有钻石矿");
    }
}
```

### **示例3：物品统计报告**

```csharp
public class InventoryReportCommand : ICommand
{
    public async Task<CommandResult> ExecuteAsync(ICommandSender sender, string[] args)
    {
        var positions = FindAllChestsInWorld();
        var allItems = new List<ItemStack>();
        
        foreach (var pos in positions)
        {
            var items = await _blockReader.GetChestItemsAsync(pos);
            allItems.AddRange(items);
        }
        
        // 生成统计报告
        var stats = allItems.GetStatistics();
        var byId = allItems.ToDictionary();
        
        var report = new StringBuilder();
        report.AppendLine("=== 仓库统计报告 ===");
        report.AppendLine($"总物品数: {stats.TotalCount}");
        report.AppendLine($"种类数: {stats.UniqueItems}");
        report.AppendLine($"附魔物品: {stats.EnchantedCount}");
        report.AppendLine();
        report.AppendLine("== 物品分布 ==");
        
        foreach (var (id, items) in byId.OrderByDescending(x => x.Value.Sum(i => i.Count)))
        {
            var total = items.Sum(i => i.Count);
            report.AppendLine($"{id}: {total}");
        }
        
        return CommandResult.Ok(report.ToString());
    }
}
```

### **示例4：区域保护**

```csharp
public class ProtectionPlugin : IPlugin
{
    private readonly List<(Position, Position)> _protectedAreas = new();
    
    public void OnEnable(IPluginContext context)
    {
        context.EventBus.Subscribe<BlockBreakEvent>(async e =>
        {
            var breakPos = e.Position;
            
            // 检查是否在保护区
            foreach (var (corner1, corner2) in _protectedAreas)
            {
                if (breakPos.IsInArea(corner1, corner2))
                {
                    // 检查权限
                    if (!await HasPermissionAsync(e.PlayerName, "protection.bypass"))
                    {
                        e.Cancel = true;
                        await SendMessageAsync(e.PlayerName, "§c此区域受保护！");
                        return;
                    }
                }
            }
        });
    }
}
```

### **示例5：传送冷却系统**

```csharp
public class TeleportCommand : ICommand
{
    private readonly Dictionary<string, DateTime> _cooldowns = new();
    private readonly TimeSpan _cooldownDuration = TimeSpan.FromMinutes(5);
    
    public async Task<CommandResult> ExecuteAsync(ICommandSender sender, string[] args)
    {
        // 检查冷却
        if (_cooldowns.TryGetValue(sender.Name, out var lastUse))
        {
            var elapsed = DateTime.UtcNow - lastUse;
            if (elapsed < _cooldownDuration)
            {
                var remaining = _cooldownDuration - elapsed;
                return CommandResult.Fail(
                    $"传送冷却中，还需 {remaining.TotalSeconds:F0} 秒"
                );
            }
        }
        
        var targetPos = Position.Parse(args[0]);
        var currentPos = await GetPlayerPositionAsync(sender.Name);
        var distance = currentPos.DistanceTo(targetPos);
        
        // 距离限制
        if (distance > 1000)
        {
            return CommandResult.Fail("传送距离不能超过 1000 格");
        }
        
        await TeleportPlayerAsync(sender.Name, targetPos);
        _cooldowns[sender.Name] = DateTime.UtcNow;
        
        return CommandResult.Ok($"已传送到 {targetPos.ToFormattedString()}");
    }
}
```

---

## 💡 **最佳实践**

### **1. 链式操作**

✅ **推荐：** 使用 LINQ 和扩展方法链式操作
```csharp
var result = items
    .FilterEnchanted()
    .SortByRarity()
    .Take(10)
    .ToList();
```

### **2. 性能考虑**

✅ **推荐：** 对大量数据使用缓存
```csharp
// 缓存统计结果
private ItemStatistics? _cachedStats;

public ItemStatistics GetStats(List<ItemStack> items)
{
    if (_cachedStats == null)
    {
        _cachedStats = items.GetStatistics();
    }
    return _cachedStats;
}
```

### **3. 空值检查**

✅ **推荐：** 始终检查集合是否为空
```csharp
if (items?.Any() != true)
{
    return CommandResult.Fail("箱子为空");
}

var sorted = items.SortById();
```

### **4. 组合使用**

✅ **推荐：** 结合多个扩展方法实现复杂逻辑
```csharp
// 找出周围 10 格内所有箱子的钻石
var nearbyChests = playerPos.GetSurroundingPositions(10)
    .Where(p => IsChest(p));

var allDiamonds = new List<ItemStack>();
foreach (var chest in nearbyChests)
{
    var items = await _blockReader.GetChestItemsAsync(chest);
    allDiamonds.AddRange(items.FilterById("minecraft:diamond"));
}

var totalDiamonds = allDiamonds.Sum(i => i.Count);
```

---

## 📚 **相关文档**

- [方块数据操作](../02-核心功能/方块数据操作.md)
- [物品组件系统](../02-核心功能/物品组件系统.md)
- [游戏工具](./游戏工具.md)

---

**文档维护者：** NetherGate 开发团队  
**最后更新：** 2025-01-08  
**许可证：** LGPL-3.0

