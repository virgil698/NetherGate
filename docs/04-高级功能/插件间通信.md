# 插件间通信

NetherGate 提供了强大的插件间通信（IPC）系统，允许插件之间安全、高效地交换数据和调用服务。

---

## 📋 **目录**

- [快速开始](#快速开始)
- [通信模式](#通信模式)
- [发送消息](#发送消息)
- [接收消息](#接收消息)
- [请求-响应模式](#请求-响应模式)
- [最佳实践](#最佳实践)
- [完整示例](#完整示例)

---

## 🚀 **快速开始**

### **基本概念**

- **频道（Channel）：** 消息通道，类似主题
- **消息（Message）：** 包含数据的通信单元
- **发布者（Publisher）：** 发送消息的插件
- **订阅者（Subscriber）：** 接收消息的插件

### **简单示例**

**发送消息：**
```csharp
// 插件 A 发送消息
await _context.Messenger.SendMessageAsync(
    targetPlugin: "PluginB",
    channel: "greeting",
    data: new { Message = "Hello!" }
);
```

**接收消息：**
```csharp
// 插件 B 接收消息
_context.Messenger.Subscribe("greeting", msg =>
{
    _context.Logger.Info($"收到来自 {msg.SourcePlugin} 的消息: {msg.Data}");
});
```

---

## 📡 **通信模式**

### **1. 点对点通信**

发送消息给特定插件。

```csharp
// 发送给 EconomyPlugin
await _context.Messenger.SendMessageAsync(
    targetPlugin: "EconomyPlugin",
    channel: "withdraw",
    data: new { PlayerName = "Steve", Amount = 100 }
);
```

### **2. 广播通信**

发送消息给所有订阅该频道的插件。

```csharp
// 广播给所有订阅 "player_event" 的插件
await _context.Messenger.BroadcastMessageAsync(
    channel: "player_event",
    data: new { EventType = "join", PlayerName = "Steve" }
);
```

### **3. 请求-响应模式**

发送请求并等待响应。

```csharp
// 请求并等待响应
var balance = await _context.Messenger.SendRequestAsync<int>(
    targetPlugin: "EconomyPlugin",
    channel: "get_balance",
    data: new { PlayerName = "Steve" },
    timeoutMs: 5000
);

_context.Logger.Info($"Steve 的余额: {balance}");
```

---

## 📤 **发送消息**

### **IPluginMessenger 接口**

```csharp
public interface IPluginMessenger
{
    /// <summary>
    /// 发送消息给特定插件
    /// </summary>
    Task SendMessageAsync(string targetPlugin, string channel, object? data = null);
    
    /// <summary>
    /// 广播消息给所有订阅者
    /// </summary>
    Task BroadcastMessageAsync(string channel, object? data = null);
    
    /// <summary>
    /// 发送请求并等待响应
    /// </summary>
    Task<TResponse?> SendRequestAsync<TResponse>(
        string targetPlugin, 
        string channel, 
        object? data = null, 
        int timeoutMs = 5000);
}
```

### **SendMessageAsync - 点对点**

```csharp
// 基本用法
await _context.Messenger.SendMessageAsync("TargetPlugin", "channel");

// 带数据
await _context.Messenger.SendMessageAsync(
    "TargetPlugin", 
    "channel", 
    new { Key = "Value" }
);

// 复杂数据
await _context.Messenger.SendMessageAsync(
    "EconomyPlugin",
    "transaction",
    new TransactionData
    {
        From = "Steve",
        To = "Alex",
        Amount = 100,
        Reason = "购买物品"
    }
);
```

### **BroadcastMessageAsync - 广播**

```csharp
// 广播给所有订阅者
await _context.Messenger.BroadcastMessageAsync(
    channel: "server_event",
    data: new 
    {
        Event = "restart",
        Time = DateTime.UtcNow,
        Reason = "定期维护"
    }
);

// 所有订阅 "server_event" 的插件都会收到
```

### **SendRequestAsync - 请求-响应**

```csharp
// 请求数据
var response = await _context.Messenger.SendRequestAsync<PlayerBalance>(
    targetPlugin: "EconomyPlugin",
    channel: "get_balance",
    data: new { PlayerName = "Steve" },
    timeoutMs: 3000  // 3秒超时
);

if (response != null)
{
    _context.Logger.Info($"余额: {response.Balance}");
}
else
{
    _context.Logger.Warning("请求超时或失败");
}
```

---

## 📥 **接收消息**

### **Subscribe - 订阅消息**

```csharp
public interface IPluginMessenger
{
    /// <summary>
    /// 订阅频道消息
    /// </summary>
    void Subscribe(string channel, Action<PluginMessage> handler);
    
    /// <summary>
    /// 订阅请求并提供响应
    /// </summary>
    void SubscribeRequest<TRequest, TResponse>(
        string channel, 
        Func<TRequest, Task<TResponse>> handler);
    
    /// <summary>
    /// 取消订阅
    /// </summary>
    void Unsubscribe(string channel, Action<PluginMessage> handler);
}
```

### **PluginMessage 结构**

```csharp
public class PluginMessage
{
    /// <summary>
    /// 源插件名称
    /// </summary>
    public string SourcePlugin { get; set; }
    
    /// <summary>
    /// 频道名称
    /// </summary>
    public string Channel { get; set; }
    
    /// <summary>
    /// 消息数据
    /// </summary>
    public object? Data { get; set; }
    
    /// <summary>
    /// 时间戳
    /// </summary>
    public DateTime Timestamp { get; set; }
}
```

### **基本订阅**

```csharp
public void OnEnable(IPluginContext context)
{
    // 订阅消息
    _context.Messenger.Subscribe("player_data", OnPlayerDataReceived);
    _context.Messenger.Subscribe("economy_transaction", OnTransaction);
}

private void OnPlayerDataReceived(PluginMessage msg)
{
    _context.Logger.Info($"收到来自 {msg.SourcePlugin} 的消息");
    
    // 解析数据
    if (msg.Data is System.Text.Json.JsonElement json)
    {
        var playerName = json.GetProperty("PlayerName").GetString();
        var level = json.GetProperty("Level").GetInt32();
        
        _context.Logger.Info($"玩家: {playerName}, 等级: {level}");
    }
}

private void OnTransaction(PluginMessage msg)
{
    // 处理交易消息
}

public void OnDisable()
{
    // 取消订阅
    _context.Messenger.Unsubscribe("player_data", OnPlayerDataReceived);
}
```

### **类型化订阅**

```csharp
// 定义消息类型
public class PlayerDataMessage
{
    public string PlayerName { get; set; } = string.Empty;
    public int Level { get; set; }
    public int Experience { get; set; }
}

// 订阅并反序列化
_context.Messenger.Subscribe("player_data", msg =>
{
    var data = DeserializeMessage<PlayerDataMessage>(msg.Data);
    if (data != null)
    {
        _context.Logger.Info($"玩家 {data.PlayerName} 等级 {data.Level}");
    }
});

// 辅助方法
private T? DeserializeMessage<T>(object? data)
{
    if (data is System.Text.Json.JsonElement json)
    {
        return System.Text.Json.JsonSerializer.Deserialize<T>(json.GetRawText());
    }
    return default;
}
```

---

## 🔄 **请求-响应模式**

### **发送请求方**

```csharp
public async Task<int> GetPlayerBalance(string playerName)
{
    try
    {
        var balance = await _context.Messenger.SendRequestAsync<int>(
            targetPlugin: "EconomyPlugin",
            channel: "get_balance",
            data: new { PlayerName = playerName },
            timeoutMs: 5000
        );
        
        return balance;
    }
    catch (TimeoutException)
    {
        _context.Logger.Warning("获取余额超时");
        return 0;
    }
    catch (Exception ex)
    {
        _context.Logger.Error($"获取余额失败: {ex.Message}");
        return 0;
    }
}
```

### **响应请求方**

```csharp
public void OnEnable(IPluginContext context)
{
    // 注册请求处理器
    _context.Messenger.SubscribeRequest<BalanceRequest, int>(
        channel: "get_balance",
        handler: HandleBalanceRequest
    );
    
    _context.Messenger.SubscribeRequest<TransferRequest, TransferResult>(
        channel: "transfer",
        handler: HandleTransferRequest
    );
}

private async Task<int> HandleBalanceRequest(BalanceRequest request)
{
    _context.Logger.Debug($"收到余额查询请求: {request.PlayerName}");
    
    // 查询余额
    var balance = await _economyService.GetBalanceAsync(request.PlayerName);
    
    return balance;
}

private async Task<TransferResult> HandleTransferRequest(TransferRequest request)
{
    _context.Logger.Info($"收到转账请求: {request.From} -> {request.To}, {request.Amount}");
    
    // 执行转账
    var success = await _economyService.TransferAsync(
        request.From, 
        request.To, 
        request.Amount
    );
    
    return new TransferResult
    {
        Success = success,
        Message = success ? "转账成功" : "余额不足"
    };
}

// 请求和响应类型
public class BalanceRequest
{
    public string PlayerName { get; set; } = string.Empty;
}

public class TransferRequest
{
    public string From { get; set; } = string.Empty;
    public string To { get; set; } = string.Empty;
    public int Amount { get; set; }
}

public class TransferResult
{
    public bool Success { get; set; }
    public string Message { get; set; } = string.Empty;
}
```

---

## 💡 **最佳实践**

### **1. 定义清晰的消息契约**

```csharp
// 在共享库或文档中定义消息格式
namespace PluginContracts;

/// <summary>
/// 经济系统 - 余额查询请求
/// 频道: "economy.get_balance"
/// </summary>
public class GetBalanceRequest
{
    public string PlayerName { get; set; } = string.Empty;
}

/// <summary>
/// 经济系统 - 余额查询响应
/// </summary>
public class GetBalanceResponse
{
    public int Balance { get; set; }
    public string Currency { get; set; } = "金币";
}
```

### **2. 使用命名空间避免冲突**

```csharp
// ✅ 推荐：使用插件名作为前缀
await _context.Messenger.SendMessageAsync(
    "EconomyPlugin",
    "economy.transaction",  // 带命名空间
    data
);

// ❌ 不推荐：可能与其他插件冲突
await _context.Messenger.SendMessageAsync(
    "EconomyPlugin",
    "transaction",  // 太通用
    data
);
```

### **3. 错误处理**

```csharp
try
{
    var response = await _context.Messenger.SendRequestAsync<int>(
        "EconomyPlugin",
        "economy.get_balance",
        new { PlayerName = "Steve" },
        timeoutMs: 3000
    );
    
    if (response > 0)
    {
        // 处理响应
    }
}
catch (TimeoutException)
{
    _context.Logger.Warning("请求超时，经济插件可能未启用");
}
catch (InvalidOperationException ex)
{
    _context.Logger.Error($"目标插件未找到: {ex.Message}");
}
catch (Exception ex)
{
    _context.Logger.Error($"通信失败: {ex.Message}");
}
```

### **4. 版本兼容性**

```csharp
public class GetBalanceRequest
{
    /// <summary>
    /// 协议版本
    /// </summary>
    public int Version { get; set; } = 1;
    
    public string PlayerName { get; set; } = string.Empty;
}

// 处理不同版本
private async Task<GetBalanceResponse> HandleGetBalance(GetBalanceRequest request)
{
    if (request.Version != 1)
    {
        throw new NotSupportedException($"不支持的协议版本: {request.Version}");
    }
    
    // 处理请求...
}
```

### **5. 异步处理**

```csharp
// ✅ 推荐：使用异步
_context.Messenger.Subscribe("heavy_task", async msg =>
{
    await ProcessHeavyTaskAsync(msg);
});

// ❌ 不推荐：阻塞处理
_context.Messenger.Subscribe("heavy_task", msg =>
{
    Thread.Sleep(5000);  // 阻塞！
    ProcessTask(msg);
});
```

---

## 📚 **完整示例**

### **经济插件（提供服务）**

```csharp
public class EconomyPlugin : IPlugin
{
    private IPluginContext _context = null!;
    private EconomyService _service = null!;

    public void OnEnable(IPluginContext context)
    {
        _context = context;
        _service = new EconomyService();
        
        // 注册请求处理器
        RegisterMessengerHandlers();
        
        _context.Logger.Info("EconomyPlugin API 已就绪");
    }

    private void RegisterMessengerHandlers()
    {
        // 查询余额
        _context.Messenger.SubscribeRequest<GetBalanceRequest, int>(
            "economy.get_balance",
            async req => await _service.GetBalanceAsync(req.PlayerName)
        );
        
        // 转账
        _context.Messenger.SubscribeRequest<TransferRequest, bool>(
            "economy.transfer",
            async req => await _service.TransferAsync(req.From, req.To, req.Amount)
        );
        
        // 添加金币
        _context.Messenger.SubscribeRequest<AddMoneyRequest, bool>(
            "economy.add_money",
            async req => await _service.AddMoneyAsync(req.PlayerName, req.Amount)
        );
        
        // 扣除金币
        _context.Messenger.SubscribeRequest<RemoveMoneyRequest, bool>(
            "economy.remove_money",
            async req => await _service.RemoveMoneyAsync(req.PlayerName, req.Amount)
        );
        
        // 订阅交易广播（其他插件可以监听）
        _context.Messenger.Subscribe("economy.transaction", msg =>
        {
            _context.Logger.Debug($"交易广播: {msg.Data}");
        });
    }

    // 交易时广播事件
    private async Task BroadcastTransaction(string from, string to, int amount)
    {
        await _context.Messenger.BroadcastMessageAsync(
            "economy.transaction",
            new
            {
                From = from,
                To = to,
                Amount = amount,
                Timestamp = DateTime.UtcNow
            }
        );
    }
}

public class GetBalanceRequest
{
    public string PlayerName { get; set; } = string.Empty;
}

public class TransferRequest
{
    public string From { get; set; } = string.Empty;
    public string To { get; set; } = string.Empty;
    public int Amount { get; set; }
}

public class AddMoneyRequest
{
    public string PlayerName { get; set; } = string.Empty;
    public int Amount { get; set; }
}

public class RemoveMoneyRequest
{
    public string PlayerName { get; set; } = string.Empty;
    public int Amount { get; set; }
}
```

### **商店插件（使用服务）**

```csharp
public class ShopPlugin : IPlugin
{
    private IPluginContext _context = null!;

    public void OnEnable(IPluginContext context)
    {
        _context = context;
        
        // 注册购买命令
        _context.CommandManager.RegisterCommand(new BuyCommand(_context, this));
        
        // 监听经济交易事件
        _context.Messenger.Subscribe("economy.transaction", OnTransaction);
        
        _context.Logger.Info("ShopPlugin 已启用");
    }

    public async Task<bool> PurchaseItemAsync(string playerName, string itemName, int price)
    {
        // 检查余额
        var balance = await GetPlayerBalanceAsync(playerName);
        
        if (balance < price)
        {
            await _context.GameDisplayApi.SendChatMessage(
                playerName, 
                $"§c余额不足！需要 {price} 金币，当前余额 {balance}"
            );
            return false;
        }
        
        // 扣除金币
        var success = await RemoveMoneyAsync(playerName, price);
        
        if (success)
        {
            // 给予物品
            await _context.GameDisplayApi.GiveItem(playerName, itemName, 1);
            
            await _context.GameDisplayApi.SendChatMessage(
                playerName,
                $"§a购买成功！花费 {price} 金币"
            );
            
            return true;
        }
        
        return false;
    }

    private async Task<int> GetPlayerBalanceAsync(string playerName)
    {
        try
        {
            return await _context.Messenger.SendRequestAsync<int>(
                "EconomyPlugin",
                "economy.get_balance",
                new { PlayerName = playerName },
                timeoutMs: 3000
            );
        }
        catch (Exception ex)
        {
            _context.Logger.Error($"查询余额失败: {ex.Message}");
            return 0;
        }
    }

    private async Task<bool> RemoveMoneyAsync(string playerName, int amount)
    {
        try
        {
            return await _context.Messenger.SendRequestAsync<bool>(
                "EconomyPlugin",
                "economy.remove_money",
                new { PlayerName = playerName, Amount = amount },
                timeoutMs: 3000
            );
        }
        catch (Exception ex)
        {
            _context.Logger.Error($"扣除金币失败: {ex.Message}");
            return false;
        }
    }

    private void OnTransaction(PluginMessage msg)
    {
        // 记录交易
        _context.Logger.Debug($"监听到交易: {msg.Data}");
    }
}

public class BuyCommand : ICommand
{
    private readonly IPluginContext _context;
    private readonly ShopPlugin _plugin;

    public string Name => "buy";
    public string Description => "购买物品";

    public BuyCommand(IPluginContext context, ShopPlugin plugin)
    {
        _context = context;
        _plugin = plugin;
    }

    public async Task<CommandResult> ExecuteAsync(string[] args, ICommandSender? sender = null)
    {
        if (sender == null)
            return CommandResult.Fail("此命令只能在游戏内使用");
        
        if (args.Length == 0)
            return CommandResult.Fail("用法: #buy <物品名>");
        
        var itemName = args[0];
        var price = 100; // 假设价格
        
        var success = await _plugin.PurchaseItemAsync(sender.Name, itemName, price);
        
        return success ? CommandResult.Success() : CommandResult.Fail();
    }
}
```

---

## 📚 **相关文档**

- [插件开发指南](../03-插件开发/插件开发指南.md)
- [插件热重载](./插件热重载.md)
- [API 参考](../08-参考/API参考.md)

---

**文档维护者：** NetherGate 开发团队  
**最后更新：** 2025-10-05
