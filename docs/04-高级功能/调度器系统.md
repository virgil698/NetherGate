# 调度器系统

NetherGate 提供了强大的调度器系统，用于执行延迟任务和周期性任务。该功能受 [MCDReforged](https://github.com/Fallen-Breath/MCDReforged) 调度器启发。

---

## 📋 **目录**

- [快速开始](#快速开始)
- [核心概念](#核心概念)
- [API 参考](#api-参考)
- [使用示例](#使用示例)
- [最佳实践](#最佳实践)

---

## 🚀 **快速开始**

### **基本用法**

```csharp
using NetherGate.API.Scheduling;

public class MyPlugin : IPlugin
{
    private IScheduler _scheduler;
    
    public void OnEnable(IPluginContext context)
    {
        _scheduler = context.Scheduler;
        
        // 延迟执行（5秒后）
        _scheduler.ScheduleDelayed(() =>
        {
            context.Logger.Info("5秒后执行");
        }, TimeSpan.FromSeconds(5));
        
        // 周期性执行（每10秒）
        _scheduler.ScheduleRepeating(() =>
        {
            context.Logger.Info("每10秒执行一次");
        }, TimeSpan.FromSeconds(10));
    }
}
```

---

## 💡 **核心概念**

### **1. 任务类型**

| 类型 | 说明 | 使用场景 |
|------|------|----------|
| **延迟任务** | 延迟指定时间后执行一次 | 延迟通知、定时操作 |
| **周期任务** | 按固定间隔重复执行 | 自动保存、数据同步 |
| **异步任务** | 支持 async/await | 网络请求、数据库操作 |

### **2. 时间单位**

```csharp
// 使用 TimeSpan
TimeSpan.FromSeconds(30)    // 30 秒
TimeSpan.FromMinutes(5)     // 5 分钟
TimeSpan.FromHours(1)       // 1 小时
TimeSpan.FromDays(1)        // 1 天

// 组合时间
TimeSpan.FromMinutes(5) + TimeSpan.FromSeconds(30)  // 5分30秒
```

---

## 📖 **API 参考**

### **IScheduler 接口**

```csharp
public interface IScheduler
{
    /// <summary>
    /// 延迟执行任务
    /// </summary>
    void ScheduleDelayed(Action task, TimeSpan delay);
    
    /// <summary>
    /// 延迟执行异步任务
    /// </summary>
    void ScheduleDelayed(Func<Task> task, TimeSpan delay);
    
    /// <summary>
    /// 周期性执行任务
    /// </summary>
    /// <returns>任务ID，可用于取消</returns>
    string ScheduleRepeating(Action task, TimeSpan interval);
    
    /// <summary>
    /// 周期性执行异步任务
    /// </summary>
    string ScheduleRepeating(Func<Task> task, TimeSpan interval);
    
    /// <summary>
    /// 取消任务
    /// </summary>
    void CancelTask(string taskId);
    
    /// <summary>
    /// 取消所有任务
    /// </summary>
    void CancelAllTasks();
}
```

---

## 📝 **使用示例**

### **1. 延迟任务**

```csharp
// 延迟3秒发送消息
_scheduler.ScheduleDelayed(() =>
{
    context.GameDisplay.BroadcastMessage("§a服务器将在10秒后重启！");
}, TimeSpan.FromSeconds(3));

// 延迟10秒执行异步任务
_scheduler.ScheduleDelayed(async () =>
{
    await SaveWorldAsync();
    context.Logger.Info("世界已保存");
}, TimeSpan.FromSeconds(10));
```

### **2. 周期性任务**

```csharp
// 每5分钟自动保存
var taskId = _scheduler.ScheduleRepeating(async () =>
{
    await SaveWorldAsync();
    context.Logger.Info("自动保存完成");
}, TimeSpan.FromMinutes(5));

// 稍后取消任务
_scheduler.CancelTask(taskId);
```

### **3. 倒计时系统**

```csharp
public class CountdownCommand : ICommand
{
    private readonly IScheduler _scheduler;
    private readonly IGameDisplayApi _gameDisplay;
    
    public async Task<CommandResult> ExecuteAsync(ICommandSender sender, string[] args)
    {
        var seconds = int.Parse(args[0]);
        
        // 倒计时
        for (int i = seconds; i > 0; i--)
        {
            var current = i;
            _scheduler.ScheduleDelayed(() =>
            {
                _gameDisplay.BroadcastMessage($"§c{current}...");
            }, TimeSpan.FromSeconds(seconds - current));
        }
        
        // 最后的消息
        _scheduler.ScheduleDelayed(() =>
        {
            _gameDisplay.BroadcastMessage("§a时间到！");
        }, TimeSpan.FromSeconds(seconds));
        
        return CommandResult.Ok($"开始 {seconds} 秒倒计时");
    }
}
```

### **4. 自动备份系统**

```csharp
public class AutoBackupPlugin : IPlugin
{
    private IScheduler _scheduler;
    private string _backupTaskId;
    
    public void OnEnable(IPluginContext context)
    {
        _scheduler = context.Scheduler;
        
        // 每6小时自动备份
        _backupTaskId = _scheduler.ScheduleRepeating(async () =>
        {
            context.Logger.Info("开始自动备份...");
            
            var backupName = $"auto_backup_{DateTime.Now:yyyyMMdd_HHmmss}";
            await CreateBackupAsync(backupName);
            
            context.Logger.Info($"自动备份完成: {backupName}");
            
            // 清理7天前的备份
            await CleanOldBackupsAsync(TimeSpan.FromDays(7));
            
        }, TimeSpan.FromHours(6));
    }
    
    public void OnDisable()
    {
        // 插件卸载时取消任务
        _scheduler.CancelTask(_backupTaskId);
    }
}
```

### **5. 定时公告系统**

```csharp
public class AnnouncementPlugin : IPlugin
{
    private readonly string[] _announcements = new[]
    {
        "§6欢迎来到我们的服务器！",
        "§b记得阅读服务器规则",
        "§a使用 #help 查看命令帮助",
        "§e发现bug请报告给管理员"
    };
    
    public void OnEnable(IPluginContext context)
    {
        var index = 0;
        
        // 每5分钟发送一条公告
        context.Scheduler.ScheduleRepeating(() =>
        {
            var message = _announcements[index];
            context.GameDisplay.BroadcastMessage(message);
            
            index = (index + 1) % _announcements.Length;
        }, TimeSpan.FromMinutes(5));
    }
}
```

### **6. 玩家AFK检测**

```csharp
public class AfkDetectionPlugin : IPlugin
{
    private readonly Dictionary<string, DateTime> _lastActivity = new();
    private readonly TimeSpan _afkThreshold = TimeSpan.FromMinutes(5);
    
    public void OnEnable(IPluginContext context)
    {
        // 监听玩家活动
        context.EventBus.Subscribe<PlayerChatEvent>(e =>
        {
            _lastActivity[e.PlayerName] = DateTime.UtcNow;
        });
        
        // 每30秒检查AFK状态
        context.Scheduler.ScheduleRepeating(async () =>
        {
            var players = await context.SmpApi.GetPlayersAsync();
            
            foreach (var player in players)
            {
                if (_lastActivity.TryGetValue(player.Name, out var lastTime))
                {
                    var inactive = DateTime.UtcNow - lastTime;
                    
                    if (inactive > _afkThreshold)
                    {
                        await context.GameDisplay.ShowActionBarAsync(
                            player.Name,
                            $"§7[AFK] 离开 {inactive.TotalMinutes:F0} 分钟"
                        );
                    }
                }
            }
        }, TimeSpan.FromSeconds(30));
    }
}
```

### **7. 服务器重启调度**

```csharp
public class RestartScheduler : IPlugin
{
    public void OnEnable(IPluginContext context)
    {
        // 设置在凌晨4点重启
        var now = DateTime.Now;
        var nextRestart = new DateTime(now.Year, now.Month, now.Day, 4, 0, 0);
        
        if (nextRestart < now)
        {
            nextRestart = nextRestart.AddDays(1);
        }
        
        var delay = nextRestart - now;
        
        context.Scheduler.ScheduleDelayed(async () =>
        {
            // 提前10分钟通知
            await context.GameDisplay.BroadcastMessageAsync("§c服务器将在10分钟后重启！");
            
            context.Scheduler.ScheduleDelayed(async () =>
            {
                // 提前5分钟通知
                await context.GameDisplay.BroadcastMessageAsync("§c服务器将在5分钟后重启！");
                
                context.Scheduler.ScheduleDelayed(async () =>
                {
                    // 提前1分钟通知
                    await context.GameDisplay.BroadcastMessageAsync("§c服务器将在1分钟后重启！");
                    
                    context.Scheduler.ScheduleDelayed(async () =>
                    {
                        // 执行重启
                        await context.RconClient.ExecuteCommandAsync("stop");
                    }, TimeSpan.FromMinutes(1));
                    
                }, TimeSpan.FromMinutes(4));
                
            }, TimeSpan.FromMinutes(5));
            
        }, delay);
        
        context.Logger.Info($"已安排下次重启时间: {nextRestart}");
    }
}
```

---

## 💡 **最佳实践**

### **1. 任务生命周期管理**

✅ **推荐：** 保存任务ID并在适当时机取消
```csharp
public class MyPlugin : IPlugin
{
    private readonly List<string> _taskIds = new();
    
    public void OnEnable(IPluginContext context)
    {
        var taskId = context.Scheduler.ScheduleRepeating(...);
        _taskIds.Add(taskId);
    }
    
    public void OnDisable()
    {
        // 清理所有任务
        foreach (var id in _taskIds)
        {
            context.Scheduler.CancelTask(id);
        }
    }
}
```

### **2. 异常处理**

✅ **推荐：** 在任务中处理异常
```csharp
_scheduler.ScheduleRepeating(async () =>
{
    try
    {
        await DoSomethingAsync();
    }
    catch (Exception ex)
    {
        _logger.Error("定时任务执行失败", ex);
    }
}, TimeSpan.FromMinutes(5));
```

### **3. 避免阻塞**

✅ **推荐：** 使用异步任务处理耗时操作
```csharp
// 好的做法
_scheduler.ScheduleRepeating(async () =>
{
    await LongRunningOperationAsync();  // 不会阻塞
}, interval);
```

❌ **不推荐：** 在同步任务中执行耗时操作
```csharp
_scheduler.ScheduleRepeating(() =>
{
    Thread.Sleep(5000);  // 会阻塞调度器！
}, interval);
```

### **4. 合理设置间隔时间**

✅ **推荐：** 根据实际需求设置间隔
```csharp
// 自动保存 - 5-10分钟
_scheduler.ScheduleRepeating(SaveAsync, TimeSpan.FromMinutes(5));

// 状态检查 - 30秒-1分钟
_scheduler.ScheduleRepeating(CheckStatusAsync, TimeSpan.FromSeconds(30));

// 公告 - 3-5分钟
_scheduler.ScheduleRepeating(SendAnnouncementAsync, TimeSpan.FromMinutes(3));
```

---

## 📚 **相关文档**

- [命令系统](../02-核心功能/命令系统.md) - 结合命令使用调度器
- [事件系统](../02-核心功能/事件系统.md) - 事件触发的任务调度
- [国际化 (i18n)](./国际化.md) - 多语言公告

---

## 🙏 **致谢**

调度器系统的设计受 [MCDReforged](https://github.com/Fallen-Breath/MCDReforged) 启发。

---

**文档维护者：** NetherGate 开发团队  
**最后更新：** 2025-01-08  
**参考项目：** [MCDReforged](https://github.com/Fallen-Breath/MCDReforged) (GPL-3.0)

