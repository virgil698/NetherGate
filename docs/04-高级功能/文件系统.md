# 文件系统详解

NetherGate 提供了安全、强大的文件系统 API，允许插件访问和管理服务器文件。

---

## 1. 文件系统概述

### 1.1 文件系统能力

NetherGate 的文件系统 API 提供以下功能：

**文件访问：**
- 安全的文件读写（受权限和路径限制）
- 支持文本和二进制文件
- 相对路径和绝对路径

**备份管理：**
- 自动备份世界文件
- 自定义备份策略
- 备份恢复功能

**文件监控：**
- 实时监听文件变更
- 支持创建、修改、删除事件
- 可配置的监控目录

### 1.2 安全模型

```
┌──────────────────────────────────────┐
│       Plugin File Access             │
│  ┌────────────────────────────────┐  │
│  │  IServerFileAccess             │  │
│  │  ┌──────────────────────────┐  │  │
│  │  │  Path Validation         │  │  │
│  │  │  - Sandbox Check         │  │  │
│  │  │  - Permission Check      │  │  │
│  │  └──────────────────────────┘  │  │
│  │  ┌──────────────────────────┐  │  │
│  │  │  File Operations         │  │  │
│  │  │  - Read / Write          │  │  │
│  │  │  - Create / Delete       │  │  │
│  │  └──────────────────────────┘  │  │
│  └────────────────────────────────┘  │
└──────────────────────────────────────┘
         │
         ▼
  ┌────────────────┐
  │  Server Files  │
  │  - world/      │
  │  - plugins/    │
  │  - config/     │
  └────────────────┘
```

**安全限制：**
- 插件默认只能访问自己的目录（`plugins/plugin-name/`）
- 访问其他目录需要明确的权限
- 禁止访问敏感系统文件
- 所有路径都经过规范化和验证

---

## 2. 文件访问 API

### 2.1 基础文件操作

```csharp
using NetherGate.API.Plugins;
using NetherGate.API.FileSystem;

public class FileAccessPlugin : IPlugin
{
    private IServerFileAccess _fileAccess;

    public async void OnEnable()
    {
        _fileAccess = Context.FileAccess;
        
        // 读取文件（文本）
        var content = await _fileAccess.ReadTextFileAsync("plugins/my-plugin/data.txt");
        Logger.Info($"文件内容: {content}");
        
        // 写入文件（文本）
        await _fileAccess.WriteTextFileAsync(
            "plugins/my-plugin/output.txt",
            "Hello, NetherGate!",
            backup: true  // 自动备份原文件
        );
        
        // 检查文件是否存在
        if (_fileAccess.FileExists("world/level.dat"))
        {
            Logger.Info("世界文件存在");
        }
        
        // 列出目录内容
        var files = _fileAccess.ListFiles("plugins/my-plugin");
        foreach (var file in files)
        {
            Logger.Info($"文件: {file}");
        }
    }
}
```

### 2.2 IServerFileAccess 接口详解

```csharp
public interface IServerFileAccess
{
    /// <summary>
    /// 获取服务器根目录
    /// </summary>
    string ServerDirectory { get; }
    
    // === 文本文件操作 ===
    
    /// <summary>
    /// 异步读取文本文件
    /// </summary>
    Task<string> ReadTextFileAsync(string relativePath);
    
    /// <summary>
    /// 异步写入文本文件
    /// </summary>
    /// <param name="relativePath">相对路径</param>
    /// <param name="content">文件内容</param>
    /// <param name="backup">是否先备份原文件</param>
    Task WriteTextFileAsync(string relativePath, string content, bool backup = true);
    
    // === JSON 文件操作 ===
    
    /// <summary>
    /// 异步读取 JSON 文件
    /// </summary>
    Task<T?> ReadJsonFileAsync<T>(string relativePath) where T : class;
    
    /// <summary>
    /// 异步写入 JSON 文件
    /// </summary>
    Task WriteJsonFileAsync<T>(string relativePath, T data, bool backup = true) where T : class;
    
    // === 服务器配置操作 ===
    
    /// <summary>
    /// 读取服务器配置（server.properties）
    /// </summary>
    Task<Dictionary<string, string>> ReadServerPropertiesAsync();
    
    /// <summary>
    /// 写入服务器配置（server.properties）
    /// </summary>
    Task WriteServerPropertiesAsync(Dictionary<string, string> properties, bool backup = true);
    
    // === 文件管理 ===
    
    /// <summary>
    /// 检查文件是否存在
    /// </summary>
    bool FileExists(string relativePath);
    
    /// <summary>
    /// 检查目录是否存在
    /// </summary>
    bool DirectoryExists(string relativePath);
    
    /// <summary>
    /// 创建目录
    /// </summary>
    void CreateDirectory(string relativePath);
    
    /// <summary>
    /// 异步删除文件
    /// </summary>
    Task DeleteFileAsync(string relativePath, bool backup = true);
    
    // === 目录操作 ===
    
    /// <summary>
    /// 列出目录中的文件
    /// </summary>
    /// <param name="relativePath">相对路径</param>
    /// <param name="pattern">文件匹配模式（如 "*.json"）</param>
    /// <param name="recursive">是否递归搜索</param>
    List<string> ListFiles(string relativePath, string pattern = "*", bool recursive = false);
    
    // === 文件信息 ===
    
    /// <summary>
    /// 获取文件信息
    /// </summary>
    FileInfo GetFileInfo(string relativePath);
}
```

### 2.3 文件路径处理

```csharp
public class FilePathHelper
{
    private readonly IServerFileAccess _fileAccess;

    // 获取插件数据目录
    public string GetPluginDataDirectory()
    {
        return $"plugins/{Context.Metadata.Id}";
    }

    // 构建安全的文件路径
    public string GetDataFilePath(string filename)
    {
        // 确保文件名不包含路径遍历字符
        filename = Path.GetFileName(filename);
        return $"{GetPluginDataDirectory()}/{filename}";
    }

    // 初始化插件目录结构
    public void InitializeDirectories()
    {
        var baseDir = GetPluginDataDirectory();
        
        _fileAccess.CreateDirectory($"{baseDir}/data");
        _fileAccess.CreateDirectory($"{baseDir}/cache");
        _fileAccess.CreateDirectory($"{baseDir}/logs");
        _fileAccess.CreateDirectory($"{baseDir}/backups");
    }

    // 检查路径是否在插件目录内
    public bool IsPluginPath(string path)
    {
        var baseDir = GetPluginDataDirectory();
        var fullPath = Path.GetFullPath(path);
        var fullBaseDir = Path.GetFullPath(baseDir);
        
        return fullPath.StartsWith(fullBaseDir, StringComparison.OrdinalIgnoreCase);
    }
}
```

### 2.4 高级文件操作

#### JSON/YAML 文件读写

```csharp
using System.Text.Json;
using YamlDotNet.Serialization;

public class ConfigFileManager
{
    private readonly IServerFileAccess _fileAccess;

    // 读取 JSON 文件（使用内置方法）
    public async Task<T?> ReadJsonFileAsync<T>(string path) where T : class
    {
        return await _fileAccess.ReadJsonFileAsync<T>(path);
    }

    // 写入 JSON 文件（使用内置方法）
    public async Task WriteJsonFileAsync<T>(string path, T data) where T : class
    {
        await _fileAccess.WriteJsonFileAsync(path, data, backup: true);
    }

    // 读取 YAML 文件
    public async Task<T> ReadYamlFileAsync<T>(string path)
    {
        var yaml = await _fileAccess.ReadTextFileAsync(path);
        var deserializer = new DeserializerBuilder().Build();
        return deserializer.Deserialize<T>(yaml);
    }

    // 写入 YAML 文件
    public async Task WriteYamlFileAsync<T>(string path, T data)
    {
        var serializer = new SerializerBuilder().Build();
        var yaml = serializer.Serialize(data);
        await _fileAccess.WriteTextFileAsync(path, yaml, backup: true);
    }
}
```

#### CSV 文件处理

```csharp
public class CsvHelper
{
    private readonly IServerFileAccess _fileAccess;

    public async Task<List<Dictionary<string, string>>> ReadCsvAsync(string path)
    {
        var content = await _fileAccess.ReadTextFileAsync(path);
        var lines = content.Split('\n');
        var headers = lines[0].Split(',');
        var data = new List<Dictionary<string, string>>();

        for (int i = 1; i < lines.Length; i++)
        {
            if (string.IsNullOrWhiteSpace(lines[i])) continue;
            
            var values = lines[i].Split(',');
            var row = new Dictionary<string, string>();
            
            for (int j = 0; j < headers.Length; j++)
            {
                row[headers[j].Trim()] = values[j].Trim();
            }
            
            data.Add(row);
        }

        return data;
    }

    public async Task WriteCsvAsync(string path, List<Dictionary<string, string>> data)
    {
        if (data.Count == 0) return;

        var headers = data[0].Keys;
        var csv = new StringBuilder();
        
        // 写入表头
        csv.AppendLine(string.Join(",", headers));
        
        // 写入数据行
        foreach (var row in data)
        {
            var values = headers.Select(h => row[h]);
            csv.AppendLine(string.Join(",", values));
        }

        await _fileAccess.WriteTextFileAsync(path, csv.ToString(), backup: true);
    }
}
```

---

## 3. 备份管理 API

### 3.1 基础备份操作

```csharp
using NetherGate.API.FileSystem;

public class BackupPlugin : IPlugin
{
    private IBackupManager _backupManager;

    public async void OnEnable()
    {
        _backupManager = Context.BackupManager;
        
        // 创建世界备份
        var backupPath = await _backupManager.CreateWorldBackupAsync();
        Logger.Info($"备份已创建: {backupPath}");
        
        // 创建完整备份（包含世界和配置）
        var fullBackupPath = await _backupManager.CreateBackupAsync(
            backupName: null,  // 使用时间戳作为名称
            includeWorlds: true,
            includeConfigs: true,
            includePlugins: false
        );
        Logger.Info($"完整备份已创建: {fullBackupPath}");
        
        // 列出所有备份
        var backups = _backupManager.ListBackups();
        foreach (var backup in backups)
        {
            Logger.Info($"备份: {backup.Name} ({backup.FormattedSize}) - {backup.CreatedAt}");
            Logger.Info($"  类型: {backup.Type}, 包含世界: {backup.IncludesWorlds}, 包含配置: {backup.IncludesConfigs}");
        }
        
        // 恢复备份
        await _backupManager.RestoreBackupAsync(backups[0].FilePath, createBackupBeforeRestore: true);
        
        // 删除特定备份
        await _backupManager.DeleteBackupAsync(backups.Last().FilePath);
        
        // 清理旧备份
        await _backupManager.CleanupBackupsAsync(keepCount: 10, olderThanDays: 30);
    }
}
```

### 3.2 IBackupManager 接口详解

```csharp
public interface IBackupManager
{
    /// <summary>
    /// 创建完整备份
    /// </summary>
    Task<string> CreateBackupAsync(
        string? backupName = null,
        bool includeWorlds = true,
        bool includeConfigs = true,
        bool includePlugins = false);
    
    /// <summary>
    /// 创建世界备份
    /// </summary>
    Task<string> CreateWorldBackupAsync(string? worldName = null, string? backupName = null);
    
    /// <summary>
    /// 恢复备份
    /// </summary>
    Task RestoreBackupAsync(string backupPath, bool createBackupBeforeRestore = true);
    
    /// <summary>
    /// 列出所有备份
    /// </summary>
    List<BackupInfo> ListBackups();
    
    /// <summary>
    /// 删除备份
    /// </summary>
    Task DeleteBackupAsync(string backupPath);
    
    /// <summary>
    /// 清理旧备份
    /// </summary>
    Task CleanupBackupsAsync(int keepCount = 10, int olderThanDays = 30);
    
    /// <summary>
    /// 启用自动备份
    /// </summary>
    void EnableAutoBackup(int intervalMinutes = 60, int maxBackups = 10);
    
    /// <summary>
    /// 禁用自动备份
    /// </summary>
    void DisableAutoBackup();
    
    /// <summary>
    /// 获取备份目录
    /// </summary>
    string BackupDirectory { get; }
}

public class BackupInfo
{
    public string Name { get; init; }
    public string FilePath { get; init; }
    public DateTime CreatedAt { get; init; }
    public long Size { get; init; }
    public BackupType Type { get; init; }
    public bool IncludesWorlds { get; init; }
    public bool IncludesConfigs { get; init; }
    public string FormattedSize { get; }  // 自动格式化的大小 (如 "1.5 GB")
}

public enum BackupType
{
    Full,        // 完整备份
    World,       // 世界备份
    Config,      // 配置备份
    Auto         // 自动备份
}
```

### 3.3 自动备份策略

```csharp
using System.Timers;

public class AutoBackupPlugin : IPlugin
{
    private IBackupManager _backupManager;
    private Timer _backupTimer;
    private AutoBackupConfig _config;

    public void OnEnable()
    {
        _backupManager = Context.BackupManager;
        _config = Context.ConfigManager.LoadConfig<AutoBackupConfig>();
        
        if (_config.Enabled)
        {
            StartAutoBackup();
        }
    }

    private void StartAutoBackup()
    {
        // 使用 IBackupManager 的内置自动备份功能
        _backupManager.EnableAutoBackup(
            intervalMinutes: _config.IntervalHours * 60,
            maxBackups: _config.MaxBackupCount
        );
        
        Logger.Info($"自动备份已启用，间隔: {_config.IntervalHours} 小时，最多保留 {_config.MaxBackupCount} 个备份");
    }

    // 或者使用自定义定时器
    private void StartCustomAutoBackup()
    {
        var intervalMs = _config.IntervalHours * 3600 * 1000;
        _backupTimer = new Timer(intervalMs);
        _backupTimer.Elapsed += OnBackupTimerElapsed;
        _backupTimer.Start();
        
        Logger.Info($"自定义自动备份已启用，间隔: {_config.IntervalHours} 小时");
    }

    private async void OnBackupTimerElapsed(object sender, ElapsedEventArgs e)
    {
        try
        {
            Logger.Info("开始自动备份...");
            
            // 创建世界备份
            await _backupManager.CreateWorldBackupAsync();
            
            // 清理旧备份
            if (_config.MaxBackupCount > 0 || _config.MaxBackupDays > 0)
            {
                await _backupManager.CleanupBackupsAsync(
                    keepCount: _config.MaxBackupCount,
                    olderThanDays: _config.MaxBackupDays
                );
            }
            
            Logger.Info("自动备份完成");
        }
        catch (Exception ex)
        {
            Logger.Error($"自动备份失败: {ex.Message}");
        }
    }

    public void OnDisable()
    {
        _backupTimer?.Stop();
        _backupTimer?.Dispose();
    }
}

public class AutoBackupConfig
{
    public bool Enabled { get; set; } = true;
    public int IntervalHours { get; set; } = 6;
    public int MaxBackupCount { get; set; } = 10;
    public int MaxBackupDays { get; set; } = 30;
}
```

### 3.4 增量备份

```csharp
public class IncrementalBackupManager
{
    private readonly IBackupManager _backupManager;
    private readonly IServerFileAccess _fileAccess;
    private readonly Dictionary<string, DateTime> _fileModTimes = new();

    public async Task<string> CreateIncrementalBackupAsync(string targetPath)
    {
        var changedFiles = new List<string>();
        
        // 检测变更的文件
        foreach (var file in _fileAccess.ListFilesRecursive(targetPath))
        {
            var modTime = _fileAccess.GetLastModifiedTime(file);
            
            if (!_fileModTimes.ContainsKey(file) || _fileModTimes[file] < modTime)
            {
                changedFiles.Add(file);
                _fileModTimes[file] = modTime;
            }
        }
        
        if (changedFiles.Count == 0)
        {
            Logger.Info("没有文件变更，跳过备份");
            return null;
        }
        
        Logger.Info($"检测到 {changedFiles.Count} 个文件变更，创建增量备份");
        
        // 创建增量备份（只备份变更的文件）
        var backupName = $"{Path.GetFileName(targetPath)}-incremental-{DateTime.Now:yyyyMMdd-HHmmss}";
        var backupDir = $"backups/{backupName}";
        
        _fileAccess.CreateDirectory(backupDir);
        
        foreach (var file in changedFiles)
        {
            var destFile = $"{backupDir}/{Path.GetRelativePath(targetPath, file)}";
            var destDir = Path.GetDirectoryName(destFile);
            
            if (!_fileAccess.DirectoryExists(destDir))
            {
                _fileAccess.CreateDirectory(destDir);
            }
            
            _fileAccess.CopyFile(file, destFile);
        }
        
        Logger.Info($"增量备份完成: {backupDir}");
        return backupDir;
    }
}
```

---

## 4. 文件监控 API

### 4.1 基础文件监控

```csharp
using NetherGate.API.FileSystem;

public class FileWatcherPlugin : IPlugin
{
    private IFileWatcher _fileWatcher;

    private string? _configWatcherId;
    private string? _playerdataWatcherId;

    public void OnEnable()
    {
        _fileWatcher = Context.FileWatcher;
        
        // 监听配置文件变更
        _configWatcherId = _fileWatcher.WatchFile("plugins/my-plugin/config.yaml", OnConfigChanged);
        
        // 监听整个目录（包含所有 .dat 文件）
        _playerdataWatcherId = _fileWatcher.WatchDirectory(
            "world/playerdata",
            "*.dat",
            includeSubdirectories: false,
            OnPlayerDataChanged
        );
    }

    private void OnConfigChanged(FileChangeEvent e)
    {
        Logger.Info($"配置文件已变更: {e.FilePath} ({e.ChangeType})");
        
        // 重新加载配置
        Context.ConfigManager.ReloadConfig<MyConfig>();
    }

    private void OnPlayerDataChanged(FileChangeEvent e)
    {
        Logger.Info($"玩家数据变更: {e.FilePath} ({e.ChangeType})");
        
        // 处理玩家数据更新
        if (e.ChangeType == FileChangeType.Modified)
        {
            var playerName = Path.GetFileNameWithoutExtension(e.FilePath);
            // ...
        }
        else if (e.ChangeType == FileChangeType.Renamed && e.OldFilePath != null)
        {
            Logger.Info($"文件重命名: {e.OldFilePath} -> {e.FilePath}");
        }
    }

    public void OnDisable()
    {
        // 停止特定监听器
        if (_configWatcherId != null)
            _fileWatcher.StopWatching(_configWatcherId);
        if (_playerdataWatcherId != null)
            _fileWatcher.StopWatching(_playerdataWatcherId);
        
        // 或停止所有监听
        _fileWatcher.StopAll();
    }
}
```

### 4.2 IFileWatcher 接口详解

```csharp
public interface IFileWatcher
{
    /// <summary>
    /// 监听指定文件
    /// </summary>
    /// <returns>监听器 ID</returns>
    string WatchFile(string filePath, Action<FileChangeEvent> callback);
    
    /// <summary>
    /// 监听指定目录
    /// </summary>
    /// <param name="directoryPath">目录路径</param>
    /// <param name="pattern">文件匹配模式（如 "*.json"）</param>
    /// <param name="includeSubdirectories">是否包含子目录</param>
    /// <param name="callback">文件变更回调</param>
    /// <returns>监听器 ID</returns>
    string WatchDirectory(string directoryPath, string pattern, bool includeSubdirectories, Action<FileChangeEvent> callback);
    
    /// <summary>
    /// 停止监听
    /// </summary>
    /// <param name="watcherId">监听器 ID</param>
    void StopWatching(string watcherId);
    
    /// <summary>
    /// 停止所有监听
    /// </summary>
    void StopAll();
}

public class FileChangeEvent
{
    public FileChangeType ChangeType { get; init; }
    public string FilePath { get; init; }
    public string? OldFilePath { get; init; }  // 仅重命名时有效
    public DateTime Timestamp { get; init; }
}

public enum FileChangeType
{
    Created,
    Modified,
    Deleted,
    Renamed
}
```

### 4.3 高级文件监控

#### 文件变更历史记录

```csharp
public class FileChangeRecorder
{
    private readonly List<FileChangeEvent> _history = new();
    private readonly int _maxHistorySize = 1000;

    public void OnFileChanged(FileChangeEvent e)
    {
        _history.Add(e);
        
        if (_history.Count > _maxHistorySize)
        {
            _history.RemoveAt(0);
        }
        
        Logger.Debug($"文件变更记录: {e.FilePath} - {e.ChangeType}");
    }

    public IEnumerable<FileChangeEvent> GetHistory(TimeSpan duration)
    {
        var cutoff = DateTime.Now - duration;
        return _history.Where(e => e.Timestamp > cutoff);
    }

    public IEnumerable<FileChangeEvent> GetHistoryForFile(string filePath)
    {
        return _history.Where(e => e.FilePath == filePath);
    }
}
```

#### 文件变更通知

```csharp
public class FileChangeNotifier
{
    private readonly IGameDisplayApi _display;

    public async void OnImportantFileChanged(FileChangeEvent e)
    {
        if (e.FilePath.Contains("server.properties"))
        {
            // 通知所有管理员
            await _display.BroadcastAsync(
                $"§e[系统] 服务器配置文件已被修改！",
                "yourplugin.admin"
            );
        }
    }
}
```

---

## 5. 最佳实践

### 5.1 文件操作最佳实践

#### 使用异步 I/O

```csharp
// ✅ 正确：使用异步 I/O
var content = await _fileAccess.ReadTextFileAsync("large-file.txt");

// ❌ 注意：NetherGate 的 IServerFileAccess 只提供异步方法
// 所有文件操作都应使用 async/await
```

#### 异常处理

```csharp
try
{
    var content = await _fileAccess.ReadTextFileAsync(path);
    // ...
}
catch (FileNotFoundException ex)
{
    Logger.Warning($"文件不存在: {path}");
}
catch (UnauthorizedAccessException ex)
{
    Logger.Error($"权限不足，无法访问: {path}");
}
catch (IOException ex)
{
    Logger.Error($"文件 I/O 错误: {ex.Message}");
}
```

#### 文件锁处理

```csharp
public async Task<string> ReadFileWithRetry(string path, int maxRetries = 3)
{
    for (int i = 0; i < maxRetries; i++)
    {
        try
        {
            return await _fileAccess.ReadTextFileAsync(path);
        }
        catch (IOException) when (i < maxRetries - 1)
        {
            Logger.Debug($"文件被锁定，重试 {i + 1}/{maxRetries}");
            await Task.Delay(100);
        }
    }
    
    throw new IOException($"无法读取文件 {path}，已重试 {maxRetries} 次");
}
```

### 5.2 备份最佳实践

#### 备份前停止服务器保存

```csharp
public async Task CreateSafeBackupAsync()
{
    // 1. 禁用自动保存
    await _rconClient.SendCommandAsync("save-off");
    
    // 2. 强制保存当前状态
    await _rconClient.SendCommandAsync("save-all flush");
    
    // 3. 等待保存完成
    await Task.Delay(5000);
    
    // 4. 创建备份
    await _backupManager.CreateBackupAsync("world");
    
    // 5. 恢复自动保存
    await _rconClient.SendCommandAsync("save-on");
    
    Logger.Info("安全备份完成");
}
```

#### 验证备份完整性

```csharp
public bool VerifyBackup(string backupPath)
{
    // 检查关键文件是否存在
    var requiredFiles = new[] {
        "level.dat",
        "region/r.0.0.mca"
    };
    
    foreach (var file in requiredFiles)
    {
        if (!_fileAccess.FileExists($"{backupPath}/{file}"))
        {
            Logger.Error($"备份不完整，缺少文件: {file}");
            return false;
        }
    }
    
    return true;
}
```

### 5.3 性能优化

#### 批量文件操作

```csharp
// ❌ 错误：逐个文件操作
foreach (var file in files)
{
    await _fileAccess.WriteTextFileAsync(file, content);
}

// ✅ 正确：并行批量操作
await Task.WhenAll(files.Select(file => 
    _fileAccess.WriteTextFileAsync(file, content)
));
```

#### 缓存文件内容

```csharp
public class FileCache
{
    private readonly Dictionary<string, (DateTime, string)> _cache = new();
    private readonly TimeSpan _cacheExpiry = TimeSpan.FromMinutes(5);

    public async Task<string> GetFileContentAsync(string path)
    {
        if (_cache.TryGetValue(path, out var cached))
        {
            if (DateTime.Now - cached.Item1 < _cacheExpiry)
            {
                return cached.Item2;
            }
        }
        
        var content = await _fileAccess.ReadTextFileAsync(path);
        _cache[path] = (DateTime.Now, content);
        
        return content;
    }
}
```

---

## 6. 常见问题

### Q1: 如何访问其他插件的文件？

**A:** `IServerFileAccess` 可以访问服务器根目录下的任何文件（通过相对路径）：
```csharp
// 访问其他插件的文件
var data = await _fileAccess.ReadTextFileAsync("plugins/other-plugin/data.txt");

// 访问世界文件
var properties = await _fileAccess.ReadServerPropertiesAsync();

// 访问日志文件
var log = await _fileAccess.ReadTextFileAsync("logs/latest.log");
```

**注意:** 确保路径有效且有权限访问。建议只访问自己插件目录的文件。

### Q2: 备份会影响服务器性能吗？

**A:** 备份会占用 I/O 资源。建议：
1. 在低峰时段执行（凌晨）
2. 使用异步 API（`CreateBackupAsync`）
3. 考虑使用增量备份

### Q3: 如何处理文件编码问题？

**A:** NetherGate 的 `IServerFileAccess` 默认使用 UTF-8 编码处理文本文件。如需处理其他编码，可以手动读取和转换：

```csharp
// 读取为 UTF-8（默认）
var content = await _fileAccess.ReadTextFileAsync(path);

// 如需处理其他编码，可以通过 FileInfo 访问原始文件
var fileInfo = _fileAccess.GetFileInfo(path);
var fullPath = Path.Combine(_fileAccess.ServerDirectory, fileInfo.FullName);
var bytes = await File.ReadAllBytesAsync(fullPath);
var content = Encoding.GetEncoding("GBK").GetString(bytes);
```

---

## 参考资源

- [.NET File I/O 最佳实践](https://learn.microsoft.com/dotnet/standard/io/)
- [文件系统监视器 (FileSystemWatcher)](https://learn.microsoft.com/dotnet/api/system.io.filesystemwatcher)

