# 插件热重载

NetherGate 支持插件热重载功能，允许在不重启服务器的情况下重新加载插件。本文档介绍热重载的工作原理和最佳实践。

---

## 📋 **目录**

- [什么是热重载](#什么是热重载)
- [使用热重载](#使用热重载)
- [热重载流程](#热重载流程)
- [状态管理](#状态管理)
- [资源清理](#资源清理)
- [最佳实践](#最佳实践)
- [常见问题](#常见问题)

---

## 🔥 **什么是热重载**

热重载（Hot Reload）是指在运行时重新加载插件的能力，无需重启整个服务器。

### **优点**

- ✅ **快速迭代** - 修改代码后立即生效
- ✅ **零停机** - 不影响其他插件和玩家
- ✅ **调试方便** - 快速测试修复
- ✅ **开发效率高** - 节省重启时间

### **限制**

- ⚠️ **静态变量** - 不会重置
- ⚠️ **依赖关系** - 需要手动管理
- ⚠️ **状态保存** - 需要正确实现
- ⚠️ **内存泄漏** - 不正确清理会导致泄漏

---

## 🎮 **使用热重载**

### **1. 通过控制台命令**

```bash
# 重载单个插件
plugin reload MyPlugin

# 重载所有插件
plugin reload all

# 禁用插件
plugin disable MyPlugin

# 启用插件
plugin enable MyPlugin

# 卸载插件
plugin unload MyPlugin

# 加载新插件
plugin load MyPlugin
```

### **2. 通过 API**

```csharp
using NetherGate.API.Plugins;

public class PluginManagerPlugin : PluginBase
{
    public async Task ManagePluginsAsync()
    {
        // 使用 PluginManager 属性（由 PluginBase 提供）
        
        // 重载单个插件
        await PluginManager.ReloadPluginAsync("MyPlugin");
        Logger.Info("插件已重载");
        
        // 重载所有插件
        await PluginManager.ReloadAllPluginsAsync();
        Logger.Info("所有插件已重载");
        
        // 启用/禁用插件
        await PluginManager.EnablePluginAsync("MyPlugin");
        await PluginManager.DisablePluginAsync("MyPlugin");
        
        // 加载/卸载插件
        await PluginManager.LoadPluginAsync("MyPlugin");
        await PluginManager.UnloadPluginAsync("MyPlugin");
    }
}
```

### **3. 自动重载（文件监视）**

在 `nethergate-config.yaml` 中启用：

```yaml
plugins:
  enable_hot_reload: true  # 启用热重载
  auto_load: true          # 自动加载新插件
```

当检测到插件文件变化时，自动重载。

---

## 🔄 **热重载流程**

### **完整流程**

```
1. 保存状态
   └─ 调用 SaveState()
   
2. 禁用插件
   ├─ 调用 OnDisable()
   ├─ 取消事件订阅
   ├─ 注销命令
   └─ 清理资源
   
3. 卸载程序集
   └─ 释放 AssemblyLoadContext
   
4. 重新加载程序集
   ├─ 创建新的 AssemblyLoadContext
   ├─ 加载 DLL 文件
   └─ 读取 plugin.json
   
5. 创建插件实例
   └─ 实例化主类
   
6. 启用插件
   ├─ 调用 OnLoad()
   ├─ 创建 IPluginContext
   ├─ 调用 OnEnable()
   └─ 恢复状态
   
7. 恢复状态
   └─ 调用 RestoreState()
```

### **时序图**

```
[用户] ─────→ [PluginManager]
                     │
                     ├─→ [旧实例].SaveState()
                     │
                     ├─→ [旧实例].OnDisable()
                     │      ├─ 取消事件订阅
                     │      ├─ 注销命令
                     │      └─ 清理资源
                     │
                     ├─→ 卸载程序集
                     │
                     ├─→ 重新加载程序集
                     │
                     ├─→ [新实例] = new Plugin()
                     │
                     ├─→ [新实例].OnLoad()
                     │
                     ├─→ [新实例].OnEnable(context)
                     │      ├─ 订阅事件
                     │      ├─ 注册命令
                     │      └─ 初始化
                     │
                     └─→ [新实例].RestoreState()
```

---

## 💾 **状态管理**

### **实现状态保存和恢复**

```csharp
using NetherGate.API.Plugins;
using System.Text.Json;

public class MyPlugin : PluginBase
{
    private Dictionary<string, PlayerData> _playerData = new();
    private MyConfig _config = null!;

    public override async Task OnLoadAsync()
    {
        Logger.Debug("插件加载中...");
    }

    public override async Task OnEnableAsync()
    {
        // 加载配置
        _config = await Config.LoadAsync<MyConfig>("config");
        
        // 加载持久化数据
        await LoadDataAsync();
        
        // 尝试恢复热重载前的状态
        await RestoreStateAsync();
        
        // 注册事件和命令
        RegisterEvents();
        RegisterCommands();
        
        Logger.Info("MyPlugin 已启用");
    }

    public override async Task OnDisableAsync()
    {
        // 保存状态（用于热重载）
        await SaveStateAsync();
        
        // 保存数据到磁盘
        await SaveDataAsync();
        
        Logger.Info("MyPlugin 已禁用");
    }

    public override async Task OnUnloadAsync()
    {
        // 最后的清理工作
        Logger.Debug("插件卸载完成");
    }

    /// <summary>
    /// 保存状态（热重载前）
    /// </summary>
    private async Task SaveStateAsync()
    {
        try
        {
            var state = new PluginState
            {
                PlayerData = _playerData,
                LastSaveTime = DateTime.UtcNow
            };
            
            // 使用 DataDirectory 属性（由 PluginBase 提供）
            var stateFile = Path.Combine(DataDirectory, ".state.json");
            var json = JsonSerializer.Serialize(state, 
                new JsonSerializerOptions { WriteIndented = true });
            await File.WriteAllTextAsync(stateFile, json);
            
            Logger.Debug("状态已保存");
        }
        catch (Exception ex)
        {
            Logger.Error($"保存状态失败: {ex.Message}");
        }
    }

    /// <summary>
    /// 恢复状态（热重载后）
    /// </summary>
    private async Task RestoreStateAsync()
    {
        try
        {
            var stateFile = Path.Combine(_context.DataDirectory, ".state.json");
            if (!File.Exists(stateFile))
            {
                _context.Logger.Debug("没有找到状态文件，跳过恢复");
                return;
            }
            
            var json = File.ReadAllText(stateFile);
            var state = System.Text.Json.JsonSerializer.Deserialize<PluginState>(json);
            
            if (state != null)
            {
                _playerData = state.PlayerData;
                _context.Logger.Info($"状态已恢复（上次保存: {state.LastSaveTime}）");
                
                // 删除状态文件
                File.Delete(stateFile);
            }
        }
        catch (Exception ex)
        {
            _context.Logger.Error($"恢复状态失败: {ex.Message}");
        }
    }

    private void LoadData()
    {
        // 从持久化存储加载数据
        var dataFile = Path.Combine(_context.DataDirectory, "data.json");
        if (File.Exists(dataFile))
        {
            var json = File.ReadAllText(dataFile);
            _playerData = System.Text.Json.JsonSerializer
                .Deserialize<Dictionary<string, PlayerData>>(json) ?? new();
        }
    }

    private void SaveData()
    {
        // 保存数据到持久化存储
        var dataFile = Path.Combine(_context.DataDirectory, "data.json");
        var json = System.Text.Json.JsonSerializer.Serialize(_playerData,
            new System.Text.Json.JsonSerializerOptions { WriteIndented = true });
        File.WriteAllText(dataFile, json);
    }

    private void RegisterEvents()
    {
        _context.EventBus.Subscribe<PlayerJoinedEvent>(OnPlayerJoined);
        _context.EventBus.Subscribe<PlayerLeftEvent>(OnPlayerLeft);
    }

    private void RegisterCommands()
    {
        _context.CommandManager.RegisterCommand(new MyCommand(_context));
    }

    private void OnPlayerJoined(PlayerJoinedEvent e)
    {
        // 处理玩家加入
    }

    private void OnPlayerLeft(PlayerLeftEvent e)
    {
        // 处理玩家离开
    }
}

public class PluginState
{
    public Dictionary<string, PlayerData> PlayerData { get; set; } = new();
    public DateTime LastSaveTime { get; set; }
}

public class PlayerData
{
    public string Name { get; set; } = string.Empty;
    public int Score { get; set; }
    // 其他数据...
}
```

---

## 🧹 **资源清理**

### **1. 取消事件订阅**

```csharp
public class MyPlugin : IPlugin
{
    private Action<PlayerJoinedEvent>? _joinHandler;
    private Action<PlayerLeftEvent>? _leftHandler;

    public void OnEnable(IPluginContext context)
    {
        // 保存处理器引用
        _joinHandler = OnPlayerJoined;
        _leftHandler = OnPlayerLeft;
        
        _context.EventBus.Subscribe(_joinHandler);
        _context.EventBus.Subscribe(_leftHandler);
    }

    public void OnDisable()
    {
        // 手动取消订阅（可选，框架会自动处理）
        if (_joinHandler != null)
            _context.EventBus.Unsubscribe(_joinHandler);
        
        if (_leftHandler != null)
            _context.EventBus.Unsubscribe(_leftHandler);
    }
}
```

### **2. 停止定时器**

```csharp
public class MyPlugin : IPlugin
{
    private Timer? _heartbeatTimer;
    private Timer? _cleanupTimer;

    public void OnEnable(IPluginContext context)
    {
        _heartbeatTimer = new Timer(_ => DoHeartbeat(), 
            null, TimeSpan.Zero, TimeSpan.FromSeconds(30));
        
        _cleanupTimer = new Timer(_ => DoCleanup(), 
            null, TimeSpan.FromMinutes(5), TimeSpan.FromMinutes(5));
    }

    public void OnDisable()
    {
        // 停止并释放定时器
        _heartbeatTimer?.Dispose();
        _heartbeatTimer = null;
        
        _cleanupTimer?.Dispose();
        _cleanupTimer = null;
    }

    private void DoHeartbeat() { }
    private void DoCleanup() { }
}
```

### **3. 关闭文件流和连接**

```csharp
public class MyPlugin : IPlugin
{
    private FileStream? _logStream;
    private HttpClient? _httpClient;
    private DatabaseConnection? _dbConnection;

    public void OnEnable(IPluginContext context)
    {
        _logStream = File.OpenWrite("plugin.log");
        _httpClient = new HttpClient();
        _dbConnection = new DatabaseConnection();
    }

    public void OnDisable()
    {
        // 关闭所有资源
        _logStream?.Dispose();
        _logStream = null;
        
        _httpClient?.Dispose();
        _httpClient = null;
        
        _dbConnection?.Close();
        _dbConnection = null;
    }
}
```

### **4. 取消异步操作**

```csharp
public class MyPlugin : IPlugin
{
    private CancellationTokenSource? _cts;

    public void OnEnable(IPluginContext context)
    {
        _cts = new CancellationTokenSource();
        
        // 启动后台任务
        _ = BackgroundTaskAsync(_cts.Token);
    }

    public void OnDisable()
    {
        // 取消所有后台任务
        _cts?.Cancel();
        _cts?.Dispose();
        _cts = null;
    }

    private async Task BackgroundTaskAsync(CancellationToken cancellationToken)
    {
        while (!cancellationToken.IsCancellationRequested)
        {
            try
            {
                await DoWorkAsync();
                await Task.Delay(1000, cancellationToken);
            }
            catch (OperationCanceledException)
            {
                _context.Logger.Info("后台任务已取消");
                break;
            }
        }
    }

    private async Task DoWorkAsync()
    {
        // 执行工作
    }
}
```

---

## 💡 **最佳实践**

### **1. 始终实现正确的清理**

```csharp
public void OnDisable()
{
    // ✅ 完整的清理流程
    
    // 1. 保存状态
    SaveState();
    
    // 2. 停止所有定时器
    StopTimers();
    
    // 3. 取消所有异步操作
    CancelAsyncOperations();
    
    // 4. 关闭所有连接和流
    CloseConnections();
    
    // 5. 保存数据
    SaveData();
    
    // 6. 记录日志
    _context.Logger.Info("插件已完全清理");
}
```

### **2. 避免静态变量**

```csharp
// ❌ 不推荐：静态变量在热重载时不会重置
public static Dictionary<string, PlayerData> PlayerCache = new();

// ✅ 推荐：使用实例变量
private Dictionary<string, PlayerData> _playerCache = new();
```

如果必须使用静态变量，在 `OnDisable()` 中清理：

```csharp
public static Dictionary<string, PlayerData> PlayerCache = new();

public void OnDisable()
{
    // 清理静态变量
    PlayerCache.Clear();
}
```

### **3. 实现幂等性**

确保多次调用 `OnEnable()` 和 `OnDisable()` 不会出错：

```csharp
private bool _isInitialized = false;

public void OnEnable(IPluginContext context)
{
    if (_isInitialized)
    {
        _context.Logger.Warning("插件已初始化，跳过重复初始化");
        return;
    }
    
    // 初始化逻辑
    Initialize();
    
    _isInitialized = true;
}

public void OnDisable()
{
    if (!_isInitialized)
    {
        return;
    }
    
    // 清理逻辑
    Cleanup();
    
    _isInitialized = false;
}
```

### **4. 测试热重载**

在开发时频繁测试热重载：

```bash
# 修改代码
# 构建插件
dotnet build

# 测试重载
plugin reload MyPlugin

# 检查日志
# 验证功能
```

### **5. 记录热重载日志**

```csharp
public void OnDisable()
{
    _context.Logger.Info("=== 插件正在卸载（热重载） ===");
    _context.Logger.Info($"当前状态: {GetCurrentState()}");
    
    SaveState();
    Cleanup();
    
    _context.Logger.Info("插件卸载完成");
}

public void OnEnable(IPluginContext context)
{
    _context.Logger.Info("=== 插件正在加载（热重载） ===");
    
    Initialize();
    RestoreState();
    
    _context.Logger.Info($"恢复后状态: {GetCurrentState()}");
}
```

---

## ❓ **常见问题**

### **Q: 热重载后数据丢失？**

**A:** 确保正确实现状态保存和恢复：

```csharp
public void OnDisable()
{
    SaveState();  // 保存到临时状态文件
    SaveData();   // 保存到持久化存储
}

public void OnEnable(IPluginContext context)
{
    LoadData();     // 从持久化存储加载
    RestoreState(); // 恢复热重载前的状态
}
```

---

### **Q: 热重载后事件重复触发？**

**A:** 确保在 `OnDisable()` 中取消所有事件订阅：

```csharp
private Action<PlayerJoinedEvent> _joinHandler = null!;

public void OnEnable(IPluginContext context)
{
    _joinHandler = OnPlayerJoined;
    _context.EventBus.Subscribe(_joinHandler);
}

public void OnDisable()
{
    _context.EventBus.Unsubscribe(_joinHandler);
}
```

---

### **Q: 热重载导致内存泄漏？**

**A:** 检查是否正确释放了所有资源：

```csharp
public void OnDisable()
{
    // 检查清单：
    // ✅ 定时器已停止？
    _timer?.Dispose();
    
    // ✅ 文件流已关闭？
    _fileStream?.Dispose();
    
    // ✅ 网络连接已关闭？
    _httpClient?.Dispose();
    
    // ✅ 数据库连接已关闭？
    _dbConnection?.Close();
    
    // ✅ 异步操作已取消？
    _cts?.Cancel();
    
    // ✅ 事件订阅已取消？
    _context.EventBus.Unsubscribe(_handler);
}
```

---

### **Q: 静态变量如何处理？**

**A:** 

**方法 1：避免使用静态变量**（推荐）

```csharp
// 使用实例变量
private Dictionary<string, int> _cache = new();
```

**方法 2：手动清理静态变量**

```csharp
public static Dictionary<string, int> Cache = new();

public void OnDisable()
{
    Cache.Clear();
}
```

**方法 3：使用单例模式**

```csharp
public class PluginData
{
    private static PluginData? _instance;
    
    public static PluginData Instance => _instance ??= new();
    
    public Dictionary<string, int> Cache { get; } = new();
    
    public static void Reset()
    {
        _instance = null;
    }
}

public void OnDisable()
{
    PluginData.Reset();
}
```

---

### **Q: 如何调试热重载问题？**

**A:**

1. **启用详细日志**

```yaml
logging:
  level: "Debug"
```

2. **添加调试信息**

```csharp
public void OnDisable()
{
    _context.Logger.Debug($"OnDisable 调用，当前数据量: {_playerData.Count}");
    SaveState();
    _context.Logger.Debug("状态已保存");
}

public void OnEnable(IPluginContext context)
{
    _context.Logger.Debug("OnEnable 调用");
    RestoreState();
    _context.Logger.Debug($"状态已恢复，数据量: {_playerData.Count}");
}
```

3. **检查内存使用**

```csharp
_context.EventBus.Subscribe<ServerHeartbeatEvent>(e =>
{
    var memoryMB = GC.GetTotalMemory(false) / 1024 / 1024;
    _context.Logger.Debug($"内存使用: {memoryMB} MB");
});
```

---

## 📚 **相关文档**

- [插件开发指南](../03-插件开发/插件开发指南.md)
- [性能优化](../07-示例和最佳实践/性能优化.md)
- [调试技巧](../03-插件开发/调试技巧.md)

---

**文档维护者：** NetherGate 开发团队  
**最后更新：** 2025-10-05
