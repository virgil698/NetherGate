# 构造函数注入示例插件

本示例展示如何使用依赖注入 (DI) 创建现代化的 NetherGate 插件。

---

## 基础示例

### 简单的日志插件

```csharp
using NetherGate.API.Plugins;
using NetherGate.API.Logging;
using NetherGate.API.Events;

namespace SimpleLoggerPlugin;

public class SimpleLoggerPlugin : IPlugin
{
    private readonly ILogger _logger;
    private readonly IEventBus _eventBus;
    
    // 通过构造函数注入依赖
    public SimpleLoggerPlugin(ILoggerFactory loggerFactory, IEventBus eventBus)
    {
        _logger = loggerFactory.CreateLogger("SimpleLogger");
        _eventBus = eventBus;
    }
    
    public PluginInfo Info => new()
    {
        Id = "com.example.simple-logger",
        Name = "Simple Logger",
        Version = "1.0.0",
        Author = "NetherGate",
        Description = "记录所有服务器事件"
    };
    
    public Task OnLoadAsync()
    {
        _logger.Info("SimpleLogger 正在加载...");
        return Task.CompletedTask;
    }
    
    public Task OnEnableAsync()
    {
        _logger.Info("SimpleLogger 已启用");
        
        // 订阅事件
        _eventBus.Subscribe<PlayerJoinedEvent>(OnPlayerJoined);
        _eventBus.Subscribe<PlayerLeftEvent>(OnPlayerLeft);
        
        return Task.CompletedTask;
    }
    
    private void OnPlayerJoined(PlayerJoinedEvent e)
    {
        _logger.Info($"[JOIN] {e.PlayerName} 加入了游戏");
    }
    
    private void OnPlayerLeft(PlayerLeftEvent e)
    {
        _logger.Info($"[LEFT] {e.PlayerName} 离开了游戏");
    }
    
    public Task OnDisableAsync()
    {
        _logger.Info("SimpleLogger 已禁用");
        return Task.CompletedTask;
    }
    
    public Task OnUnloadAsync()
    {
        _logger.Info("SimpleLogger 已卸载");
        return Task.CompletedTask;
    }
}
```

---

## 高级示例

### 玩家数据分析插件

```csharp
using NetherGate.API.Plugins;
using NetherGate.API.Logging;
using NetherGate.API.Protocol;
using NetherGate.API.Data;
using NetherGate.API.Analytics;
using NetherGate.Core.Plugins;

namespace PlayerAnalyticsPlugin;

public class PlayerAnalyticsPlugin : IPlugin
{
    private readonly ILogger _logger;
    private readonly ISmpApi _smpApi;
    private readonly IPlayerDataReader _playerDataReader;
    private readonly IStatisticsTracker _statisticsTracker;
    private readonly DistributedPluginBus _distributedBus;
    
    // 注入多个服务
    public PlayerAnalyticsPlugin(
        ILoggerFactory loggerFactory,
        ISmpApi smpApi,
        IPlayerDataReader playerDataReader,
        IStatisticsTracker statisticsTracker,
        DistributedPluginBus distributedBus)
    {
        _logger = loggerFactory.CreateLogger("PlayerAnalytics");
        _smpApi = smpApi;
        _playerDataReader = playerDataReader;
        _statisticsTracker = statisticsTracker;
        _distributedBus = distributedBus;
    }
    
    public PluginInfo Info => new()
    {
        Id = "com.example.player-analytics",
        Name = "Player Analytics",
        Version = "1.0.0",
        Author = "NetherGate",
        Description = "玩家数据分析和统计"
    };
    
    public Task OnLoadAsync()
    {
        _logger.Info("PlayerAnalytics 正在加载...");
        return Task.CompletedTask;
    }
    
    public async Task OnEnableAsync()
    {
        _logger.Info("PlayerAnalytics 已启用");
        
        // 订阅分布式消息
        _distributedBus.Subscribe("player:analytics:request", OnAnalyticsRequest);
        
        // 启动定时任务
        _ = Task.Run(AnalyticsLoopAsync);
    }
    
    private async void OnAnalyticsRequest(DistributedMessage message)
    {
        try
        {
            var request = JsonSerializer.Deserialize<AnalyticsRequest>(message.Data);
            var playerUuid = request.PlayerUuid;
            
            // 获取玩家统计
            var stats = await _statisticsTracker.GetPlayerStatisticsAsync(playerUuid);
            
            // 发送响应到请求节点
            await _distributedBus.PublishAsync(
                $"player:analytics:response:{request.RequestId}",
                new AnalyticsResponse
                {
                    PlayerUuid = playerUuid,
                    PlayTime = stats.PlayTimeSpan,
                    Deaths = stats.Deaths,
                    Kills = stats.MobKills + stats.PlayerKills
                },
                targetNodeId: message.SourceNodeId
            );
        }
        catch (Exception ex)
        {
            _logger.Error($"处理分析请求失败: {ex.Message}");
        }
    }
    
    private async Task AnalyticsLoopAsync()
    {
        while (true)
        {
            try
            {
                await Task.Delay(TimeSpan.FromMinutes(5));
                
                // 获取在线玩家
                var players = await _smpApi.GetPlayersAsync();
                
                foreach (var player in players)
                {
                    // 获取玩家数据
                    var playerData = await _playerDataReader.ReadPlayerDataAsync(player.Uuid);
                    
                    if (playerData != null)
                    {
                        _logger.Info($"玩家 {player.Name}:");
                        _logger.Info($"  位置: {playerData.Position}");
                        _logger.Info($"  生命: {playerData.Health}/{playerData.MaxHealth}");
                        _logger.Info($"  等级: {playerData.ExperienceLevel}");
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.Error($"分析循环失败: {ex.Message}");
            }
        }
    }
    
    public Task OnDisableAsync()
    {
        _logger.Info("PlayerAnalytics 已禁用");
        return Task.CompletedTask;
    }
    
    public Task OnUnloadAsync()
    {
        _logger.Info("PlayerAnalytics 已卸载");
        return Task.CompletedTask;
    }
}

// 数据模型
public class AnalyticsRequest
{
    public string RequestId { get; set; } = string.Empty;
    public string PlayerUuid { get; set; } = string.Empty;
}

public class AnalyticsResponse
{
    public string PlayerUuid { get; set; } = string.Empty;
    public TimeSpan PlayTime { get; set; }
    public int Deaths { get; set; }
    public int Kills { get; set; }
}
```

---

## 连接池示例

### 使用连接池的数据库插件

```csharp
using NetherGate.API.Plugins;
using NetherGate.API.Logging;
using NetherGate.Core.Network;
using System.Data.SQLite;

namespace DatabasePlugin;

public class DatabasePlugin : IPlugin, IDisposable
{
    private readonly ILogger _logger;
    private ConnectionPool<SQLiteConnection>? _dbPool;
    
    public DatabasePlugin(ILoggerFactory loggerFactory)
    {
        _logger = loggerFactory.CreateLogger("Database");
    }
    
    public PluginInfo Info => new()
    {
        Id = "com.example.database",
        Name = "Database Plugin",
        Version = "1.0.0",
        Author = "NetherGate"
    };
    
    public Task OnLoadAsync()
    {
        return Task.CompletedTask;
    }
    
    public Task OnEnableAsync()
    {
        // 创建数据库连接池
        _dbPool = new ConnectionPool<SQLiteConnection>(
            connectionFactory: async () =>
            {
                var connection = new SQLiteConnection("Data Source=players.db;Version=3;");
                await connection.OpenAsync();
                return connection;
            },
            connectionDisposer: connection =>
            {
                connection.Close();
                connection.Dispose();
            },
            logger: _logger,
            maxPoolSize: 10,
            connectionTimeout: TimeSpan.FromMinutes(5)
        );
        
        _logger.Info("数据库连接池已初始化");
        return Task.CompletedTask;
    }
    
    public async Task<PlayerRecord?> GetPlayerAsync(string playerName)
    {
        if (_dbPool == null)
            return null;
        
        // 从连接池获取连接
        using (var pooled = await _dbPool.AcquireAsync())
        {
            var connection = pooled.Connection;
            
            using var command = connection.CreateCommand();
            command.CommandText = "SELECT * FROM players WHERE name = @name";
            command.Parameters.AddWithValue("@name", playerName);
            
            using var reader = await command.ExecuteReaderAsync();
            if (await reader.ReadAsync())
            {
                return new PlayerRecord
                {
                    Name = reader.GetString(0),
                    Uuid = reader.GetString(1),
                    LastSeen = DateTime.Parse(reader.GetString(2))
                };
            }
        } // 连接自动释放回池中
        
        return null;
    }
    
    public Task OnDisableAsync()
    {
        Dispose();
        return Task.CompletedTask;
    }
    
    public Task OnUnloadAsync()
    {
        return Task.CompletedTask;
    }
    
    public void Dispose()
    {
        _dbPool?.Dispose();
        _logger.Info("数据库连接池已释放");
    }
}

public class PlayerRecord
{
    public string Name { get; set; } = string.Empty;
    public string Uuid { get; set; } = string.Empty;
    public DateTime LastSeen { get; set; }
}
```

---

## 分布式消息示例

### 跨服务器聊天插件

```csharp
using NetherGate.API.Plugins;
using NetherGate.API.Logging;
using NetherGate.API.Events;
using NetherGate.API.GameDisplay;
using NetherGate.Core.Plugins;

namespace CrossServerChatPlugin;

public class CrossServerChatPlugin : IPlugin
{
    private readonly ILogger _logger;
    private readonly IEventBus _eventBus;
    private readonly IGameDisplayApi _gameDisplay;
    private readonly DistributedPluginBus _distributedBus;
    
    public CrossServerChatPlugin(
        ILoggerFactory loggerFactory,
        IEventBus eventBus,
        IGameDisplayApi gameDisplay,
        DistributedPluginBus distributedBus)
    {
        _logger = loggerFactory.CreateLogger("CrossServerChat");
        _eventBus = eventBus;
        _gameDisplay = gameDisplay;
        _distributedBus = distributedBus;
    }
    
    public PluginInfo Info => new()
    {
        Id = "com.example.cross-server-chat",
        Name = "Cross-Server Chat",
        Version = "1.0.0",
        Author = "NetherGate",
        Description = "跨服务器聊天系统"
    };
    
    public Task OnLoadAsync()
    {
        return Task.CompletedTask;
    }
    
    public Task OnEnableAsync()
    {
        _logger.Info($"CrossServerChat 已启用 (节点: {_distributedBus.CurrentNodeId})");
        
        // 订阅本地聊天事件
        _eventBus.Subscribe<ChatMessageEvent>(OnLocalChatMessage);
        
        // 订阅远程聊天消息
        _distributedBus.Subscribe("global:chat", OnRemoteChatMessage);
        
        return Task.CompletedTask;
    }
    
    private async void OnLocalChatMessage(ChatMessageEvent e)
    {
        // 广播到所有服务器节点
        await _distributedBus.PublishAsync("global:chat", new
        {
            ServerName = Environment.MachineName,
            PlayerName = e.PlayerName,
            Message = e.Message,
            Timestamp = DateTime.UtcNow
        });
    }
    
    private async void OnRemoteChatMessage(DistributedMessage message)
    {
        try
        {
            var chatData = JsonSerializer.Deserialize<GlobalChatMessage>(message.Data);
            
            // 跳过来自本节点的消息
            if (message.SourceNodeId == _distributedBus.CurrentNodeId)
                return;
            
            // 在本地服务器显示远程聊天消息
            await _gameDisplay.SendChatMessageAsync(
                "@a",
                $"§7[§6{chatData.ServerName}§7] §f{chatData.PlayerName}§7: §f{chatData.Message}"
            );
            
            _logger.Info($"[远程聊天] {chatData.ServerName}/{chatData.PlayerName}: {chatData.Message}");
        }
        catch (Exception ex)
        {
            _logger.Error($"处理远程聊天消息失败: {ex.Message}");
        }
    }
    
    public Task OnDisableAsync()
    {
        _logger.Info("CrossServerChat 已禁用");
        return Task.CompletedTask;
    }
    
    public Task OnUnloadAsync()
    {
        return Task.CompletedTask;
    }
}

public class GlobalChatMessage
{
    public string ServerName { get; set; } = string.Empty;
    public string PlayerName { get; set; } = string.Empty;
    public string Message { get; set; } = string.Empty;
    public DateTime Timestamp { get; set; }
}
```

---

## 最佳实践

### 1. 依赖注入原则

```csharp
// ✅ 好的做法：只注入需要的服务
public MyPlugin(ILogger logger, ISmpApi smpApi)
{
    _logger = logger;
    _smpApi = smpApi;
}

// ❌ 避免：注入过多不需要的服务
public MyPlugin(
    ILogger logger,
    ISmpApi smpApi,
    IRconClient rconClient,
    IEventBus eventBus,
    IPlayerDataReader reader,
    // ... 太多了！
)
```

### 2. 异步编程

```csharp
// ✅ 好的做法：全异步
public async Task OnEnableAsync()
{
    var players = await _smpApi.GetPlayersAsync();
    await ProcessPlayersAsync(players);
}

// ❌ 避免：同步等待（可能死锁）
public Task OnEnableAsync()
{
    var players = _smpApi.GetPlayersAsync().Result;
    return Task.CompletedTask;
}
```

### 3. 资源管理

```csharp
// ✅ 好的做法：实现 IDisposable
public class MyPlugin : IPlugin, IDisposable
{
    private ConnectionPool<TcpClient>? _pool;
    
    public Task OnDisableAsync()
    {
        Dispose();
        return Task.CompletedTask;
    }
    
    public void Dispose()
    {
        _pool?.Dispose();
    }
}
```

---

## 编译和部署

### 1. 创建项目

```bash
dotnet new classlib -n MyPlugin
cd MyPlugin
dotnet add package NetherGate.API
```

### 2. 编译

```bash
dotnet build -c Release
```

### 3. 部署

将 `bin/Release/net9.0/MyPlugin.dll` 复制到 NetherGate 的 `plugins/` 目录。

---

## 调试

### 使用 Visual Studio

1. 附加到 `NetherGate.Host.exe` 进程
2. 在插件代码中设置断点
3. 使用 `plugin reload MyPlugin` 触发热重载

### 使用日志

```csharp
public MyPlugin(ILoggerFactory loggerFactory)
{
    _logger = loggerFactory.CreateLogger("MyPlugin");
    
    // 不同级别的日志
    _logger.Debug("调试信息");
    _logger.Info("普通信息");
    _logger.Warning("警告");
    _logger.Error("错误");
}
```

---

## 完整项目结构

```
MyPlugin/
├── MyPlugin.csproj
├── MyPlugin.cs
├── plugin.json
└── README.md
```

### plugin.json

```json
{
  "id": "com.example.myplugin",
  "name": "My Plugin",
  "version": "1.0.0",
  "author": "YourName",
  "description": "A sample plugin",
  "main": "MyPlugin.MyPlugin",
  "dependencies": [],
  "soft_dependencies": []
}
```

---

## 参考资料

- [架构优化指南](../05-配置和部署/架构优化指南.md)
- [插件开发指南](../03-插件开发/插件开发指南.md)
- [API 参考](../08-参考/API参考.md)

