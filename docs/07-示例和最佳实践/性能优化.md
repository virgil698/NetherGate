# æ€§èƒ½ä¼˜åŒ–æŒ‡å—

æœ¬æŒ‡å—ä»‹ç»å¦‚ä½•ä¼˜åŒ– NetherGate æ’ä»¶çš„æ€§èƒ½ï¼Œæé«˜æœåŠ¡å™¨çš„æ•´ä½“è¿è¡Œæ•ˆç‡ã€‚

---

## ğŸ“‹ **ç›®å½•**

- [æ€§èƒ½åˆ†æ](#æ€§èƒ½åˆ†æ)
- [å¼‚æ­¥ç¼–ç¨‹](#å¼‚æ­¥ç¼–ç¨‹)
- [ç¼“å­˜ç­–ç•¥](#ç¼“å­˜ç­–ç•¥)
- [æ•°æ®åº“ä¼˜åŒ–](#æ•°æ®åº“ä¼˜åŒ–)
- [å†…å­˜ç®¡ç†](#å†…å­˜ç®¡ç†)
- [äº‹ä»¶å¤„ç†ä¼˜åŒ–](#äº‹ä»¶å¤„ç†ä¼˜åŒ–)
- [ç½‘ç»œä¼˜åŒ–](#ç½‘ç»œä¼˜åŒ–)
- [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)

---

## ğŸ“Š **æ€§èƒ½åˆ†æ**

### **1. ä½¿ç”¨æ€§èƒ½ç›‘è§†å™¨**

```csharp
public class MyPlugin : IPlugin
{
    private IPluginContext _context = null!;

    public void OnEnable(IPluginContext context)
    {
        _context = context;
        
        // å¯åŠ¨æ€§èƒ½ç›‘æ§
        var timer = new System.Timers.Timer(60000); // æ¯åˆ†é’Ÿ
        timer.Elapsed += (s, e) => LogPerformanceMetrics();
        timer.Start();
    }

    private void LogPerformanceMetrics()
    {
        var metrics = _context.PerformanceMonitor.GetMetrics();
        
        _context.Logger.Info($"=== æ€§èƒ½æŒ‡æ ‡ ===");
        _context.Logger.Info($"CPU ä½¿ç”¨ç‡: {metrics.CpuUsage:F1}%");
        _context.Logger.Info($"å†…å­˜ä½¿ç”¨: {metrics.MemoryUsageMB:F0} MB");
        _context.Logger.Info($"æœåŠ¡å™¨ TPS: {metrics.Tps:F1}");
        
        // å‘Šè­¦
        if (metrics.CpuUsage > 80)
        {
            _context.Logger.Warning("CPU ä½¿ç”¨ç‡è¿‡é«˜ï¼");
        }
        
        if (metrics.MemoryUsageMB > 4096)
        {
            _context.Logger.Warning("å†…å­˜ä½¿ç”¨è¿‡é«˜ï¼");
        }
    }
}
```

### **2. æµ‹é‡æ–¹æ³•æ‰§è¡Œæ—¶é—´**

```csharp
public class PerformanceTimer : IDisposable
{
    private readonly string _operationName;
    private readonly ILogger _logger;
    private readonly Stopwatch _stopwatch;

    public PerformanceTimer(string operationName, ILogger logger)
    {
        _operationName = operationName;
        _logger = logger;
        _stopwatch = Stopwatch.StartNew();
    }

    public void Dispose()
    {
        _stopwatch.Stop();
        var elapsed = _stopwatch.ElapsedMilliseconds;
        
        if (elapsed > 100)
        {
            _logger.Warning($"{_operationName} è€—æ—¶ {elapsed}msï¼ˆè¾ƒæ…¢ï¼‰");
        }
        else
        {
            _logger.Debug($"{_operationName} è€—æ—¶ {elapsed}ms");
        }
    }
}

// ä½¿ç”¨
using (new PerformanceTimer("åŠ è½½ç©å®¶æ•°æ®", _context.Logger))
{
    await LoadPlayerDataAsync(playerName);
}
```

---

## âš¡ **å¼‚æ­¥ç¼–ç¨‹**

### **1. ä½¿ç”¨ async/await**

```csharp
// âŒ é˜»å¡å¼ï¼ˆä¼šé™ä½æ€§èƒ½ï¼‰
public void OnPlayerJoined(PlayerJoinedEvent e)
{
    Thread.Sleep(1000);  // é˜»å¡çº¿ç¨‹
    var data = LoadPlayerData(e.Player.Name);  // åŒæ­¥ I/O
}

// âœ… å¼‚æ­¥å¼ï¼ˆä¸é˜»å¡ï¼‰
public async void OnPlayerJoined(PlayerJoinedEvent e)
{
    await Task.Delay(1000);  // å¼‚æ­¥ç­‰å¾…
    var data = await LoadPlayerDataAsync(e.Player.Name);  // å¼‚æ­¥ I/O
}
```

### **2. å¹¶å‘æ‰§è¡Œå¤šä¸ªä»»åŠ¡**

```csharp
// âŒ ä¸²è¡Œæ‰§è¡Œï¼ˆæ…¢ï¼‰
foreach (var player in players)
{
    await SendWelcomeMessage(player);  // é€ä¸ªå‘é€
}

// âœ… å¹¶å‘æ‰§è¡Œï¼ˆå¿«ï¼‰
var tasks = players.Select(p => SendWelcomeMessage(p));
await Task.WhenAll(tasks);
```

### **3. é¿å…åœ¨äº‹ä»¶å¤„ç†ä¸­é˜»å¡**

```csharp
// âŒ åœ¨äº‹ä»¶å¤„ç†ä¸­æ‰§è¡Œè€—æ—¶æ“ä½œ
_context.EventBus.Subscribe<PlayerJoinedEvent>(e =>
{
    // è¿™ä¼šé˜»å¡å…¶ä»–è®¢é˜…è€…
    LoadHeavyData(e.Player.Name);
});

// âœ… ä½¿ç”¨åå°ä»»åŠ¡
_context.EventBus.Subscribe<PlayerJoinedEvent>(e =>
{
    _ = Task.Run(async () =>
    {
        await LoadHeavyDataAsync(e.Player.Name);
    });
});
```

### **4. è¶…æ—¶å¤„ç†**

```csharp
public async Task<T> ExecuteWithTimeoutAsync<T>(
    Func<Task<T>> operation, 
    int timeoutMs = 5000)
{
    using var cts = new CancellationTokenSource(timeoutMs);
    
    try
    {
        return await operation().WaitAsync(cts.Token);
    }
    catch (OperationCanceledException)
    {
        _context.Logger.Warning("æ“ä½œè¶…æ—¶");
        throw;
    }
}

// ä½¿ç”¨
var data = await ExecuteWithTimeoutAsync(
    () => LoadDataAsync(playerName),
    timeoutMs: 3000
);
```

---

## ğŸ—„ï¸ **ç¼“å­˜ç­–ç•¥**

### **1. å†…å­˜ç¼“å­˜**

```csharp
public class PlayerDataCache
{
    private readonly Dictionary<string, CacheEntry<PlayerData>> _cache = new();
    private readonly TimeSpan _expiration = TimeSpan.FromMinutes(5);

    public async Task<PlayerData> GetOrLoadAsync(string playerName, 
        Func<string, Task<PlayerData>> loader)
    {
        // æ£€æŸ¥ç¼“å­˜
        if (_cache.TryGetValue(playerName, out var entry))
        {
            if (DateTime.UtcNow - entry.Timestamp < _expiration)
            {
                return entry.Data;
            }
            
            // ç¼“å­˜è¿‡æœŸï¼Œç§»é™¤
            _cache.Remove(playerName);
        }
        
        // åŠ è½½æ•°æ®
        var data = await loader(playerName);
        
        // å­˜å…¥ç¼“å­˜
        _cache[playerName] = new CacheEntry<PlayerData>
        {
            Data = data,
            Timestamp = DateTime.UtcNow
        };
        
        return data;
    }

    public void Invalidate(string playerName)
    {
        _cache.Remove(playerName);
    }

    public void Clear()
    {
        _cache.Clear();
    }
}

public class CacheEntry<T>
{
    public T Data { get; set; } = default!;
    public DateTime Timestamp { get; set; }
}
```

### **2. LRU ç¼“å­˜ï¼ˆæœ€è¿‘æœ€å°‘ä½¿ç”¨ï¼‰**

```csharp
public class LruCache<TKey, TValue> where TKey : notnull
{
    private readonly int _capacity;
    private readonly Dictionary<TKey, LinkedListNode<CacheItem>> _cache;
    private readonly LinkedList<CacheItem> _lru;

    public LruCache(int capacity)
    {
        _capacity = capacity;
        _cache = new Dictionary<TKey, LinkedListNode<CacheItem>>(capacity);
        _lru = new LinkedList<CacheItem>();
    }

    public bool TryGet(TKey key, out TValue value)
    {
        if (_cache.TryGetValue(key, out var node))
        {
            // ç§»åˆ°é“¾è¡¨å¤´éƒ¨ï¼ˆæœ€è¿‘ä½¿ç”¨ï¼‰
            _lru.Remove(node);
            _lru.AddFirst(node);
            
            value = node.Value.Value;
            return true;
        }
        
        value = default!;
        return false;
    }

    public void Add(TKey key, TValue value)
    {
        if (_cache.TryGetValue(key, out var existingNode))
        {
            // æ›´æ–°ç°æœ‰é¡¹
            _lru.Remove(existingNode);
            _lru.AddFirst(existingNode);
            existingNode.Value.Value = value;
            return;
        }
        
        // æ£€æŸ¥å®¹é‡
        if (_cache.Count >= _capacity)
        {
            // ç§»é™¤æœ€ä¹…æœªä½¿ç”¨çš„é¡¹
            var lastNode = _lru.Last!;
            _lru.RemoveLast();
            _cache.Remove(lastNode.Value.Key);
        }
        
        // æ·»åŠ æ–°é¡¹
        var newNode = _lru.AddFirst(new CacheItem { Key = key, Value = value });
        _cache[key] = newNode;
    }

    private class CacheItem
    {
        public TKey Key { get; set; } = default!;
        public TValue Value { get; set; } = default!;
    }
}

// ä½¿ç”¨
private LruCache<string, PlayerData> _playerCache = new(100); // æœ€å¤š100ä¸ª

public PlayerData GetPlayerData(string playerName)
{
    if (_playerCache.TryGet(playerName, out var data))
    {
        return data;
    }
    
    data = LoadPlayerData(playerName);
    _playerCache.Add(playerName, data);
    return data;
}
```

### **3. å®šæœŸæ¸…ç†è¿‡æœŸç¼“å­˜**

```csharp
public class MyPlugin : IPlugin
{
    private Timer? _cacheCleanupTimer;

    public void OnEnable(IPluginContext context)
    {
        // æ¯å°æ—¶æ¸…ç†ä¸€æ¬¡ç¼“å­˜
        _cacheCleanupTimer = new Timer(_ => CleanupCache(), 
            null, TimeSpan.Zero, TimeSpan.FromHours(1));
    }

    private void CleanupCache()
    {
        var before = _cache.Count;
        
        // ç§»é™¤è¿‡æœŸé¡¹
        var expiredKeys = _cache
            .Where(kvp => DateTime.UtcNow - kvp.Value.Timestamp > TimeSpan.FromMinutes(30))
            .Select(kvp => kvp.Key)
            .ToList();
        
        foreach (var key in expiredKeys)
        {
            _cache.Remove(key);
        }
        
        var after = _cache.Count;
        _context.Logger.Debug($"ç¼“å­˜æ¸…ç†ï¼šç§»é™¤ {before - after} ä¸ªè¿‡æœŸé¡¹");
    }

    public void OnDisable()
    {
        _cacheCleanupTimer?.Dispose();
    }
}
```

---

## ğŸ—ƒï¸ **æ•°æ®åº“ä¼˜åŒ–**

### **1. æ‰¹é‡æ“ä½œ**

```csharp
// âŒ é€æ¡æ’å…¥ï¼ˆæ…¢ï¼‰
foreach (var player in players)
{
    await database.InsertAsync(player);
}

// âœ… æ‰¹é‡æ’å…¥ï¼ˆå¿«ï¼‰
await database.BulkInsertAsync(players);
```

### **2. è¿æ¥æ± **

```csharp
public class DatabasePool
{
    private readonly SemaphoreSlim _semaphore;
    private readonly Queue<DbConnection> _pool = new();
    private readonly string _connectionString;

    public DatabasePool(string connectionString, int maxConnections = 10)
    {
        _connectionString = connectionString;
        _semaphore = new SemaphoreSlim(maxConnections, maxConnections);
    }

    public async Task<DbConnection> GetConnectionAsync()
    {
        await _semaphore.WaitAsync();
        
        lock (_pool)
        {
            if (_pool.Count > 0)
            {
                return _pool.Dequeue();
            }
        }
        
        var connection = CreateConnection();
        await connection.OpenAsync();
        return connection;
    }

    public void ReturnConnection(DbConnection connection)
    {
        lock (_pool)
        {
            _pool.Enqueue(connection);
        }
        
        _semaphore.Release();
    }

    private DbConnection CreateConnection()
    {
        // åˆ›å»ºæ•°æ®åº“è¿æ¥
        return new SqlConnection(_connectionString);
    }
}
```

### **3. å¼‚æ­¥æŸ¥è¯¢**

```csharp
public async Task<List<PlayerData>> GetTopPlayersAsync(int count)
{
    await using var connection = await _dbPool.GetConnectionAsync();
    
    return await connection.QueryAsync<PlayerData>(
        "SELECT * FROM players ORDER BY score DESC LIMIT @Count",
        new { Count = count }
    ).ToListAsync();
}
```

---

## ğŸ’¾ **å†…å­˜ç®¡ç†**

### **1. ä½¿ç”¨å¼±å¼•ç”¨**

```csharp
// å¯¹äºå¤§å¯¹è±¡æˆ–ä¸å¸¸ç”¨çš„ç¼“å­˜
private Dictionary<string, WeakReference<PlayerData>> _weakCache = new();

public PlayerData? GetPlayerData(string playerName)
{
    if (_weakCache.TryGetValue(playerName, out var weakRef))
    {
        if (weakRef.TryGetTarget(out var data))
        {
            return data;
        }
        
        // å¼•ç”¨å·²è¢«å›æ”¶
        _weakCache.Remove(playerName);
    }
    
    return null;
}
```

### **2. åŠæ—¶é‡Šæ”¾èµ„æº**

```csharp
public class ResourceManagement
{
    private Stream? _stream;
    private Timer? _timer;

    public void Initialize()
    {
        _stream = File.OpenRead("data.txt");
        _timer = new Timer(_ => DoWork(), null, 0, 1000);
    }

    public void Cleanup()
    {
        // é‡Šæ”¾èµ„æº
        _stream?.Dispose();
        _stream = null;
        
        _timer?.Dispose();
        _timer = null;
    }
}

// æˆ–ä½¿ç”¨ using
public async Task ProcessFileAsync(string path)
{
    await using var stream = File.OpenRead(path);
    // è‡ªåŠ¨é‡Šæ”¾
}
```

### **3. å¯¹è±¡æ± **

```csharp
public class ObjectPool<T> where T : class, new()
{
    private readonly ConcurrentBag<T> _objects = new();
    private readonly int _maxSize;

    public ObjectPool(int maxSize = 100)
    {
        _maxSize = maxSize;
    }

    public T Rent()
    {
        if (_objects.TryTake(out var obj))
        {
            return obj;
        }
        
        return new T();
    }

    public void Return(T obj)
    {
        if (_objects.Count < _maxSize)
        {
            _objects.Add(obj);
        }
    }
}

// ä½¿ç”¨
private ObjectPool<StringBuilder> _stringBuilderPool = new();

public string BuildMessage()
{
    var sb = _stringBuilderPool.Rent();
    try
    {
        sb.Clear();
        sb.Append("Hello");
        sb.Append(" World");
        return sb.ToString();
    }
    finally
    {
        _stringBuilderPool.Return(sb);
    }
}
```

---

## ğŸ¯ **äº‹ä»¶å¤„ç†ä¼˜åŒ–**

### **1. ä½¿ç”¨åˆé€‚çš„ä¼˜å…ˆçº§**

```csharp
// é¢„å¤„ç†ï¼ˆä½ä¼˜å…ˆçº§ï¼Œå…ˆæ‰§è¡Œï¼‰
_context.EventBus.Subscribe<PlayerJoinedEvent>(e =>
{
    // éªŒè¯ã€è¿‡æ»¤
}, EventPriority.Lowest);

// æ­£å¸¸å¤„ç†
_context.EventBus.Subscribe<PlayerJoinedEvent>(e =>
{
    // ä¸»è¦é€»è¾‘
}, EventPriority.Normal);

// åå¤„ç†ï¼ˆé«˜ä¼˜å…ˆçº§ï¼Œåæ‰§è¡Œï¼‰
_context.EventBus.Subscribe<PlayerJoinedEvent>(e =>
{
    // æ—¥å¿—ã€ç»Ÿè®¡
}, EventPriority.Monitor);
```

### **2. é¿å…é‡å¤è®¢é˜…**

```csharp
private bool _eventsRegistered = false;

public void OnEnable(IPluginContext context)
{
    if (!_eventsRegistered)
    {
        _context.EventBus.Subscribe<PlayerJoinedEvent>(OnPlayerJoined);
        _eventsRegistered = true;
    }
}
```

### **3. å¼‚å¸¸å¤„ç†**

```csharp
_context.EventBus.Subscribe<PlayerJoinedEvent>(async e =>
{
    try
    {
        await ProcessPlayerJoin(e.Player);
    }
    catch (Exception ex)
    {
        _context.Logger.Error($"å¤„ç†ç©å®¶åŠ å…¥å¤±è´¥: {ex.Message}");
        // ä¸è¦æŠ›å‡ºå¼‚å¸¸ï¼Œé¿å…å½±å“å…¶ä»–è®¢é˜…è€…
    }
});
```

---

## ğŸŒ **ç½‘ç»œä¼˜åŒ–**

### **1. æ‰¹é‡è¯·æ±‚**

```csharp
// âŒ å¤šæ¬¡è¯·æ±‚
foreach (var player in players)
{
    await _context.SmpApi.GetPlayerDataAsync(player);
}

// âœ… æ‰¹é‡è¯·æ±‚
var playerDataList = await _context.SmpApi.GetBatchPlayerDataAsync(players);
```

### **2. è¯·æ±‚å»é‡**

```csharp
private readonly Dictionary<string, Task<PlayerData>> _pendingRequests = new();

public async Task<PlayerData> GetPlayerDataAsync(string playerName)
{
    // å¦‚æœå·²æœ‰ç›¸åŒè¯·æ±‚æ­£åœ¨è¿›è¡Œï¼Œå¤ç”¨ç»“æœ
    lock (_pendingRequests)
    {
        if (_pendingRequests.TryGetValue(playerName, out var existingTask))
        {
            return await existingTask;
        }
    }
    
    // åˆ›å»ºæ–°è¯·æ±‚
    var task = FetchPlayerDataAsync(playerName);
    
    lock (_pendingRequests)
    {
        _pendingRequests[playerName] = task;
    }
    
    try
    {
        return await task;
    }
    finally
    {
        lock (_pendingRequests)
        {
            _pendingRequests.Remove(playerName);
        }
    }
}
```

---

## âœ… **æœ€ä½³å®è·µæ¸…å•**

### **é€šç”¨åŸåˆ™**

- âœ… ä½¿ç”¨ async/await è¿›è¡Œå¼‚æ­¥ç¼–ç¨‹
- âœ… ç¼“å­˜é¢‘ç¹è®¿é—®çš„æ•°æ®
- âœ… æ‰¹é‡å¤„ç†ä»£æ›¿é€ä¸ªå¤„ç†
- âœ… åŠæ—¶é‡Šæ”¾èµ„æºï¼ˆä½¿ç”¨ `using` æˆ– `Dispose`ï¼‰
- âœ… ç›‘æ§æ€§èƒ½æŒ‡æ ‡
- âœ… è®¾ç½®åˆç†çš„è¶…æ—¶æ—¶é—´
- âœ… åœ¨äº‹ä»¶å¤„ç†ä¸­é¿å…é˜»å¡æ“ä½œ

### **é¿å…çš„åšæ³•**

- âŒ åœ¨äº‹ä»¶å¤„ç†ä¸­ä½¿ç”¨ `Thread.Sleep`
- âŒ åŒæ­¥ I/O æ“ä½œï¼ˆæ–‡ä»¶ã€æ•°æ®åº“ã€ç½‘ç»œï¼‰
- âŒ æ— é™å¢é•¿çš„ç¼“å­˜
- âŒ èµ„æºæ³„æ¼ï¼ˆæœªé‡Šæ”¾æµã€è¿æ¥ã€å®šæ—¶å™¨ï¼‰
- âŒ åœ¨å¾ªç¯ä¸­æ‰§è¡Œè€—æ—¶æ“ä½œ
- âŒ è¿‡åº¦ä½¿ç”¨é”ï¼ˆå¯¼è‡´æ­»é”ï¼‰

### **ä»£ç å®¡æŸ¥æ£€æŸ¥ç‚¹**

- [ ] æ‰€æœ‰ I/O æ“ä½œæ˜¯å¦ä½¿ç”¨å¼‚æ­¥ï¼Ÿ
- [ ] ç¼“å­˜æ˜¯å¦æœ‰å¤§å°é™åˆ¶å’Œè¿‡æœŸæœºåˆ¶ï¼Ÿ
- [ ] èµ„æºæ˜¯å¦æ­£ç¡®é‡Šæ”¾ï¼Ÿ
- [ ] æ˜¯å¦æœ‰æ€§èƒ½ç›‘æ§å’Œæ—¥å¿—ï¼Ÿ
- [ ] å¼‚å¸¸æ˜¯å¦æ­£ç¡®å¤„ç†ï¼Ÿ
- [ ] æ˜¯å¦æœ‰è¶…æ—¶æœºåˆ¶ï¼Ÿ

---

## ğŸ“š **ç›¸å…³æ–‡æ¡£**

- [æ’ä»¶å¼€å‘æŒ‡å—](../03-æ’ä»¶å¼€å‘/æ’ä»¶å¼€å‘æŒ‡å—.md)
- [ç¤ºä¾‹æ’ä»¶é›†](./ç¤ºä¾‹æ’ä»¶é›†.md)
- [API å‚è€ƒ](../08-å‚è€ƒ/APIå‚è€ƒ.md)

---

**æ–‡æ¡£ç»´æŠ¤è€…ï¼š** NetherGate å¼€å‘å›¢é˜Ÿ  
**æœ€åæ›´æ–°ï¼š** 2025-10-05
