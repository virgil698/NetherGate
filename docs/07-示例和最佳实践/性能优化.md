# 性能优化指南

本指南介绍如何优化 NetherGate 插件的性能，提高服务器的整体运行效率。

---

## 📋 **目录**

- [性能分析](#性能分析)
- [异步编程](#异步编程)
- [缓存策略](#缓存策略)
- [数据库优化](#数据库优化)
- [内存管理](#内存管理)
- [事件处理优化](#事件处理优化)
- [网络优化](#网络优化)
- [最佳实践](#最佳实践)

---

## 📊 **性能分析**

### **1. 使用性能监视器**

```csharp
public class MyPlugin : IPlugin
{
    private IPluginContext _context = null!;

    public void OnEnable(IPluginContext context)
    {
        _context = context;
        
        // 启动性能监控
        var timer = new System.Timers.Timer(60000); // 每分钟
        timer.Elapsed += (s, e) => LogPerformanceMetrics();
        timer.Start();
    }

    private void LogPerformanceMetrics()
    {
        var metrics = _context.PerformanceMonitor.GetMetrics();
        
        _context.Logger.Info($"=== 性能指标 ===");
        _context.Logger.Info($"CPU 使用率: {metrics.CpuUsage:F1}%");
        _context.Logger.Info($"内存使用: {metrics.MemoryUsageMB:F0} MB");
        _context.Logger.Info($"服务器 TPS: {metrics.Tps:F1}");
        
        // 告警
        if (metrics.CpuUsage > 80)
        {
            _context.Logger.Warning("CPU 使用率过高！");
        }
        
        if (metrics.MemoryUsageMB > 4096)
        {
            _context.Logger.Warning("内存使用过高！");
        }
    }
}
```

### **2. 测量方法执行时间**

```csharp
public class PerformanceTimer : IDisposable
{
    private readonly string _operationName;
    private readonly ILogger _logger;
    private readonly Stopwatch _stopwatch;

    public PerformanceTimer(string operationName, ILogger logger)
    {
        _operationName = operationName;
        _logger = logger;
        _stopwatch = Stopwatch.StartNew();
    }

    public void Dispose()
    {
        _stopwatch.Stop();
        var elapsed = _stopwatch.ElapsedMilliseconds;
        
        if (elapsed > 100)
        {
            _logger.Warning($"{_operationName} 耗时 {elapsed}ms（较慢）");
        }
        else
        {
            _logger.Debug($"{_operationName} 耗时 {elapsed}ms");
        }
    }
}

// 使用
using (new PerformanceTimer("加载玩家数据", _context.Logger))
{
    await LoadPlayerDataAsync(playerName);
}
```

---

## ⚡ **异步编程**

### **1. 使用 async/await**

```csharp
// ❌ 阻塞式（会降低性能）
public void OnPlayerJoined(PlayerJoinedEvent e)
{
    Thread.Sleep(1000);  // 阻塞线程
    var data = LoadPlayerData(e.Player.Name);  // 同步 I/O
}

// ✅ 异步式（不阻塞）
public async void OnPlayerJoined(PlayerJoinedEvent e)
{
    await Task.Delay(1000);  // 异步等待
    var data = await LoadPlayerDataAsync(e.Player.Name);  // 异步 I/O
}
```

### **2. 并发执行多个任务**

```csharp
// ❌ 串行执行（慢）
foreach (var player in players)
{
    await SendWelcomeMessage(player);  // 逐个发送
}

// ✅ 并发执行（快）
var tasks = players.Select(p => SendWelcomeMessage(p));
await Task.WhenAll(tasks);
```

### **3. 避免在事件处理中阻塞**

```csharp
// ❌ 在事件处理中执行耗时操作
_context.EventBus.Subscribe<PlayerJoinedEvent>(e =>
{
    // 这会阻塞其他订阅者
    LoadHeavyData(e.Player.Name);
});

// ✅ 使用后台任务
_context.EventBus.Subscribe<PlayerJoinedEvent>(e =>
{
    _ = Task.Run(async () =>
    {
        await LoadHeavyDataAsync(e.Player.Name);
    });
});
```

### **4. 超时处理**

```csharp
public async Task<T> ExecuteWithTimeoutAsync<T>(
    Func<Task<T>> operation, 
    int timeoutMs = 5000)
{
    using var cts = new CancellationTokenSource(timeoutMs);
    
    try
    {
        return await operation().WaitAsync(cts.Token);
    }
    catch (OperationCanceledException)
    {
        _context.Logger.Warning("操作超时");
        throw;
    }
}

// 使用
var data = await ExecuteWithTimeoutAsync(
    () => LoadDataAsync(playerName),
    timeoutMs: 3000
);
```

---

## 🗄️ **缓存策略**

### **1. 内存缓存**

```csharp
public class PlayerDataCache
{
    private readonly Dictionary<string, CacheEntry<PlayerData>> _cache = new();
    private readonly TimeSpan _expiration = TimeSpan.FromMinutes(5);

    public async Task<PlayerData> GetOrLoadAsync(string playerName, 
        Func<string, Task<PlayerData>> loader)
    {
        // 检查缓存
        if (_cache.TryGetValue(playerName, out var entry))
        {
            if (DateTime.UtcNow - entry.Timestamp < _expiration)
            {
                return entry.Data;
            }
            
            // 缓存过期，移除
            _cache.Remove(playerName);
        }
        
        // 加载数据
        var data = await loader(playerName);
        
        // 存入缓存
        _cache[playerName] = new CacheEntry<PlayerData>
        {
            Data = data,
            Timestamp = DateTime.UtcNow
        };
        
        return data;
    }

    public void Invalidate(string playerName)
    {
        _cache.Remove(playerName);
    }

    public void Clear()
    {
        _cache.Clear();
    }
}

public class CacheEntry<T>
{
    public T Data { get; set; } = default!;
    public DateTime Timestamp { get; set; }
}
```

### **2. LRU 缓存（最近最少使用）**

```csharp
public class LruCache<TKey, TValue> where TKey : notnull
{
    private readonly int _capacity;
    private readonly Dictionary<TKey, LinkedListNode<CacheItem>> _cache;
    private readonly LinkedList<CacheItem> _lru;

    public LruCache(int capacity)
    {
        _capacity = capacity;
        _cache = new Dictionary<TKey, LinkedListNode<CacheItem>>(capacity);
        _lru = new LinkedList<CacheItem>();
    }

    public bool TryGet(TKey key, out TValue value)
    {
        if (_cache.TryGetValue(key, out var node))
        {
            // 移到链表头部（最近使用）
            _lru.Remove(node);
            _lru.AddFirst(node);
            
            value = node.Value.Value;
            return true;
        }
        
        value = default!;
        return false;
    }

    public void Add(TKey key, TValue value)
    {
        if (_cache.TryGetValue(key, out var existingNode))
        {
            // 更新现有项
            _lru.Remove(existingNode);
            _lru.AddFirst(existingNode);
            existingNode.Value.Value = value;
            return;
        }
        
        // 检查容量
        if (_cache.Count >= _capacity)
        {
            // 移除最久未使用的项
            var lastNode = _lru.Last!;
            _lru.RemoveLast();
            _cache.Remove(lastNode.Value.Key);
        }
        
        // 添加新项
        var newNode = _lru.AddFirst(new CacheItem { Key = key, Value = value });
        _cache[key] = newNode;
    }

    private class CacheItem
    {
        public TKey Key { get; set; } = default!;
        public TValue Value { get; set; } = default!;
    }
}

// 使用
private LruCache<string, PlayerData> _playerCache = new(100); // 最多100个

public PlayerData GetPlayerData(string playerName)
{
    if (_playerCache.TryGet(playerName, out var data))
    {
        return data;
    }
    
    data = LoadPlayerData(playerName);
    _playerCache.Add(playerName, data);
    return data;
}
```

### **3. 定期清理过期缓存**

```csharp
public class MyPlugin : IPlugin
{
    private Timer? _cacheCleanupTimer;

    public void OnEnable(IPluginContext context)
    {
        // 每小时清理一次缓存
        _cacheCleanupTimer = new Timer(_ => CleanupCache(), 
            null, TimeSpan.Zero, TimeSpan.FromHours(1));
    }

    private void CleanupCache()
    {
        var before = _cache.Count;
        
        // 移除过期项
        var expiredKeys = _cache
            .Where(kvp => DateTime.UtcNow - kvp.Value.Timestamp > TimeSpan.FromMinutes(30))
            .Select(kvp => kvp.Key)
            .ToList();
        
        foreach (var key in expiredKeys)
        {
            _cache.Remove(key);
        }
        
        var after = _cache.Count;
        _context.Logger.Debug($"缓存清理：移除 {before - after} 个过期项");
    }

    public void OnDisable()
    {
        _cacheCleanupTimer?.Dispose();
    }
}
```

---

## 🗃️ **数据库优化**

### **1. 批量操作**

```csharp
// ❌ 逐条插入（慢）
foreach (var player in players)
{
    await database.InsertAsync(player);
}

// ✅ 批量插入（快）
await database.BulkInsertAsync(players);
```

### **2. 连接池**

```csharp
public class DatabasePool
{
    private readonly SemaphoreSlim _semaphore;
    private readonly Queue<DbConnection> _pool = new();
    private readonly string _connectionString;

    public DatabasePool(string connectionString, int maxConnections = 10)
    {
        _connectionString = connectionString;
        _semaphore = new SemaphoreSlim(maxConnections, maxConnections);
    }

    public async Task<DbConnection> GetConnectionAsync()
    {
        await _semaphore.WaitAsync();
        
        lock (_pool)
        {
            if (_pool.Count > 0)
            {
                return _pool.Dequeue();
            }
        }
        
        var connection = CreateConnection();
        await connection.OpenAsync();
        return connection;
    }

    public void ReturnConnection(DbConnection connection)
    {
        lock (_pool)
        {
            _pool.Enqueue(connection);
        }
        
        _semaphore.Release();
    }

    private DbConnection CreateConnection()
    {
        // 创建数据库连接
        return new SqlConnection(_connectionString);
    }
}
```

### **3. 异步查询**

```csharp
public async Task<List<PlayerData>> GetTopPlayersAsync(int count)
{
    await using var connection = await _dbPool.GetConnectionAsync();
    
    return await connection.QueryAsync<PlayerData>(
        "SELECT * FROM players ORDER BY score DESC LIMIT @Count",
        new { Count = count }
    ).ToListAsync();
}
```

---

## 💾 **内存管理**

### **1. 使用弱引用**

```csharp
// 对于大对象或不常用的缓存
private Dictionary<string, WeakReference<PlayerData>> _weakCache = new();

public PlayerData? GetPlayerData(string playerName)
{
    if (_weakCache.TryGetValue(playerName, out var weakRef))
    {
        if (weakRef.TryGetTarget(out var data))
        {
            return data;
        }
        
        // 引用已被回收
        _weakCache.Remove(playerName);
    }
    
    return null;
}
```

### **2. 及时释放资源**

```csharp
public class ResourceManagement
{
    private Stream? _stream;
    private Timer? _timer;

    public void Initialize()
    {
        _stream = File.OpenRead("data.txt");
        _timer = new Timer(_ => DoWork(), null, 0, 1000);
    }

    public void Cleanup()
    {
        // 释放资源
        _stream?.Dispose();
        _stream = null;
        
        _timer?.Dispose();
        _timer = null;
    }
}

// 或使用 using
public async Task ProcessFileAsync(string path)
{
    await using var stream = File.OpenRead(path);
    // 自动释放
}
```

### **3. 对象池**

```csharp
public class ObjectPool<T> where T : class, new()
{
    private readonly ConcurrentBag<T> _objects = new();
    private readonly int _maxSize;

    public ObjectPool(int maxSize = 100)
    {
        _maxSize = maxSize;
    }

    public T Rent()
    {
        if (_objects.TryTake(out var obj))
        {
            return obj;
        }
        
        return new T();
    }

    public void Return(T obj)
    {
        if (_objects.Count < _maxSize)
        {
            _objects.Add(obj);
        }
    }
}

// 使用
private ObjectPool<StringBuilder> _stringBuilderPool = new();

public string BuildMessage()
{
    var sb = _stringBuilderPool.Rent();
    try
    {
        sb.Clear();
        sb.Append("Hello");
        sb.Append(" World");
        return sb.ToString();
    }
    finally
    {
        _stringBuilderPool.Return(sb);
    }
}
```

---

## 🎯 **事件处理优化**

### **1. 使用合适的优先级**

```csharp
// 预处理（低优先级，先执行）
_context.EventBus.Subscribe<PlayerJoinedEvent>(e =>
{
    // 验证、过滤
}, EventPriority.Lowest);

// 正常处理
_context.EventBus.Subscribe<PlayerJoinedEvent>(e =>
{
    // 主要逻辑
}, EventPriority.Normal);

// 后处理（高优先级，后执行）
_context.EventBus.Subscribe<PlayerJoinedEvent>(e =>
{
    // 日志、统计
}, EventPriority.Monitor);
```

### **2. 避免重复订阅**

```csharp
private bool _eventsRegistered = false;

public void OnEnable(IPluginContext context)
{
    if (!_eventsRegistered)
    {
        _context.EventBus.Subscribe<PlayerJoinedEvent>(OnPlayerJoined);
        _eventsRegistered = true;
    }
}
```

### **3. 异常处理**

```csharp
_context.EventBus.Subscribe<PlayerJoinedEvent>(async e =>
{
    try
    {
        await ProcessPlayerJoin(e.Player);
    }
    catch (Exception ex)
    {
        _context.Logger.Error($"处理玩家加入失败: {ex.Message}");
        // 不要抛出异常，避免影响其他订阅者
    }
});
```

---

## 🌐 **网络优化**

### **1. 批量请求**

```csharp
// ❌ 多次请求
foreach (var player in players)
{
    await _context.SmpApi.GetPlayerDataAsync(player);
}

// ✅ 批量请求
var playerDataList = await _context.SmpApi.GetBatchPlayerDataAsync(players);
```

### **2. 请求去重**

```csharp
private readonly Dictionary<string, Task<PlayerData>> _pendingRequests = new();

public async Task<PlayerData> GetPlayerDataAsync(string playerName)
{
    // 如果已有相同请求正在进行，复用结果
    lock (_pendingRequests)
    {
        if (_pendingRequests.TryGetValue(playerName, out var existingTask))
        {
            return await existingTask;
        }
    }
    
    // 创建新请求
    var task = FetchPlayerDataAsync(playerName);
    
    lock (_pendingRequests)
    {
        _pendingRequests[playerName] = task;
    }
    
    try
    {
        return await task;
    }
    finally
    {
        lock (_pendingRequests)
        {
            _pendingRequests.Remove(playerName);
        }
    }
}
```

---

## ✅ **最佳实践清单**

### **通用原则**

- ✅ 使用 async/await 进行异步编程
- ✅ 缓存频繁访问的数据
- ✅ 批量处理代替逐个处理
- ✅ 及时释放资源（使用 `using` 或 `Dispose`）
- ✅ 监控性能指标
- ✅ 设置合理的超时时间
- ✅ 在事件处理中避免阻塞操作

### **避免的做法**

- ❌ 在事件处理中使用 `Thread.Sleep`
- ❌ 同步 I/O 操作（文件、数据库、网络）
- ❌ 无限增长的缓存
- ❌ 资源泄漏（未释放流、连接、定时器）
- ❌ 在循环中执行耗时操作
- ❌ 过度使用锁（导致死锁）

### **代码审查检查点**

- [ ] 所有 I/O 操作是否使用异步？
- [ ] 缓存是否有大小限制和过期机制？
- [ ] 资源是否正确释放？
- [ ] 是否有性能监控和日志？
- [ ] 异常是否正确处理？
- [ ] 是否有超时机制？

---

## 📚 **相关文档**

- [插件开发指南](../03-插件开发/插件开发指南.md)
- [示例插件集](./示例插件集.md)
- [API 参考](../08-参考/API参考.md)

---

**文档维护者：** NetherGate 开发团队  
**最后更新：** 2025-10-05
